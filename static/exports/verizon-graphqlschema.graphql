# API Name: "Verizon"
# Host: https://5gedge.verizon.com/api/mec/eds
# The Verizon Edge Discovery Service API can direct your application clients to connect to the optimal service endpoints for your Multi-access Edge Computing (MEC) applications for every session. The Edge Discovery Service takes into account the current location of a device, its IP anchor location, current network traffic and other factors to determine which 5G Edge platform a device should connect to.

"The category of application client."
enum ClientType {
    ANALYTICS
    AR
    COMPUTERVISION
    GAMING
    IOT
    MACHINELEARNING
    ROBOTICS
    V2X
    VR
}

"Status of the MEC Platform (default is 'unknown')"
enum MECPlatformStatus {
    ACTIVE
    INACTIVE
    UNKNOWN
}

"Type of User Equipment identifier used in `UEIdentity`."
enum UserEquipmentIdentityType {
    IPADDRESS
}

"The current status of the callback response."
enum RequestStatus {
    FAILURE
    PENDING
    SUCCESS
}

"Accurary, currently only 0-coarse supported."
enum AccuracyMode {
    _0
}

"Location cache mode."
enum CacheMode {
    _0
    _1
    _2
}

"The name of the callback service."
enum CallbackServiceName {
    DEVICELOCATION
    LOCATION
}

"Status of the report."
enum ReportStatus {
    COMPLETED
    INPROGRESS
    QUEUED
}

"Service name"
enum ServiceName {
    FOTA
    LOCATION
}

"Callback type. Must be 'Fota' for Software Management Services API."
enum CallbackService {
    FOTA
}

"The status of the upgrades that you want to retrieve."
enum UpgradeStatus {
    FINISHED
    INPROGRESS
    QUEUED
    REQUESTFAILED
    REQUESTPENDING
    UPGRADEFAILED
}

"Possible values are `append` or `remove`"
enum FirmwareTypeList {
    APPEND
    REMOVE
}

"Current status of the campaign."
enum CampaignStatus {
    CAMPAIGNABORTED
    CAMPAIGNCANCELLED
    CAMPAIGNENDED
    CAMPAIGNFAILED
    CAMPAIGNREQUESTFAILED
    CAMPAIGNREQUESTPENDING
    CAMPAIGNREQUESTQUEUED
    CAMPAIGNSCHEDULED
}

"Firmware protocol. Valid values include: LWM2M, OMD-DM."
enum CampaignMetaInfoProtocol {
    LWM2M
    OMDDM
}

"Firmware protocol. Valid values include: LWM2M, OMADM, HTTP."
enum DevicesProtocol {
    HTTP
    LWM2M
    OMDADM
}

"Firmware protocol. Valid values include: LWM2M, OMD-DM, all."
enum FirmwareProtocol {
    ALL
    LWM2M
    OMDDM
}

"Attribute identifier."
enum AttributeIdentifier {
    CELL_ID
    LINK_QUALITY
    MANUFACTURER
    NETWORK_BEARER
    RADIO_SIGNAL_STRENGTH
}

"Unit of time."
enum NumericalDataUnit {
    DAY
    HOUR
    MINUTE
    SECOND
}

"Error Code."
enum ErrorResponseCode {
    INTERNAL_ERROR
    INVALID_ACCESS
    INVALID_PARAMETER
    SUCCESS
}

"Possible response codes."
enum ResponseCode {
    INTERNAL_ERROR
    INVALID_ACCESS
    INVALID_PARAMETER
    SUCCESS
}

"HTML error code and description."
enum HttpStatusCode {
    _100CONTINUE
    _101SWITCHING_PROTOCOLS
    _102PROCESSING
    _103CHECKPOINT
    _200OK
    _201CREATED
    _202ACCEPTED
    _203NON_AUTHORITATIVE_INFORMATION
    _204NO_CONTENT
    _205RESET_CONTENT
    _206PARTIAL_CONTENT
    _207MULTI_STATUS
    _208ALREADY_REPORTED
    _226IM_USED
    _300MULTIPLE_CHOICES
    _301MOVED_PERMANENTLY
    _302FOUND
    _302MOVED_TEMPORARILY
    _303SEE_OTHER
    _304NOT_MODIFIED
    _305USE_PROXY
    _307TEMPORARY_REDIRECT
    _308PERMANENT_REDIRECT
    _400BAD_REQUEST
    _401UNAUTHORIZED
    _402PAYMENT_REQUIRED
    _403FORBIDDEN
    _404NOT_FOUND
    _405METHOD_NOT_ALLOWED
    _406NOT_ACCEPTABLE
    _407PROXY_AUTHENTICATION_REQUIRED
    _408REQUEST_TIMEOUT
    _409CONFLICT
    _410GONE
    _411LENGTH_REQUIRED
    _412PRECONDITION_FAILED
    _413PAYLOAD_TOO_LARGE
    _413REQUEST_ENTITY_TOO_LARGE
    _414REQUEST_URI_TOO_LONG
    _414URI_TOO_LONG
    _415UNSUPPORTED_MEDIA_TYPE
    _416REQUESTED_RANGE_NOT_SATISFIABLE
    _417EXPECTATION_FAILED
    _418I_AM_A_TEAPOT
    _419INSUFFICIENT_SPACE_ON_RESOURCE
    _420METHOD_FAILURE
    _421DESTINATION_LOCKED
    _422UNPROCESSABLE_ENTITY
    _423LOCKED
    _424FAILED_DEPENDENCY
    _425TOO_EARLY
    _426UPGRADE_REQUIRED
    _428PRECONDITION_REQUIRED
    _429TOO_MANY_REQUESTS
    _431REQUEST_HEADER_FIELDS_TOO_LARGE
    _451UNAVAILABLE_FOR_LEGAL_REASONS
    _500INTERNAL_SERVER_ERROR
    _501NOT_IMPLEMENTED
    _502BAD_GATEWAY
    _503SERVICE_UNAVAILABLE
    _504GATEWAY_TIMEOUT
    _505HTTP_VERSION_NOT_SUPPORTED
    _506VARIANT_ALSO_NEGOTIATES
    _507INSUFFICIENT_STORAGE
    _508LOOP_DETECTED
    _509BANDWIDTH_LIMIT_EXCEEDED
    _510NOT_EXTENDED
    _511NETWORK_AUTHENTICATION_REQUIRED
}

"QUEUED or COMPLETED. Requests for IoT devices with cacheMode=0 (cached) have status=COMPLETED; all other requests are QUEUED."
enum AggregatedReportCallbackStatus {
    COMPLETED
    QUEUED
}

enum CycleType {
    CYCLEONE
    CYCLETWO
}

enum Status1 {
    FAILED
    SUCCESS
}

"The type of the client that is to be registered. This is one of the major traffic participant groups considered in V2X communication. The system uses this value to define which topics the client will be able to publish and subscribe to.\n\nValues:\n- **Vehicle** - Vehicle with an enclosure around the passengers. (Subtypes: PassengerCar, Truck, Bus, EmergencyVehicle, SchoolBus, MaintenanceVehicle)\n- **VulnerableRoadUser** - Traffic participants without a protecting enclosure. (Subtypes: Motorcycle, Bicycle, Pedestrian, Scooter)\n- **TrafficLightController** - A Traffic light controller system. (Subtypes: NA)\n- **InfrastructureSensor** - Sensors that are deployed in the infrastructure. (Subtypes: RoadSideUnit, Camera, Lidar, Radar, InductiveLoop, MagneticSensor)\n- **OnboardSensor** - Sensors that are onboard on a vehicle(Subtypes: Camera, Lidar, Radar)\n- **Software** - A software system or application. (Subtypes: NA)"
enum IMPClientType {
    INFRASTRUCTURESENSOR
    ONBOARDSENSOR
    SOFTWARE
    TRAFFICLIGHTCONTROLLER
    VEHICLE
    VULNERABLEROADUSER
}

"The type of the device's network connection at the time of the request. If the device is on the Verizon cellular network it should use the \"VZ\" value otherwise the \"non-VZ\" value.\n\nDevices on the Verizon network can directly access the IMP Message Exchange on the MEC (Mobile Edge Compute server)"
enum IMPNetworkType {
    NONVZ
    VZ
}

"The type of action the vendor registration service took for the request\n\nValues:\n- **Added** - A new vendor was added to the system\n- **Updated** - The existing vendor was updated with the newly provided properties"
enum ActionType {
    ADDED
    UPDATED
}

"The subtype or subgroup of the client type. This further specifies the client type. For example it will specify if the client is a passenger car or a truck. See the ClientType description for the supported Subtypes for each client type."
enum ClientSubtype {
    BICYCLE
    BUS
    CAMERA
    EMERGENCYVEHICLE
    INDUCTIVELOOP
    LIDAR
    MAGNETICSENSOR
    MAINTENANCEVEHICLE
    MOTORCYCLE
    NA
    PASSENGERCAR
    PEDESTRIAN
    RADAR
    ROADSIDEUNIT
    SCHOOLBUS
    SCOOTER
    TRUCK
}

"Response on successful deletion of service profile."
type DeleteServiceProfileResult {
    status: String!
    message: String!
}

"Response on successful update of service profile."
type UpdateServiceProfileResult {
    "HTTP status code."
    status: String!
    "Service Profile that are updated or error details in case of an error."
    message: String!
}

"Response on successful retrieval of service profiles."
type ListServiceProfilesResult {
    "HTTP status code."
    status: String!
    "A comma delimited list of all the service profiles registered under your API key."
    data: [String!]
}

"A successful request returns a serviceProfileId that you can use in subsequent requests."
type CreateServiceProfileResult {
    "Unique identifier for a service profile."
    serviceProfileId: String!
}

"Response to deregister an application's Service Endpoint from one or more Multi-access Edge Compute (MEC) Platforms."
type DeregisterServiceEndpointResult {
    "HTTP status code."
    status: String!
    "EdgeAppServicesID that are deleted or error details in case of an error."
    message: String!
}

"Response to update registered Service Endpoint information."
type UpdateServiceEndpointResult {
    "HTTP status code."
    status: String!
    "EdgeAppServices are updated or error details in case of an error."
    message: String!
}

"Response on successful retrieval of all registered service endpoints."
type ListAllServiceEndpointsResult {
    "HTTP status code."
    status: String!
    "A comma delimited list of all registered service endpoints."
    data: [String!]
}

"Response to register Service Endpoints of a deployed application to specified Muli-access Edge Compute (MEC) Platforms."
type RegisterServiceEndpointResult {
    "A system-defined string identifier representing one or more registered Service Endpoints."
    serviceEndpointsId: String!
}

"Response on successful retrieval of optimal service endpoints for clients."
type ListOptimalServiceEndpointsResult {
    "An array of optimal Service Endpoint IDs for clients to connect to."
    serviceEndpoints: [ResourcesEdgeHostedService!]
}

"Response to return an array of all regions in the Verizon 5G Edge service. You can use the region IDs from the response to find optimal Edge platforms or service endpoints."
type ListRegionsResult {
    "An array of all regions in the Verizon 5G Edge service."
    regions: [Region!]
}

"Response to return the optimal 5G Edge platforms for deployment based on a region, service profile of the service that you want to deploy or user equipment."
type ListMECPlatformsResult {
    "A list of optimal MEC Platforms where you can register your deployed application."
    mECPlatforms: [MECPlatformResource!]
}

"Information about the resource requirements and service characteristics of an edge application. The `maxLatencyMs` and `clientType` parameters are both required in the request body. **Note:** The `maxLatencyMs` value must be submitted in multiples of 5. Does not include serviceProfileId"
type ResourcesServiceProfile {
    "The category of application client."
    clientType: ClientType!
    "Identity of the preferred Edge Computing Service Provider."
    ecspFilter: String!
    "The expected operation schedule of the application client (e.g. time windows)."
    clientSchedule: String!
    "The expected location(s) (e.g. route) of the hosting UE during the Client's operation schedule."
    clientServiceArea: String!
    "Network resources of a service profile."
    networkResources: NetworkResourcesType!
    "Compute resources of a service profile."
    computeResources: ComputeResourcesType!
    "Additional service support information for the MEC platform."
    properties: MECPlatformsAdditionalSupportInfo!
}

"Information about the resource requirements and service characteristics of an edge application. Includes serviceProfileId. Used when retrieving a service profile."
type ResourcesServiceProfileWithId {
    "Unique identifier for a service profile."
    serviceProfileId: String!
    "The category of application client."
    clientType: ClientType!
    "Identity of the preferred Edge Computing Service Provider."
    ecspFilter: String!
    "The expected operation schedule of the application client (e.g. time windows)."
    clientSchedule: String!
    "The expected location(s) (e.g. route) of the hosting UE during the Client's operation schedule."
    clientServiceArea: String!
    "Network resources of a service profile."
    networkResources: NetworkResourcesType!
    "Compute resources of a service profile."
    computeResources: ComputeResourcesType!
    "Additional service support information for the MEC platform."
    properties: MECPlatformsAdditionalSupportInfo!
}

"Additional service support information for the MEC platform."
type MECPlatformsAdditionalSupportInfo {
    "Type of additional service support information for the MEC platform."
    type: String!
    "Data about additional service support information for the MEC platform."
    data: MECPlatformsAdditionalSupportInfoData!
}

"Data about additional service support information for the MEC platform."
type MECPlatformsAdditionalSupportInfoData {
    additionalInfo: String!
}

"Edge hosted service represented by Service Endpoint definition."
type ResourcesEdgeHostedService {
    "Edge Resource Name. A string identifier for a set of edge resources."
    ern: String!
    "Service Endpoint path, address, and port."
    serviceEndpoint: ResourcesServiceEndpoint!
    "Unique ID representing the Edge Application Provider."
    applicationServerProviderId: String!
    "Unique ID representing the Edge Application."
    applicationId: String!
    serviceDescription: String!
}

"Edge hosted service represented by Service Endpoint definition."
type ResourcesEdgeHostedServiceWithProfileId {
    "Edge Resource Name. A string identifier for a set of edge resources."
    ern: String!
    "Service Endpoint path, address, and port."
    serviceEndpoint: ResourcesServiceEndpoint!
    "Unique ID representing the Edge Application Provider."
    applicationServerProviderId: String!
    "Unique ID representing the Edge Application."
    applicationId: String!
    serviceDescription: String!
    "The system assigned ID of the service profile."
    serviceProfileID: String!
}

"Service Endpoint path, address, and port."
type ResourcesServiceEndpoint {
    "URI of Service Endpoint if available."
    uRI: String!
    "FQDN of Service Endpoint if available."
    fQDN: String!
    "IPv4 Address of Service Endpoint if available."
    iPv4Address: String!
    "IPv6 Address of Service Endpoint if available."
    iPv6Address: String!
    "Port information of Service Endpoint if IPv4 or IPv6 is mentioned."
    port: Int!
}

"Information representing a certain geographical or logical area where MEC resources and services are provided."
type Region {
    "The unique identifier of the region."
    regionId: String
    "A relevant and identifiable region name."
    name: String
    "A two-character alpha code for a country, based on ISO 3166-1 alpha-2. This is future functionality, so the value returned is 'null'."
    countryCode: String
    "The metropolitan area or 'City' value.  This is future functionality, so the value returned is 'null'."
    metro: String
    "This is a sub-set of 'City' and is similar to 'Zone'. This is future functionality, so the value returned is 'null'."
    area: String
}

"5G Edge platform used for deployment of a service. The ern of each platform contains the name of the matching AWS Wavelength zone that can be used when deploying."
type MECPlatformResource {
    "Edge Resource Name. A string identifier for a set of edge resources."
    ern: String!
    "Unique identifier representing a zone. *Note:* This will have a null value as a placeholder."
    zone: String
    "MEC region name. Current valid values are US_WEST_2 and US_EAST_1."
    region: String!
    "Status of the MEC Platform (default is 'unknown')"
    status: MECPlatformStatus!
    properties: String!
}

"Network resources of a service profile."
type NetworkResourcesType {
    "Minimum required connection bandwidth in Kbit/s for the application."
    minBandwidthKbits: Int!
    "Indicates if service continuity support is required or not for the application."
    serviceContinuitySupport: Boolean!
    "Maximum request rate that the application can handle."
    maxRequestRate: Int!
    "Maximum response time or latency that the application can handle, in milliseconds. Note: this value must be in multiples of 5."
    maxLatencyMs: Int!
    "Minimum availability required for the server."
    minAvailability: Int!
}

"Compute resources of a service profile."
type ComputeResourcesType {
    "GPU resources of a service profile."
    gPU: GPU!
    "Minimum RAM required in Gigabytes."
    minRAMGB: Int!
    "Minimum storage requirement in Gigabytes."
    minStorageGB: Int!
}

"GPU resources of a service profile."
type GPU {
    "Minimum Core Clock value in megahertz."
    minCoreClockMHz: Int!
    "Minimum Memory Clock value in megahertz."
    minMemoryClockMHz: Int!
    "Minimum GPU bandwidth in GB/s."
    minBandwidthGBs: Int!
    "Minimum Floating Point Operations Per Second in Teraflops."
    minTFLOPS: Int!
}

"Base type for all errors."
type EdgeDiscoveryResult {
    "HTTP status code or status of response."
    status: String!
    "Error details."
    message: String!
    "For cases where user input exceeds the boundary values an additional 'data' key will be returned with a relevant description."
    data: EdgeDiscoveryResultData!
}

"For cases where user input exceeds the boundary values an additional 'data' key will be returned with a relevant description."
type EdgeDiscoveryResultData {
    additionalMessage: String!
}

"Returns information about a specified account."
type Account {
    "The name of the account."
    accountName: String!
    "The billing number of the account."
    accountNumber: String!
    "The name of the organization that the account is part of."
    organizationName: String!
    "True if devices can be added to the account and activated with a single request. False if devices must be added to the account before they can be activated."
    isProvisioningAllowed: Boolean!
    "The names of all carriers for the account."
    carriers: [String!]
    "The names of features that are enabled for the account."
    features: [String!]
    "Array of IP pools that are available to the account."
    iPPools: [IPPool!]
    "Array of service plans that are available to the account."
    servicePlans: [ServicePlan!]
}

"Request to add the devices."
type AddDevicesRequest {
    "The billing account to which the devices are added."
    accountName: String!
    "The names and values for any custom fields that you want set for the devices as they are added to the account."
    customFields: [CustomFields!]
    "The devices that you want to add."
    devicesToAdd: [AccountDeviceList!]
    "The name of a device group to add the devices to. They are added to the default device group if you don't include this parameter."
    groupName: String!
    "The Stock Keeping Unit (SKU) number of a 4G device type with an embedded SIM."
    skuNumber: String!
    "The initial service state for the devices. The only valid state is “Preactive.”"
    state: String!
    smsrOid: String!
}

"Contains the device identifiers and a success or failure response for each device in the request."
type AddDevicesResult {
    "Identifiers for the device."
    deviceIds: [DeviceId!]
    "The success message or error message for the current device."
    response: String!
}

"The customer address for the line's primary place of use, for line usage taxation."
type Address {
    "The street address for the line's primary place of use. This must be a physical address for taxation; it cannot be a P.O. box."
    addressLine1: String!
    "Optional additional street address information."
    addressLine2: String!
    "The city for the line's primary place of use."
    city: String!
    "The state for the line's primary place of use."
    state: String!
    "The ZIP code for the line's primary place of use."
    zip: String!
    "The ZIP+4 for the line's primary place of use."
    zip4: String!
    "Either “US” or “USA” for the country of the line's primary place of use."
    country: String!
    "A phone number where the customer can be reached."
    phone: String!
    "A single letter to indicate the customer phone type."
    phoneType: String!
    "An email address for the customer."
    emailAddress: String!
}

"Includes callback listeners that were registered through the Connectivity Management API."
type ConnectivityManagementCallback {
    "The name of the billing account for which callback messages will be sent."
    accountName: String!
    "The password defined when a URL was registered for the callback service, or an empty string if no password was defined."
    password: String!
    "The name of the callback service, which identifies the type and format of messages that will be sent to the registered URL."
    serviceName: String!
    "The address of the callback listening service where the ThingSpace Platform will send callback messages for the service type."
    url: String!
    "The username defined when a URL was registered for the callback service, or an empty string if no username was defined."
    username: String!
}

"Response to a callback action."
type CallbackActionResult {
    "The name of the billing account."
    accountName: String!
    "The name of the callback service that was registered/deregistered."
    serviceName: String!
}

"Request for a carrier action."
type CarrierActionsRequest {
    "The name of a billing account."
    accountName: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFields!]
    "The devices for which you want to restore service, specified by device identifier."
    devices: [AccountDeviceList!]
    "The name of a device group, if you want to restore service for all devices in that group."
    groupName: String!
    "The name of a service plan, if you want to only include devices that have that service plan."
    servicePlan: String!
}

type NotificationReportStatusRequest {
    "The name of a billing account."
    accountName: String!
    "An identifier for a single device."
    device: DeviceId!
    "The time at which the request expires."
    requestExpirationTime: String!
    "The type of request."
    requestType: String!
}

type RetrieveMonitorsRequest {
    "The name of a billing account."
    accountName: String!
    "The devices for which you want to restore service, specified by device identifier."
    devices: [AccountDeviceList!]
    "The name of a billing account."
    monitorType: String!
}

"Request for carrier activation."
type CarrierActivateRequest {
    "The name of a billing account."
    accountName: String!
    "The private IP pool (Carrier Group Name) from which your device IP addresses will be derived."
    carrierIpPoolName: String!
    "The carrier that will perform the activation."
    carrierName: String!
    "A string to identify the cost center that the device is associated with."
    costCenterCode: String!
    "A user-defined descriptive field, limited to 50 characters."
    customFields: [CustomFields!]
    "Up to 10,000 devices for which you want to activate service, specified by device identifier."
    devices: [AccountDeviceList!]
    "If you specify devices by ID in the devices parameters, this is the name of a device group that the devices should be added to.If you don't specify individual devices with the devices parameter, you can provide the name of a device group to activate all devices in that group."
    groupName: String!
    "The ID of a “Qualified” or “Closed - Won” VPP customer lead, which is used with other values to determine MDN assignment, taxation, and compensation."
    leadId: String!
    "The Zip code of the location where the line of service will primarily be used, or a Zip code that you have been told to use with these devices. For accounts that are configured for geographic numbering, this is the ZIP code from which the MDN will be derived."
    mdnZipCode: String!
    "The customer name and the address of the device's primary place of use. Leave these fields empty to use the account profile address as the primary place of use. These values will be applied to all devices in the request.If the account is enabled for non-geographic MDNs and the device supports it, the primaryPlaceOfUse address will also be used to derive the MDN for the device."
    primaryPlaceOfUse: PlaceOfUse!
    "For devices with static IP addresses on the public network, this specifies whether the devices have general access to the Internet."
    publicIpRestriction: String!
    "The service plan code that you want to assign to all specified devices."
    servicePlan: String!
    "The Stock Keeping Unit (SKU) of a 4G device type can be used with ICCID device identifiers in lieu of an IMEI when activating 4G devices. The SkuNumber will be used with all devices in the request, so all devices must be of the same type."
    skuNumber: String!
}

"Request to deactivate a carrier."
type CarrierDeactivateRequest {
    "The name of a billing account."
    accountName: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFields!]
    "The devices for which you want to deactivate service, specified by device identifier."
    devices: [AccountDeviceList!]
    "Fees may be assessed for deactivating Verizon Wireless devices, depending on the account contract. The etfWaiver parameter waives the Early Termination Fee (ETF), if applicable."
    etfWaiver: Boolean!
    "The name of a device group, if you want to deactivate all devices in that group."
    groupName: String!
    "Code identifying the reason for the deactivation. Currently the only valid reason code is “FF”, which corresponds to General Admin/Maintenance."
    reasonCode: String!
    "The name of a service plan, if you want to only include devices that have that service plan."
    servicePlan: String!
    deleteAfterDeactivation: Boolean!
}

"Information about the carrier."
type CarrierInformation {
    "The carrier that will perform the activation. This parameter is only required if you have more than one carrier."
    carrierName: String!
    "The service plan code that is assigned to the device."
    servicePlan: String!
    "The device state. Valid values include: Activate, Suspend, Deactive, Pre-active."
    state: String!
}

"Changes the identifier of a 3G or 4G device to match hardware changes made for a line of service. Use this request to transfer the line of service and the MDN to new hardware, or to change the MDN."
type ChangeDeviceIdRequest {
    "Set to true to assign a non-Geo MDN and MSISDN, or false to assign an MDN and MSISDN from a specific NPA-NXX."
    assignNonGeoMdn: Boolean!
    "The type of change that you want to make for a 4G device."
    change4gOption: String!
    "The device that you want to change, specified by a device identifier."
    deviceIds: [DeviceId!]
    "The new identifier for the device. Required for all change4GOptions except ChangeMSISDN."
    deviceIdsTo: [DeviceId!]
    "The NPA NXX (area code and prefix) from which the MDN and MSISDN will be derived when assignNonGeoMDN is false. Specify the 6-digit NPA NXX of the location where the line of service will primarily be used. This API checks to see if a number starting with the NPA NXX is available. If not, this API uses the zipCode parameter, if specified, to assign a number in the area of the line of service. This parameter is required when you change an MDN/MSISDN for a B2B carrier, such as Verizon Wireless."
    npaNxx: String!
    "The code for a different service plan, if you want to change the service plan while changing the device identifier. Set this parameter to one of the Code values returned by GET /plans."
    servicePlan: String!
    "The ZIP code from which the MDN and MSISDN will be derived when assignNonGeoMDN is true. Specify the zip code of the location where the line of service will primarily be used."
    zipCode: String!
    smsrOid: String!
}

"Network connection events for a device during a specified time period."
type ConnectionEvent {
    "The attributes that describe the connection event."
    connectionEventAttributes: [CustomFields!]
    "Currently not used."
    extendedAttributes: [CustomFields!]
    "The date and time when the connection event occured."
    occurredAt: String!
}

"Response containing the connection history. It is a list of Network Connection Events for a device."
type ConnectionHistoryResult {
    "Device connection events, sorted by the occurredAt timestamp, oldest first."
    connectionHistory: [ConnectionEvent!]
    "False for a status 200 response.True for a status 202 response, indicating that there is more data to be retrieved. Send another request, adjusting the earliest value in the request based on the occuredAt value for the last device in the current response."
    hasMoreData: Boolean!
}

"Request to update contact information."
type ContactInfoUpdateRequest {
    "The name of the billing account that the devices belong to. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "A list of the devices that you want to change, specified by device identifier. You only need to provide one identifier per device. Do not include accountName, groupName, customFields, or servicePlan if you use this parameter."
    devices: [AccountDeviceList!]
    "The customer name and the address of the device's primary place of use. These values are applied to all devices in the request.The Primary Place of Use location may affect taxation or have other legal implications. You may want to speak with legal and/or financial advisers before entering values for these fields."
    primaryPlaceOfUse: String!
}

"Create request for a new device group and optionally add devices to the group."
type CreateDeviceGroupRequest {
    "The Verizon billing account that the device group will belong to. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "Zero or more devices to add to the device group. You can use POST /devices/actions/list to get a list of all devices in the account."
    devicesToAdd: [DeviceId!]
    "A description for the device group."
    groupDescription: String!
    "The name for the new device group. This name must be unique within the specified account."
    groupName: String!
}

"The customer name to be used for line usage taxation."
type CustomerName {
    "An optional title for the customer, such as “Mr.” or “Dr.”"
    title: String!
    "The customer's first name."
    firstName: String!
    "The customer's middle name."
    middleName: String!
    "The customer's last name."
    lastName: String!
    "An optional suffix for the customer name, such as “Jr.” or “III.”"
    suffix: String!
}

"Request to assign or change custom field values for one or more devices."
type CustomFieldsUpdateRequest {
    "The name of a billing account.This parameter is only required if the UWS account used for the current API session has access to multiple billing accounts.An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFields!]
    "The names and new values of any custom fields that you want to change."
    customFieldsToUpdate: [CustomFields!]
    "The devices that you want to change."
    devices: [AccountDeviceList!]
    "The name of a device group, if you want to only include devices in that group."
    groupName: String!
    "The name of a service plan, if you want to only include devices that have that service plan."
    servicePlan: String!
}

"Filter out the dates."
type DateFilter {
    "Only include devices that were added after this date and time."
    earliest: String!
    "Only include devices that were added before this date and time."
    latest: String!
}

"Request to delete a device request."
type DeleteDevicesRequest {
    "The Verizon billing account that the device group belongs to. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "A list of up to 100 devices that you want to delete, specified by device identifier. You only need to provide one identifier per device."
    devicesToDelete: [AccountDeviceList!]
}

"An identifier for a single device."
type DeviceId {
    "The value of the device identifier."
    id: String!
    "The type of the device identifier. Valid types of identifiers are:ESN (decimal),EID,ICCID (up to 20 digits),IMEI (up to 16 digits),MDN,MEID (hexadecimal),MSISDN."
    kind: String!
}

"Response for a request made to delete a device."
type DeleteDevicesResult {
    "One object per device to be deleted. Each object must contain a kind and id element identifying the device."
    deviceIds: String!
    "“Success” if the device was deleted, or “Failed” if there was a problem."
    status: String!
    "Not present if status=Success. One of these messages if status=Failed:The device is not in deactivate state.The user does not have access to delete the device."
    message: String!
}

"Device that exist in Verizon Mobile Device Management (MDM)."
type ThingspaceDevice {
    "The billing account that the device is associated with."
    accountName: String!
    "The date that the device's current billing cycle ends."
    billingCycleEndDate: String!
    "The carrier information associated with the device."
    carrierInformations: [CarrierInformation!]
    "True if the device is connected; false if it is not."
    connected: Boolean!
    "The date and time that the device was added to the system."
    createdAt: String!
    "The custom fields and values that have been set for the device."
    customFields: [CustomFields!]
    "All identifiers for the device."
    deviceIds: [DeviceId!]
    "Any extended attributes for the device, as Key and Value pairs. The pairs listed below are returned as part of the response for a single device, but are not included if the request was for information about multiple devices."
    extendedAttributes: [CustomFields!]
    "The device groups that the device belongs to."
    groupNames: [String!]
    "The IP address of the device."
    ipAddress: String!
    "The user who last activated the device."
    lastActivationBy: String!
    "The date and time that the device was last activated."
    lastActivationDate: String!
    "The most recent connection date and time."
    lastConnectionDate: String!
}

"Request to list device aggregate usage."
type DeviceAggregateUsageListRequest {
    "One or more devices for which you want aggregate data, specified by device ID."
    deviceIds: [DeviceId!]
    "The name of a billing account."
    accountName: String!
    "The name of a device group, if you want to only include devices in that group."
    groupName: String!
    "The beginning of the reporting period. The startTime cannot be more than 6 months before the current date."
    startTime: String!
    "The end of the reporting period. The endTime date must be within on month of the startTime date."
    endTime: String!
    label: [Label!]
}

"Request to list of network connection events for a device during a specified time period."
type DeviceConnectionListRequest {
    "An identifier for a single device."
    deviceId: DeviceId!
    "The earliest date and time for which you want connection events."
    earliest: String!
    "The last date and time for which you want connection events."
    latest: String!
}

"Request to retrieve cost center value of a device."
type DeviceCostCenterRequest {
    "The name of a billing account."
    accountName: String!
    "The new cost center code. Valid values are any string of up to 36 alphanumeric characters, space, dash, exclamation point, and pound sign."
    costCenter: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFields!]
    "A list of the devices that you want to change, specified by device identifier. Do not include accountName, groupName, customFields, or servicePlan if you use this parameter."
    devices: [AccountDeviceList!]
    "The name of a device group, if you want to only include devices in that group."
    groupName: String!
    "The customer name and the address of the device's primary place of use. These values are applied to all devices in the request.The Primary Place of Use location may affect taxation or have other legal implications. You may want to speak with legal and/or financial advisers before entering values for these fields."
    primaryPlaceOfUse: String!
    "Set to true to remove the cost center code value. This flag takes precedence over a new costCenter value. If this flag is true and costCenter has a value, the cost center code is removed. Do not include this parameter, or set it to false to change the costCenter value."
    removeCostCenter: Boolean!
    "The name of a service plan, if you want to only include devices that have that service plan."
    servicePlan: String!
}

"Request for obtaining device extended diagnostics."
type DeviceExtendedDiagnosticsRequest {
    "The Verizon billing account that the device belongs to. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "The device for which you want diagnostic information, specified by the device's MDN."
    deviceList: [DeviceId!]
}

"Result for a request to obtain device extended diagnostics."
type DeviceExtendedDiagnosticsResult {
    "The response includes various types of information about the device, grouped into categories. Each category object contains the category name and a list of Extended Attribute objects as key-value pairs."
    categories: [DiagnosticsCategory!]
}

"Specify the kind of the device identifier, the type of match, and the string that you want to match."
type DeviceFilter {
    "The the billing account that the devices belong to."
    account: String!
    "Only include devices that are in this device group."
    groupName: String!
    "Only include devices that have this service plan."
    servicePlan: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFields!]
}

"Filter for devices without account."
type DeviceFilterWithoutAccount {
    "Only include devices that are in this device group."
    groupName: String!
    "Only include devices that have this service plan."
    servicePlan: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFields!]
}

"Search by device id."
type DeviceIdSearch {
    "The string appears anywhere in the identifer."
    contains: String!
    "The identifer must start with the specified string."
    startswith: String!
    "The identifier must end with the specified string."
    endswith: String!
    "The type of the device identifier. Valid types of identifiers are:ESN (decimal),EID,ICCID (up to 20 digits),IMEI (up to 16 digits),MDN,MEID (hexadecimal),MSISDN."
    kind: String!
}

"A list of deviceId objects to use when requesting information from multiple devices."
type AccountDeviceList {
    "All identifiers for the device."
    deviceIds: [DeviceId!]
    ipAddress: String!
}

"Filter for a list of devices."
type AccountDeviceListFilter {
    "Specify the kind of the device identifier, the type of match, and the string that you want to match."
    deviceIdentifierFilters: [DeviceIdSearch!]
}

"Request for listing account devices."
type AccountDeviceListRequest {
    "The billing account for which a list of devices is returned. If you don't specify an accountName, the list includes all devices to which you have access."
    accountName: String!
    "An identifier for a single device."
    deviceId: DeviceId!
    "Filter for a list of devices."
    filter: AccountDeviceListFilter!
    "The name of a device state, to only include devices in that state."
    currentState: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFields!]
    "Only include devices that were added after this date and time."
    earliest: String!
    "Only include devices that are in this device group."
    groupName: String!
    "Only include devices that were added before this date and time."
    latest: String!
    "Only include devices that have this service plan."
    servicePlan: String!
    maxNumberOfDevices: Int!
    largestDeviceIdSeen: Int!
}

"Response for a request to list down account devices."
type AccountDeviceListResult {
    "Up to 10,000 devices that you want to move to a different account, specified by device identifier."
    devices: [ThingspaceDevice!]
    "False for a status 200 response.True for a status 202 response, indicating that there is more data to be retrieved."
    hasMoreData: Boolean!
}

"Request for device status to check availability of activation."
type DeviceActivationRequest {
    "The name of a billing account."
    accountName: String!
    "Up to 10,000 devices that you want to move to a different account, specified by device identifier."
    devices: [AccountDeviceList!]
}

"Requests the current PRL (Preferred Roaming List) version for 2G or 3G devices, which can help determine which devices need a PRL update. (4G and GSM devices do not have a PRL.)."
type DevicePrlListRequest {
    "The devices for which you want the PRL version, specified by device identifier. You only need to provide one identifier per device. Do not use any of the other parameters if you specify device IDs."
    deviceIds: [DeviceId!]
    "The name of a billing account. This parameter is only required if you are passing groupName and the UWS account used for the current API session has access to multiple billing accounts, because the same device group name can exist in multiple accounts.An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "The names and values of custom fields, if you want to only include devices that have matching custom fields."
    customFields: [CustomFields!]
    "The name of a device group, if you want to only include devices in that group."
    groupName: String!
    "The name of a service plan, if you want to only include devices that have that service plan."
    servicePlan: String!
}

"Request to list of all 4G devices with an ICCID (SIM) that was not activated with the expected IMEI (hardware) during a specified time frame."
type DeviceMismatchListRequest {
    "A list of specific devices that you want to check, specified by ICCID or MDN."
    devices: [AccountDeviceList!]
    "Filter out the dates."
    filter: DateFilter!
    "The account that you want to search for mismatched devices. If you don't specify an accountName, the search includes all devices to which you have access."
    accountName: String!
    "The name of a device group, to only include devices in that group."
    groupName: String!
}

"Response to list of all 4G devices with an ICCID (SIM) that was not activated with the expected IMEI (hardware) during a specified time frame."
type DeviceMismatchListResult {
    "A list of specific devices that you want to check, specified by ICCID or MDN."
    devices: [MismatchedDevice!]
}

"Request to return the provisioning history of a specified device during a specified time period."
type DeviceProvisioningHistoryListRequest {
    "An identifier for a single device."
    deviceId: DeviceId!
    "The earliest date and time for which you want provisioning data."
    earliest: String!
    "The last date and time for which you want provisioning data."
    latest: String!
}

"Response to return the provisioning history of a specified device during a specified time period."
type DeviceProvisioningHistoryListResult {
    "False for a status 200 response.True for a status 202 response, indicating that there is more data to be retrieved."
    hasMoreData: Boolean!
    "The provisioning history of a specified device during a specified time period."
    provisioningHistory: [ProvisioningHistory!]
}

"Request to return service suspension information about one or more devices."
type DeviceSuspensionStatusRequest {
    "The devices that you want to include in the request, specified by device identifier. You only need to provide one identifier per device."
    deviceIds: [DeviceId!]
    "Filter for devices without account."
    filter: DeviceFilterWithoutAccount!
    "The name of a billing account."
    accountName: String!
}

"Request to return the daily network data usage of a single device during a specified time period."
type DeviceUsageListRequest {
    "An identifier for a single device."
    deviceId: DeviceId!
    "The earliest date for which you want usage data."
    earliest: String!
    "The last date for which you want usage data."
    latest: String!
    label: Label!
}

type Label {
    name: String!
    value: String!
}

"Response to return the daily network data usage of a single device during a specified time period."
type DeviceUsageListResult {
    "False for a status 200 response.True for a status 202 response, indicating that there is more data to be retrieved."
    hasMoreData: Boolean!
    "Placeholder."
    usageHistory: [Usage!]
}

"Various types of information about the device, grouped into categories. Each category object contains the category name and a list of Extended Attribute objects as key-value pairs."
type DiagnosticsCategory {
    "The name of the category."
    categoryName: String!
    "A list of Extended Attribute objects as key-value pairs."
    extendedAttributes: [CustomFields!]
}

"The engagements associated with the account."
type Engagement {
    "The engagement ID."
    engagementId: String!
    "The charging group name."
    chargingGroup: String!
    "The services associated with the account."
    services: [AccountService!]
}

"Returns a list and details of all custom services and states defined for a specified account."
type AccountStatesAndServices {
    "The engagements associated with the account."
    engagement: [Engagement!]
}

"Changes the provisioning state of one or more devices to a specified customer-defined service and state."
type GoToStateRequest {
    "Up to 10,000 devices that you want to push to a different state, specified by device identifier."
    devices: [AccountDeviceList!]
    "Specify the kind of the device identifier, the type of match, and the string that you want to match."
    filter: DeviceFilter!
    "The name of a customer-defined service to push the devices to."
    serviceName: String!
    "The name of a customer-defined stage state to push the devices to."
    stateName: String!
    "The service plan code that you want to assign to all specified devices in the new state."
    servicePlan: String!
    "The Zip code of the location where the line of service will primarily be used, or a Zip code that you have been told to use with these devices. For accounts that are configured for geographic numbering, this is the ZIP code from which the MDN will be derived."
    mdnZipCode: String!
    "The pool from which your device IP addresses will be derived if the service or state change requires new IP addresses.If you do not include this element, the default pool will be used."
    carrierIpPoolName: String!
    "For devices with static IP addresses on the public network, this specifies whether the devices have general access to the Internet. Valid values are “restricted” or “unrestricted”."
    publicIpRestriction: String!
    "The Stock Keeping Unit (SKU) number of a 4G device type with an embedded SIM. Can be used with ICCID or EID device identifiers in lieu of an IMEI when activating 4G devices. The SkuNumber will be used with all devices in the request, so all devices must be of the same type."
    skuNumber: String!
    "The names and values of any custom fields that you want to set for the devices."
    customFields: [CustomFields!]
    "The name of a device group that the devices should be added to."
    groupName: String!
    "The customer name and the address of the device's primary place of use. Leave these fields empty to use the account profile address as the primary place of use. These values will be applied to all devices in the request.If the account is enabled for non-geographic MDNs and the device supports it, the primaryPlaceOfUse address will also be used to derive the MDN for the device."
    primaryPlaceOfUse: PlaceOfUse!
}

"Returns the name, description, and list of devices in a device group."
type DeviceGroupDevicesData {
    "The description of the device group."
    description: String!
    "The devices in the device group."
    devices: [AccountDeviceList!]
    "False for a status 200 response.True for a status 202 response, indicating that there is more data to be retrieved."
    hasMoreData: Boolean!
    "The name of the device group."
    name: String!
}

"Returns a list of all device groups in a specified account."
type DeviceGroup {
    "The description of the device group."
    description: String!
    "Any extended attributes for the device group, as Key and Value pairs."
    extendedAttributes: [CustomFields!]
    "Identifies the default device group."
    isDefaultGroup: Boolean!
    "The name of the device group."
    name: String!
}

"Make changes to a device group, including changing the name and description, and adding or removing devices."
type DeviceGroupUpdateRequest {
    "Zero or more devices to add to the device group, specified by device ID. The devices will be removed from their current device groups. You can use POST /devices/actions/list to get a list of all devices in the account."
    devicesToAdd: [DeviceId!]
    "Zero or more devices to remove from the device group, specified by device ID. The devices will be added to the default device group."
    devicesToRemove: [DeviceId!]
    "A new description for the device group. Do not include this parameter to leave the group description unchanged."
    newGroupDescription: String!
    "A new name for the device group. Do not include this parameter if you want to leave the group name unchanged."
    newGroupName: String!
}

"IP pool that is available to the account."
type IPPool {
    "The name of the IP pool."
    poolName: String!
    "The type of IP pool, such as “Static IP” or “Dynamic IP.”"
    poolType: String!
    "True if this is the default IP pool for the account."
    isDefaultPool: Boolean!
}

"Custom data that can be included using key-value pairs."
type CustomFields {
    "The key for an extended attribute."
    key: String!
    "The value of an extended attribute."
    value: String!
}

"Returns information for all leads associated with an account."
type AccountLeadsResult {
    "False if no more leads.True if there is more data to be retrieved."
    hasMoreData: Boolean!
    "The leads associated with an account."
    leads: [AccountLead!]
}

"A successful response returns an array of lead objects."
type AccountLead {
    "The customer address for the line's primary place of use, for line usage taxation."
    address: Address!
    "Unique number for each lead. Use this value in the leadId parameter when activating devices to credit the activations to the lead."
    leadId: String!
    "The current state of the lead, such as “Qualified” or “Closed.”"
    leadState: String!
}

"Request to initiate a Connectivity Management session and returns a VZ-M2M session token that is required in subsequent API requests."
type LogInRequest {
    "The username for authentication."
    username: String!
    "The password for authentication."
    password: String!
}

"Response to initiate a Connectivity Management session and returns a VZ-M2M session token that is required in subsequent API requests."
type LogInResult {
    "The identifier for the session that was created by the request. Store the sessionToken for use in the header of all other API requests."
    sessionToken: String!
}

"Request to end a Connectivity Management session."
type LogOutRequest {
    "The session token is returned to confirm that it was invalidated."
    sessionToken: String!
}

"4G devices with an ICCID (SIM) that was not activated with the expected IMEI (hardware) during a specified time frame."
type MismatchedDevice {
    "The account that the device is associated with."
    accountName: String!
    "The assigned phone number of the device."
    mdn: String!
    "The date and time when the SIM was last activated."
    activationDate: String!
    "The ID of the SIM."
    iccid: String!
    "The IMEI of the device prior to the SIM OTA activation on simOtaDate."
    preImei: String!
    "The IMEI of the device after the SIM OTA activation on simOtaDate."
    postImei: String!
    "The date and time of the SIM OTA activation."
    simOtaDate: String!
}

"Request to move active devices from one billing account to another within a customer profile."
type MoveDeviceRequest {
    "The name of the billing account that you want to move the devices to."
    accountName: String!
    "Specify the kind of the device identifier, the type of match, and the string that you want to match."
    filter: DeviceFilter!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFields!]
    "Up to 10,000 devices that you want to move to a different account, specified by device identifier."
    devices: [AccountDeviceList!]
    "The name of a device group, to only include devices in that group."
    groupName: String!
    "The pool from which device IP addresses will be derived in the new account. If you do not include this element, the default pool will be used."
    carrierIpPoolName: String!
    "The service plan code that you want to assign to the devices in the new account. If you do not include this element, ThingSpace will attempt to use the current service plan, which will result in a error if the new account does not have that service plan."
    servicePlan: String!
}

"The customer name and the address of the device's primary place of use. Leave these fields empty to use the account profile address as the primary place of use. These values will be applied to all devices in the request.If the account is enabled for non-geographic MDNs and the device supports it, the primaryPlaceOfUse address will also be used to derive the MDN for the device."
type PlaceOfUse {
    "The customer address for the line's primary place of use, for line usage taxation."
    address: Address!
    "The customer name to be used for line usage taxation."
    customerName: CustomerName!
}

"The provisioning history of a specified device during a specified time period."
type ProvisioningHistory {
    "The date and time when the provisioning event occured."
    occurredAt: String!
    "The success or failure of the provisioning event."
    status: String!
    "The user who performed the provisioning event."
    eventBy: String!
    "The provisioning action:Activate,Suspend,Restore,Deactivate,Device Move."
    eventType: String!
    "The MDN assigned to the device after the provisioning event."
    mdn: String!
    "The MSISDN assigned to the device after the provisioning event."
    msisdn: String!
    "The service plan of the device after the provisioning event occurred."
    servicePlan: String!
    "Any extended attributes for the event, as Key and Value pairs."
    extendedAttributes: [CustomFields!]
}

"Request to register a callback."
type RegisterCallbackRequest {
    "The name of the callback service that you want to subscribe to."
    name: String!
    "The address on your server where you have enabled a listening service for callback messages."
    url: String!
    "The user name that the M2M Platform should return in the callback messages."
    username: String!
    "The password that the M2M Platform should return in the callback messages."
    password: String!
}

"Response to activate service for one or more devices so that they can send and receive data."
type DeviceManagementResult {
    "A unique string that associates the request with the results that are sent via a callback service."
    requestId: String!
}

"A successful request returns the request ID and the current status."
type AsynchronousRequestResult {
    "The unique ID of the asynchronous request."
    requestId: String!
    "The current status of the callback response."
    status: RequestStatus!
}

"Response to errors."
type ConnectivityManagementResult {
    "Code of the error."
    errorCode: String!
    "Details of the error."
    errorMessage: String!
}

"Response to successful request."
type ConnectivityManagementSuccessResult {
    "A value of “true” indicates that the device group was created successfully."
    success: Boolean!
}

"Service associated with the account."
type AccountService {
    "The name of the service plan."
    name: String!
    "The description of the service plan."
    description: String!
    "The state of the service plan."
    states: [State!]
}

"Details of the service plan."
type ServicePlan {
    "The code that is used by the carrier for the service plan."
    carrierServicePlanCode: String!
    "The code of the service plan, which may not be the same as the name."
    code: String!
    "Any extended attributes for the service plan, as Key and Value pairs."
    extendedAttributes: [CustomFields!]
    "The name of the service plan."
    name: String!
    "The size of the service plan in kilobytes."
    sizeKb: Int!
}

"Request to update service plan."
type ServicePlanUpdateRequest {
    "The name of a billing account."
    accountName: String!
    "The name of a service plan, if you want to only include devices that have that service plan."
    currentServicePlan: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFields!]
    "A list of the devices that you want to change, specified by device identifier."
    devices: [AccountDeviceList!]
    "The name of a device group, if you want to restore service for all devices in that group."
    groupName: String!
    "The service plan code that you want to assign to all specified devices."
    servicePlan: String!
    carrierIpPoolName: String!
    takeEffect: String!
}

"Request to a new, randomly generated password for the current username."
type SessionResetPasswordRequest {
    "The current password for the username."
    oldPassword: String!
}

"Response to a new, randomly generated password for the current username."
type SessionResetPasswordResult {
    "The new password for the username."
    newPassword: String!
}

"SMS messages sent by all M2M devices associated with a billing account."
type SMSMessage {
    "One or more IDs of the device that sent the message."
    deviceIds: [DeviceId!]
    "The contents of the SMS message."
    message: String!
    "The date and time that the message was received by the Verizon ThingSpace Platform."
    timestamp: String!
}

"Response to SMS messages sent by all M2M devices associated with a billing account."
type SMSMessagesQueryResult {
    "False for a status 200 response.True for a status 202 response, indicating that there is more data to be retrieved."
    hasMoreData: Boolean!
    "An array of up to 100 SMS messages that were sent by devices in the account."
    messages: [SMSMessage!]
}

"Request to send SMS."
type SMSSendRequest {
    "The name of a billing account."
    accountName: String!
    "The names and values of custom fields, if you want to only include devices that have matching custom fields."
    customFields: [CustomFields!]
    "The SMS message encoding, which can be 7-bit (default), 8-bit-ASCII, 8-bit-UTF-8, 8-bit-DATA."
    dataEncoding: String!
    "The devices that you want to send the message to, specified by device identifier."
    deviceIds: [DeviceId!]
    "The name of a device group, if you want to send the SMS message to all devices in the device group."
    groupName: String!
    "The name of a service plan, if you want to only include devices that have that service plan."
    servicePlan: String!
    "The contents of the SMS message. The SMS message is limited to 160 characters in 7-bit format, or 140 characters in 8-bit format."
    smsMessage: String!
}

"Each service includes custom states."
type State {
    "The name of the state."
    name: String!
    "The workflow sequence number of this state."
    workflowSequenceNumber: Float!
    "The service plans that can be used to charge for services for devices in this state."
    servicePlans: [String!]
}

"The daily network data usage of a single device during a specified time period."
type Usage {
    "The number of bytes that the device sent or received on the report date."
    bytesUsed: Int!
    "The number of mobile-originated and mobile-terminated SMS messages on the report date."
    extendedAttributes: [CustomFields!]
    "The list of service plans associated with the device/account."
    servicePlan: String!
    "The number of SMS messages that were sent or received on the report date."
    smsUsed: Int!
    "The source of the information for the reported usage."
    source: String!
    "The date of the recorded usage."
    timestamp: String!
}

type ActivateDeviceProfileRequest {
    devices: [DeviceList!]
    accountName: String!
    servicePlan: String!
    mdnZipCode: String!
}

type DeviceList {
    deviceIds: [DeviceId!]
}

type RequestResponse {
    requestId: String!
}

type RestErrorResponse {
    errorCode: String!
    errorMessage: String!
}

type ProfileRequest {
    devices: [DeviceList!]
    carrierName: String!
    accountName: String!
    servicePlan: String!
    mdnZipCode: String!
    primaryPlaceOfUse: [PrimaryPlaceOfUse!]
    smsrOid: String!
    "The name of the pool of IP addresses assigned to the profile."
    carrierIpPoolName: String!
}

type Addressquery {
    address: [Address!]
}

type Customernamequery {
    customerName: [CustomerName!]
}

type DeactivateDeviceProfileRequest {
    devices: [DeactivateDeviceList!]
    accountName: String!
    carrierName: String!
    reasonCode: String!
    etfWaiver: Boolean!
    checkFallbackProfile: Boolean!
}

type DeactivateDeviceList {
    ids: [Id!]
}

type PropertyDeviceId {
    id: String!
    "The type of the device identifier. Valid types of identifiers are:ESN (decimal),EID,ICCID (up to 20 digits),IMEI (up to 16 digits),MDN,MEID (hexadecimal),MSISDN."
    kind: String!
}

type SetFallbackAttributeRequest {
    devices: [DeviceList!]
    accountName: String!
    carrierName: String!
}

type NotificationReportRequest {
    accountName: String!
    requestType: String!
    devices: [DeviceList!]
    monitorExpirationTime: String!
}

type StopMonitorRequest {
    accountName: String!
    monitorIds: [String!]
}

type DeviceUploadRequest {
    accountName: String!
    devices: [DeviceList!]
    emailAddress: String!
    deviceSku: String!
    uploadType: String!
}

type BillingCycle {
    year: String!
    month: String!
}

"Information required to associate a usage segmentation label with a device to retrieve billing."
type BilledusageListRequest {
    accountName: String!
    labels: LabelsList!
    deviceIds: [DeviceList!]
    billingCycle: BillingCycle!
}

type LabelsList {
    deviceIds: [DeviceLabels!]
}

"A label for a single device."
type DeviceLabels {
    "The label you want to associate with the device."
    name: String!
    "The value of label"
    value: String!
}

type ProfileChangeStateRequest {
    devices: [DeviceList!]
    accountName: String!
    smsrOid: String!
}

"Maximum of 2,000 objects are allowed in the array."
type AccountLabels {
    devices: [DeviceList!]
    label: [DeviceLabels!]
}

type AssociateLabelRequest {
    "The name of a billing account. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "Maximum of 2,000 objects are allowed in the array."
    labels: AccountLabels!
}

"The request body identifies the devices to upload."
type UploadsActivatesDeviceRequest {
    "The name of a billing account. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "The email address that the report should be sent to when the upload is complete."
    emailAddress: String!
    "The stock keeping unit that identifies the type of devices in the upload and activation."
    deviceSku: String!
    "The format of the device identifiers in the upload and activation."
    uploadType: String!
    "The service plan code that you want to assign to all specified devices."
    servicePlan: String!
    "The pool from which your device IP addresses is derived."
    carrierIpPoolName: String!
    "The Zip code of the location where the line of service is primarily used, or a Zip code that you have been told to use with these devices."
    mdnZipCode: String!
    "The devices to upload, specified by device IDs in a format matching uploadType."
    devices: [DeviceList!]
}

"The request body identifies the devices to upload."
type CheckOrderStatusRequest {
    "The name of a billing account. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "The request id from the activation order."
    orderRequestId: String!
    "The devices to upload, specified by device IDs in a format matching uploadType."
    devices: [DeviceList!]
}

type Id {
    "The value of the device identifier."
    id: String!
    "The type of the device identifier. Valid types of identifiers are:ESN (decimal),EID,ICCID (up to 20 digits),IMEI (up to 16 digits),MDN,MEID (hexadecimal),MSISDN."
    kind: String!
}

type PrimaryPlaceOfUse {
    customerName: [CustomerName!]
    address: [Address!]
}

type DeviceLocationCallback {
    "The name of the callback service."
    name: CallbackServiceName!
    "The location of your callback listener."
    url: String!
}

type CallbackRegistrationResult {
    "The name of the account that registered the callback URL."
    account: String!
    "The name of the callback service."
    name: CallbackServiceName!
}

type ConsentDeleteRequest {
    "Account identifier."
    accountName: String!
    "Device ID list."
    deviceList: [String!]
}

type ConsentRequest {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "Exclude all devices or not."
    allDevice: Boolean!
    "The change to make: append or replace."
    type: String!
    "Device ID list."
    exclusion: [String!]
}

type DevicesConsentResult {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "Exclude all devices or not?"
    allDevice: Boolean!
    "Are there more devices to retrieve or not?"
    hasMoreData: Boolean!
    "Total number of excluded devices in the account."
    totalCount: Int!
    "Last update time."
    updateTime: String!
    "Device ID list."
    exclusion: [String!]
}

"The devices that you want to locate. The array cannot contain more than 20 devices."
type DeviceInfo {
    "Device identifier."
    id: String!
    "Device identifier kind."
    kind: String!
    "Device MDN."
    mdn: String!
}

type SynchronousLocationRequestResult {
    "The transaction ID of the report."
    txid: String!
    "Status of the report."
    status: ReportStatus!
}

"The body contains the the account name and list of devices that you want to locate, plus other options."
type LocationRequest {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "Accurary, currently only 0-coarse supported."
    accuracyMode: AccuracyMode!
    "Location cache mode."
    cacheMode: CacheMode!
    "Device list."
    deviceList: [DeviceInfo!]
}

"Device location information."
type Location {
    "MDN."
    msid: String!
    "Position data."
    pd: PositionData!
    "Position error."
    error: PositionError!
}

"Location information for up to 1,000 devices."
type LocationReport {
    "Device location information."
    devLocationList: [Location!]
    "True if there are more device locations to retrieve."
    hasMoreData: Boolean!
    "The zero-based number of the first record to return. Set startIndex=0 for the first request. If there are more than 1,000 devices to be returned (hasMoreData=true), set startIndex=1000 for the second request, 2000 for the third request, etc."
    startIndex: String!
    "The total number of devices in the original request and in the report."
    totalCount: Int!
    "The transaction ID of the report."
    txid: String!
}

type AsynchronousLocationRequestResult {
    "The transaction ID of the report."
    txid: String!
    "Status of the report."
    status: ReportStatus!
    "Estimated number of minutes required to complete the report."
    estimatedDuration: String!
}

"Status of the report."
type LocationReportStatus {
    "The transaction ID of the report."
    txid: String!
    "Status of the report."
    status: ReportStatus!
}

"Position data."
type PositionData {
    "Time location obtained."
    time: String!
    "UTC offset of time."
    utcoffset: String!
    "X coordinate of location."
    x: String!
    "Y coordinate of location."
    y: String!
    "Radius of the location in meters."
    radius: String!
    "Whether requested accurary is met or not."
    qos: Boolean!
}

"Position error."
type PositionError {
    "Time location obtained."
    time: String!
    "UTC offset of time."
    utcoffset: String!
    "Error type returned from location server."
    type: String!
    "Additional information about the error."
    info: String!
}

type DeviceLocationSubscription {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "Location service license type."
    locType: String!
    "The number of billable location requests allowed per billing cycle."
    maxAllowance: String!
    "Location service purchase time."
    purchaseTime: String!
}

"The transaction ID of the request that you want to cancel, from the POST /devicelocations synchronus response."
type TransactionID {
    txid: String!
}

"Bill usage request."
type BillUsageRequest {
    "Account identifier."
    accountName: String!
    "Start date to search for billable usage, mm-dd-yyyy."
    startDate: String!
    "End date to search for billable usage, mm-dd-yyyy."
    endDate: String!
    "Request usage for single or multiple accounts."
    usageForAllAccounts: Boolean!
}

"Bill usage report."
type BillableUsageReport {
    "Account identifier."
    accountName: String!
    "The usage is for a single or multiple accounts."
    usageForAllAccounts: Boolean!
    "SKU Name of the service subscription."
    skuName: String!
    "The number of location requests included with the subscription type."
    transactionsAllowed: String!
    "The total number of billable device location requests during the reporting period from all included accounts."
    totalTransactionCount: String!
    primaryAccount: ServiceUsage!
    "Zero or more managed accounts."
    managedAccounts: [ServiceUsage!]
}

type ServiceUsage {
    "Account identifier."
    accountName: String!
    "Total requests for the account during the reporting period."
    transactionsCount: String!
}

"Whether the device location request was successful or not."
type DeviceLocationSuccessResult {
    success: Boolean!
}

"Will be empty if there was no error."
type DeviceLocationResult {
    errorCode: String!
    errorMessage: String!
}

type UsageTriggerAddRequest {
    "Usage trigger name"
    triggerName: String!
    "Account name"
    accountName: String!
    "Service name"
    serviceName: ServiceName!
    "The percent of subscribed usage required to activate the trigger, such as 90 or 100."
    thresholdValue: String!
    "Allow additional requests after thresholdValue is reached. (currently not functional)"
    allowExcess: Boolean!
    "Send SMS (text) alerts when the thresholdValue is reached."
    sendSmsNotification: Boolean!
    "Comma-separated list of phone numbers to send SMS alerts to. Digits only; no dashes or parentheses, etc."
    smsPhoneNumbers: String!
    "Send email alerts when the thresholdValue is reached."
    sendEmailNotification: Boolean!
    "Comma-separated list of email addresses to send alerts to."
    emailAddresses: String!
}

type UsageTriggerResponse {
    "Unique usage triggerId"
    triggerId: String!
    "Usage trigger name"
    triggerName: String!
    "Account name"
    accountName: String!
    "Service name"
    serviceName: ServiceName!
    "Percent of subscription at which trigger will send an alert"
    thresholdValue: String!
    "allowExcess determines whether to restrict usage after exceeds limits"
    allowExcess: Boolean!
    "Send SMS (text) alerts when the thresholdValue is reached."
    sendSmsNotification: Boolean!
    "comma seperated value of list of Phone numbers for SMS notifications"
    smsPhoneNumbers: String!
    "Send email alerts when the thresholdValue is reached."
    sendEmailNotification: Boolean!
    "comma seperated value of list of Email addresses for Email notifications"
    emailAddresses: String!
    "UTC Date when the usage trigger was created"
    createDate: String!
    "UTC Date when the usage trigger was last updated"
    updateDate: String!
}

type UsageTriggerUpdateRequest {
    "Usage trigger name"
    triggerName: String!
    "Account name"
    accountName: String!
    "The percent of subscribed usage required to activate the trigger, such as 90 or 100."
    thresholdValue: String!
    "Comma-separated list of phone numbers to send SMS alerts to. Digits only; no dashes or parentheses, etc."
    smsPhoneNumbers: String!
    "Comma-separated list of email addresses to send alerts to."
    emailAddresses: String!
}

type ManagedAccountsAddRequest {
    "Account identifier"
    accountName: String!
    "Service name"
    serviceName: ServiceName!
    "SKU name"
    type: String!
    "managed account list"
    managedAccList: [String!]
}

type ManagedAccountsAddResponse {
    "Transaction identifier"
    txId: String!
    statusList: [StatusList!]
}

type ManagedAccountsProvisionRequest {
    "Managed account identifier"
    accountName: String!
    "Primary Account identifier"
    paccountName: String!
    "Service name"
    serviceName: ServiceName!
    "SKU name"
    type: String!
    "Transaction identifier returned by add request"
    txid: String!
}

type ManagedAccountsProvisionResponse {
    "Transaction identifier"
    txid: String!
    "Account identifier"
    accountName: String!
    "Primary Account identifier"
    paccountName: String!
    "Service name"
    serviceName: ServiceName!
    "Provision status. Success or Fail"
    status: String!
    "Detailed reason"
    reason: String!
}

type ManagedAccountCancelRequest {
    "Managed account identifier"
    accountName: String!
    "Primary Account identifier"
    paccountName: String!
    "Service name"
    serviceName: ServiceName!
    "SKU name"
    type: String!
    "Transaction identifier returned by provision request"
    txid: String!
}

type ManagedAccountCancelResponse {
    "Transaction identifier"
    txid: String!
    "Managed account identifier"
    accountName: String!
    "Primary account identifier"
    paccountName: String!
    "Service name"
    serviceName: ServiceName!
    "Deactivate/cancel status, Success or Fail"
    status: String!
    "Detailed reason"
    reason: String!
}

type ManagedAccountsGetAllResponse {
    "Account Name"
    accountName: String!
    managedAccAddedList: [ManagedAccAddedList!]
    managedAccProvisionedList: [ManagedAccProvisionedList!]
}

type ManagedAccAddedList {
    "Account name"
    id: String!
    "Transaction identifier"
    txid: String!
}

type ManagedAccProvisionedList {
    "Account name"
    id: String!
    "Transaction identifier"
    txid: String!
}

type StatusList {
    "Account name"
    id: String!
    "Success or Fail"
    status: String!
    "detailed reason"
    reason: String!
}

"List of registered callback endpoints."
type RegisteredCallbacks {
    "The name of the billing account for which callback messages will be sent."
    aname: String!
    "The name of the callback service, which identifies the type and format of messages that will be sent to the registered URL. This will be 'Fota' for the Software Management Services callback."
    name: String!
    "The address to which callback messages will be sent."
    url: String!
    "The user name that ThingSpace will return in the callback messages."
    username: String!
    "The password that ThingSpace will return in the callback messages."
    password: String!
}

"Callback endpoint information."
type FotaV1CallbackRegistrationRequest {
    "The name of the callback service that you want to subscribe to, which must be 'Fota' for Software Management Services callbacks."
    name: String!
    "The address on your server where you have enabled a listening service for Software Management Services callback messages."
    url: String!
    "The user name that ThingSpace should return in the callback messages."
    username: String!
    "The password that ThingSpace should return in the callback messages."
    password: String!
}

"Registered callback account name and service name."
type FotaV1CallbackRegistrationResult {
    "The name of the billing account for which callback messages will be sent."
    accountName: String!
    "The name of the callback service, which identifies the type and format of messages that will be sent to the registered URL. This will be 'Fota' for the Software Management Services callback."
    serviceName: String!
}

"List of devices to removes."
type V1ListOfLicensesToRemoveRequest {
    "Set to 'append' to append the devices in the current request to the existing list. If there is no existing list then it will be created with only these devices. Leave this parameter out when you want to replace the existing list with the devices in the current request."
    type: String!
    "The IMEIs of the devices."
    deviceList: [String!]
}

"List of licenses assigned."
type V1ListOfLicensesToRemoveResult {
    "The total number of devices on the cancellation candidate list."
    count: Int!
    "The IMEIs of the devices."
    deviceList: [String!]
}

"List of cancellation candidate devices."
type V1ListOfLicensesToRemove {
    "The total number of devices on the list."
    count: Int!
    "True if there are more devices to retrieve."
    hasMoreData: Boolean!
    "The date and time that the list was last updated."
    updateTime: String!
    "The IMEIs of the devices."
    deviceList: [String!]
}

"List of devices."
type DeviceListQueryResult {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "True if there are more devices to retrieve."
    hasMoreData: Boolean!
    "If hasMoreData=true, the startIndex to use for the next request. 0 if hasMoreData=false."
    lastSeenDeviceId: Int!
    "The list of devices in the account."
    deviceList: [DeviceListQueryItem!]
}

"The list of devices in the account."
type DeviceListQueryItem {
    "Device IMEI."
    deviceId: String!
    "The MDN (phone number) of the device."
    mdn: String!
    "The device model name."
    model: String!
    "The device make."
    make: String!
    "The name of the firmware image currently installed on the device."
    firmware: String!
    "True if the device firmware can be upgraded over the air using the Software Management Services API."
    fotaEligible: Boolean!
    "True if an MRC license has been assigned to this device."
    licenseAssigned: Boolean!
    "The date and time that the device firmware was last upgraded. If a device has never been upgraded, the upgradeTime will be 01/01/1900 0:0:0."
    upgradeTime: String!
}

"Firmware upgrade information."
type DeviceUpgradeHistory {
    "Device IMEI."
    deviceId: String!
    "The unique identifier for the upgrade."
    id: String!
    "The name (number) of the billing account that the device belongs to."
    accountName: String!
    "The firmware version that was on the device before the upgrade."
    firmwareFrom: String!
    "The name of the firmware version that was on the device after the upgrade."
    firmwareTo: String!
    "The date of the upgrade."
    startDate: String!
    "The date and time that the upgrade actually started for this device."
    upgradeStartTime: String!
    "The status of the upgrade for this device."
    status: String!
    "More information about the status."
    reason: String!
}

"Response in case of any errors."
type FotaV1Result {
    "Error response code."
    errorCode: String!
    "Description of the error."
    errorMessage: String!
}

"Firmware information."
type Firmware {
    "The name of the firmware image, provided by the device manufacturer."
    firmwareName: String!
    "Internal reference; can be ignored."
    participantName: String!
    "The release date of the firmware image."
    launchDate: String!
    "Additional information about the release."
    releaseNote: String!
    "The device model that the firmware applies to."
    model: String!
    "The device make that the firmware applies to."
    make: String!
    "The firmware version that must currently be on the device to upgrade."
    fromVersion: String!
    "The firmware version that will be on the device after an upgrade."
    toVersion: String!
}

"List of devices to add or remove."
type FirmwareUpgradeChangeRequest {
    "Possible values are `append` or `remove`"
    type: FirmwareTypeList!
    "The IMEIs of the devices."
    deviceList: [String!]
}

"Upgrade information."
type FirmwareUpgradeChangeResult {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "The unique identifier for this upgrade."
    id: String!
    "A JSON object for each device that was included in the request, showing the device IMEI, the status of the addition or removal, and additional information about the status."
    deviceList: [V1DeviceListItem!]
}

"A JSON object for each device that was included in the request, showing the device IMEI, the status of the addition or removal, and additional information about the status."
type V1DeviceListItem {
    "Device IMEI."
    deviceId: String!
    "Whether the device was successfully added or removed from the campaign."
    status: String!
    "Additional details about the status."
    reason: String!
}

"Details of the firmware upgrade request."
type FirmwareUpgradeRequest {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "The name of the firmware image that will be used for the upgrade, from a GET /firmware response."
    firmwareName: String!
    "The name of the firmware version that will be on the devices after a successful upgrade."
    firmwareTo: String!
    "The date that the upgrade should begin."
    startDate: String!
    "The IMEIs of the devices."
    deviceList: [String!]
}

"Array of upgrade objects with the specified status."
type FirmwareUpgrade {
    "The unique identifier for this upgrade."
    id: String!
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "The name of the firmware image that will be used for the upgrade."
    firmwareName: String!
    "The name of the firmware version that will be on the devices after a successful upgrade."
    firmwareTo: String!
    "The intended start date for the upgrade."
    startDate: String!
    "The current status of the upgrade."
    status: String!
    "A JSON object for each device that was included in the upgrade, showing the device IMEI, the status of the upgrade, and additional information about the status."
    deviceList: [FirmwareUpgradeDeviceListItem!]
}

"A JSON object for each device that was included in the upgrade, showing the device IMEI, the status of the upgrade, and additional information about the status."
type FirmwareUpgradeDeviceListItem {
    "Device IMEI."
    deviceId: String!
    "The status of the upgrade for this device."
    status: String!
    "Additional details about the status. Not included when status='Request Pending.'"
    resultReason: String!
}

"Account license information."
type AccountLicenseInfo {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "Number of monthly licenses in an MRC subscription."
    totalLicenses: Int!
    "Number of licenses currently assigned to devices."
    assignedLicenses: Int!
    "True if there are more devices to retrieve."
    hasMoreData: Boolean!
    "If hasMoreData=true, the startIndex to use for the next request. 0 if hasMoreData=false."
    lastSeenDeviceId: Int!
    "The list of devices that have licenses assigned, including the date and time of when each license was assigned."
    deviceList: [AccountLicenseDeviceListItem!]
}

"The list of devices that have licenses assigned, including the date and time of when each license was assigned."
type AccountLicenseDeviceListItem {
    "Device IMEI."
    deviceId: String!
    "Timestamp of when a license was assigned to the device."
    assignmentTime: String!
}

"IMEIs of the devices to assign licenses to."
type V1LicensesAssignedRemovedRequest {
    "The IMEIs of the devices."
    deviceList: [String!]
}

"License assignment or removal confirmation."
type V1LicensesAssignedRemovedResult {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "Total number of monthly licenses in an MRC subscription."
    licCount: Int!
    "Number of licenses assigned to devices after the request completed."
    licUsedCount: Int!
    "A JSON object for each device that was in the request."
    deviceList: [V1DeviceListItem!]
}

"A response to a successful request contains a single Boolean value."
type FotaV1SuccessResult {
    "True is returned in case of success."
    success: Boolean!
}

"Account subscription information."
type V1AccountSubscription {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "Subscription models used by the account."
    purchaseType: String!
    "Number of monthly licenses in an MRC subscription."
    licenseCount: Int!
    "Number of licenses currently assigned to devices."
    licenseUsedCount: Int!
    "The date and time of when the subscription was last updated."
    updateTime: String!
}

"Upgrade information."
type UpgradeListQueryResult {
    "True if there are more devices to retrieve."
    hasMoreFlag: Boolean!
    "If hasMoreData=true, the startIndex to use for the next request. 0 if hasMoreData=false."
    lastSeenUpgradeId: Int!
    "Array of upgrade objects with the specified status."
    reportList: [FirmwareUpgrade]
}

"FOTA Subscription."
type FotaV2Subscription {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "Subscription models used by the account."
    purchaseType: String!
    "Number of monthly licenses in an MRC subscription."
    licenseCount: Int!
    "Number of licenses currently assigned to devices."
    licenseUsedCount: Int!
    "The date and time of when the subscription was last updated."
    updateTime: String!
}

"Summary of license assignment."
type V2LicenseSummary {
    "Account identifier."
    accountName: String!
    "Total FOTA license count."
    totalLicense: Int!
    "Assigned FOTA license count."
    assignedLicenses: Int!
    "True if there are more devices to retrieve."
    hasMoreData: Boolean!
    "Last seen device identifier."
    lastSeenDeviceId: String!
    "Maximum page size."
    maxPageSize: Int!
    "Device IMEI list."
    deviceList: [V2LicenseDevice!]
}

"Device IMEI list."
type V2LicenseDevice {
    "Device IMEI."
    deviceId: String!
    "License assignment time."
    assignmentTime: String!
}

"License assignment or removal confirmation."
type V2LicensesAssignedRemovedResult {
    "Account name."
    accountName: String!
    "Total license count."
    licTotalCount: Int!
    "Assigned license count."
    licUsedCount: Int!
    "List of devices with id in IMEI."
    deviceList: [V2DeviceStatus!]
}

"IMEIs of the devices to assign or remove licenses."
type V2LicenseIMEI {
    "Account name."
    accountName: String!
    "Device IMEI list."
    deviceList: [String!]
}

"License cancellation candidate devices."
type V2ListOfLicensesToRemoveRequest {
    "List creation option."
    type: String!
    "The number of devices."
    count: Int!
    "Device IMEI list."
    deviceList: [String!]
}

"List of created license cancellation devices."
type V2ListOfLicensesToRemoveResult {
    "The number of devices."
    count: Int!
    "Device IMEI list."
    deviceList: [String!]
}

"A list of license cancellation candidate devices."
type V2ListOfLicensesToRemove {
    "Cancellation candidate devices count."
    count: Int!
    "Flag to indicat more devices."
    hasMoreData: Boolean!
    "Last update time."
    updateTime: String!
    "Device IMEI list."
    deviceList: [String!]
}

"Software upgrade information."
type CampaignSoftwareUpgrade {
    "Campaign name."
    campaignName: String!
    "Software name to upgrade to."
    softwareName: String!
    "Old software name."
    softwareFrom: String!
    "New software name."
    softwareTo: String!
    "OMA or HTTP."
    distributionType: String!
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "Specifies starting date client should download package. If null, client will download as soon as possible."
    downloadAfterDate: String!
    "List of allowed download time windows."
    downloadTimeWindowList: [V2TimeWindow!]
    "Client will install package after date. If null, client will install as soon as possible."
    installAfterDate: String!
    "List of allowed install time windows."
    installTimeWindowList: [V2TimeWindow!]
    "Device IMEI list."
    deviceList: [String!]
}

"Software upgrade information."
type CampaignSoftware {
    "Upgrade identifier."
    id: String!
    "Account identifier."
    accountName: String!
    "Campaign name."
    campaignName: String!
    "Software name."
    softwareName: String!
    "LWM2M, OMD-DM or HTTP."
    distributionType: String!
    "Applicable make."
    make: String!
    "Applicable model."
    model: String!
    "Old software name."
    softwareFrom: String!
    "New software name."
    softwareTo: String!
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "Specifies starting date client should download package. If null, client will download as soon as possible."
    downloadAfterDate: String!
    "List of allowed download time windows."
    downloadTimeWindowList: [V2TimeWindow!]
    "Client will install package after date. If null, client will install as soon as possible."
    installAfterDate: String!
    "List of allowed install time windows."
    installTimeWindowList: [V2TimeWindow!]
    "Software upgrade status."
    status: String!
}

"New dates and time windows."
type V2ChangeCampaignDatesRequest {
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "Specifies starting date client should download package. If null, client will download as soon as possible."
    downloadAfterDate: String!
    "List of allowed download time windows. Removing of existing windows is not allowed."
    downloadTimeWindowList: [V2TimeWindow!]
    "Client will install package after date. If null, client will install as soon as possible."
    installAfterDate: String!
    "List of allowed install time windows. Removing of existing windows is not allowed."
    installTimeWindowList: [V2TimeWindow!]
}

"Add or remove device to existing software upgrade information."
type V2AddOrRemoveDeviceRequest {
    "Operation either 'append' or 'remove'."
    type: String!
    "Device IMEI list."
    deviceList: [String!]
}

"Add or remove devices from the existing software upgrade information."
type V2AddOrRemoveDeviceResult {
    "Account identifier."
    accountName: String!
    "Campaign identifier."
    campaignId: String!
    "Request identifier."
    requestId: String!
}

"Callback URL registration."
type FotaV2CallbackRegistrationRequest {
    "Callback URL for an subscribed service."
    url: String!
}

"Callback listener URL."
type FotaV2CallbackRegistrationResult {
    "Callback URL."
    url: String!
}

"Registered callback information."
type CallbackSummary {
    "Callback URL for an subscribed service."
    url: String!
}

"Software package information."
type SoftwarePackage {
    "Software name."
    softwareName: String!
    "Software launch date."
    launchDate: String!
    "Software release note reserved for future use."
    releaseNote: String!
    "Software applicable device model."
    model: String!
    "Software applicable device make."
    make: String!
    "LWM2M, OMD-DM or HTTP."
    distributionType: String!
    "The platform (Android, iOS, etc.) that the software can be applied to."
    devicePlatformId: String!
}

"Array of software upgrade objects with the specified status."
type DeviceSoftwareUpgrade {
    "Device identifier."
    deviceId: String!
    "Upgrade identifier."
    id: String!
    "Account identifier."
    accountName: String!
    "Software name."
    softwareName: String!
    "Software upgrade start date."
    startDate: String!
    "Software upgrade status."
    status: String!
    "Software upgrade result reason."
    reason: String!
}

"Campaign history details."
type V2CampaignHistory {
    "Has more report flag."
    hasMoreData: Boolean!
    "Campaign identifier."
    lastSeenCampaignId: String!
    "Software upgrade list."
    campaignList: [V2CampaignMetaInfo]
}

"Campaign and campaign details."
type V2CampaignMetaInfo {
    "Account identifier."
    accountName: String!
    "Campaign identifier."
    id: String!
    "Campaign name."
    campaignName: String!
    "Software name."
    softwareName: String!
    "LWM2M, OMD-DM or HTTP."
    distributionType: String!
    "Old software name."
    softwareFrom: String!
    "New software name."
    softwareTo: String!
    "Applicable make."
    make: String!
    "Applicable model."
    model: String!
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "Specifies starting date client should download package. If null, client will download as soon as possible."
    downloadAfterDate: String!
    "List of allowed download time windows."
    downloadTimeWindowList: [V2TimeWindow!]
    "Client will install package after date. If null, client will install as soon as possible."
    installAfterDate: String!
    "List of allowed install time windows."
    installTimeWindowList: [V2TimeWindow!]
    "Software upgrade status."
    status: String!
}

"List of devices in a campaign."
type V2CampaignDevice {
    "Total device count."
    totalDevice: Int!
    "Has more report flag."
    hasMoreData: Boolean!
    "Device identifier."
    lastSeenDeviceId: String!
    "Maximum page size."
    maxPageSize: Int!
    "List of devices with id in IMEI."
    deviceList: [V2DeviceStatus!]
}

"List of device information for an account."
type V2AccountDeviceList {
    "Account name."
    accountName: String!
    "Has more device flag?"
    hasMoreData: Boolean!
    "Last seen device identifier."
    lastSeenDeviceId: String!
    "Maximum page size."
    maxPageSize: Int!
    "Account device list."
    deviceList: [V2AccountDevice!]
}

"Account device information."
type V2AccountDevice {
    "Device identifier."
    deviceId: String!
    "MDN."
    mdn: String!
    "Device model."
    model: String!
    "Device make."
    make: String!
    "Device FOTA capable."
    fotaEligible: Boolean!
    "Device application FOTA capable."
    appFotaEligible: Boolean!
    "License assigned device."
    licenseAssigned: Boolean!
    "LWM2M, OMD-DM or HTTP."
    distributionType: String!
    "List of sofware."
    softwareList: [V2SoftwareInfo!]
    "The date and time of when the device is created."
    createTime: String!
    "The date and time of when the device firmware or software is upgraded."
    upgradeTime: String!
    "The date and time of when the device is updated."
    updateTime: String!
    "The date and time of when the device is refreshed."
    refreshTime: String!
}

"Software information."
type V2SoftwareInfo {
    "Software name."
    name: String!
    "Software version."
    version: String!
    "Upgrade time."
    upgradeTime: String!
}

"Allowed start and end time windows."
type V2TimeWindow {
    "Start hour in range [0..23], current hour >= startTime."
    startTime: Int!
    "End hour in range [1..24], current hour < endTime."
    endTime: Int!
}

"Device logging information."
type DeviceLog {
    "Device IMEI."
    deviceId: String!
    "Time of log."
    logTime: String!
    "Log type (one of SoftwareUpdate, Event, UserNotification, AgentService, Wireless, WirelessWeb, MobileBroadbandModem, WindowsMDM)."
    logType: String!
    "Event log."
    eventLog: String!
    "Base64-encoded contents of binary log file."
    binaryLogFileBase64: String!
    "File name of binary log file."
    binaryLogFilename: String!
}

"Device with id in IMEI."
type V2DeviceStatus {
    "Device IMEI."
    deviceId: String!
    "Success or failure."
    status: String!
    "Result reason."
    resultReason: String!
}

"Device logging information."
type DeviceLoggingRequest {
    "List of device IMEI identifiers."
    deviceIds: [String!]
}

"Device logging status information."
type DeviceLoggingStatus {
    "Device IMEI."
    deviceId: String!
    "The date when device logging expires."
    expiryDate: String!
}

"Check-in history for a device."
type CheckInHistoryItem {
    "Device IMEI."
    deviceId: String!
    "Type of client."
    clientType: String!
    result: String!
    failureType: String!
    timeCompleted: String!
}

"Response to a successful request."
type FotaV2SuccessResult {
    success: Boolean!
}

"Response for error cases."
type FotaV2Result {
    "Code of the error."
    errorCode: String!
    "Details of the error."
    errorMessage: String!
}

type UploadConfigurationFilesResponse {
    "The name of the file you are upgrading to."
    fileName: String!
    "The version of the file you are upgrading to."
    fileVersion: String!
    "Software launch date."
    launchDate: String!
    "Software release note."
    releaseNote: String!
    "Software applicable device model."
    model: String!
    "Software applicable device make."
    make: String!
    "LWM2M, OMD-DM or HTTP."
    distributionType: String!
    "The platform (Android, iOS, etc.) that the software can be applied to."
    devicePlatformId: String!
    "Local target path on the device."
    localTargetPath: String!
}

type RetrievesAvailableFilesResponseList {
    availableFilesResponse: [RetrievesAvailableFilesResponse!]
}

type RetrievesAvailableFilesResponse {
    "ThingSpace-generated name of the file. You will use this name when listing or scheduling campaigns for the file."
    fileName: String!
    "Version of the file."
    fileVersion: String!
    "Software release note."
    releaseNote: String!
    "The software-applicable device make."
    make: String!
    "The software-applicable device model."
    model: String!
    "Local target path on the device."
    localTargetPath: String!
    "Valid values"
    distributionType: String!
    "The platform (Android, iOS, etc.,) that the software can be applied to."
    devicePlatformId: String!
}

type UploadAndScheduleFileRequest {
    "The campaign name."
    campaignName: String!
    "The name of the file you are upgrading to."
    fileName: String!
    "The version of the file you are upgrading to."
    fileVersion: String!
    "Valid values"
    distributionType: String!
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "Specifies the starting date the client should download the package. If null, client downloads as soon as possible."
    downloadAfterDate: String!
    "List of allowed download time windows."
    downloadTimeWindowList: [DownloadTimeWindow!]
    "The date after which you install the package. If null, install as soon as possible."
    installAfterDate: String!
    "List of allowed install time windows."
    installTimeWindowList: [DownloadTimeWindow!]
    "Device IMEI list."
    deviceList: [String!]
}

type DownloadTimeWindow {
    "Device IMEI list."
    startTime: String!
    "Device IMEI list."
    endTime: String!
}

type UploadAndScheduleFileResponse {
    "Updgrade identifier."
    id: String!
    "Account identifer."
    accountName: String!
    "The campaign name."
    campaignName: String!
    "Software name."
    softwareName: String!
    "Old software name."
    softwareFrom: String!
    "New software name."
    softwareTo: String!
    "The name of the file you are upgrading to."
    fileName: String!
    "The version of the file you are upgrading to."
    fileVersion: String!
    "Valid values"
    distributionType: String!
    "Applicable make."
    make: String!
    "Applicable model."
    model: String!
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "Specifies the starting date the client should download the package. If null, client downloads as soon as possible."
    downloadAfterDate: String!
    "List of allowed download time windows."
    downloadTimeWindowList: [DownloadTimeWindow!]
    "The date after which you install the package. If null, install as soon as possible."
    installAfterDate: String!
    "List of allowed install time windows."
    installTimeWindowList: [DownloadTimeWindow!]
    "Device IMEI list."
    deviceList: [String!]
    "Software update status."
    status: String!
}

type SchedulesSoftwareUpgradeRequest {
    "The campaign name."
    campaignName: String!
    "Software name."
    softwareName: String!
    "Old software name."
    softwareFrom: String!
    "New software name."
    softwareTo: String!
    "Valid values"
    distributionType: String!
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "Specifies the starting date the client should download the package. If null, client downloads as soon as possible."
    downloadAfterDate: String!
    "List of allowed download time windows."
    downloadTimeWindowList: [DownloadTimeWindow!]
    "The date after which you install the package. If null, install as soon as possible."
    installAfterDate: String!
    "List of allowed install time windows."
    installTimeWindowList: [DownloadTimeWindow!]
    "Device IMEI list."
    deviceList: [String!]
}

"Device changed."
type V3DeviceListItem {
    "Device IMEI."
    deviceId: String!
    "Success or failure."
    status: String!
    "Result reason."
    reason: String!
}

"Devices to add or remove from existing software upgrade information."
type V3AddOrRemoveDeviceRequest {
    "Operation either 'append' or 'remove'"
    type: String!
    "Device IMEI list."
    deviceList: [String!]
}

"Add or remove devices to existing upgrade information."
type V3AddOrRemoveDeviceResult {
    "Account identifier."
    accountName: String!
    "Campaign identifier."
    campaignId: String!
    "Array of devices changed."
    deviceList: [V3DeviceListItem!]
}

"Campaign dates and time windows."
type V3ChangeCampaignDatesRequest {
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "List of allowed campaign time windows."
    campaignTimeWindowList: [V3TimeWindow!]
}

"Time window."
type V3TimeWindow {
    "Start hour in range [0..23], current hour >= startTime."
    startTime: Int!
    "End hour in range [1..24], current hour < endTime."
    endTime: Int!
}

"Information for licenses applied to devices."
type FotaV3Subscription {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "Subscription models used by the account."
    purchaseType: String!
    "Number of monthly licenses in an MRC subscription."
    licenseCount: Int!
    "Number of licenses currently assigned to devices."
    licenseUsedCount: Int!
    "The date and time of when the subscription was last updated."
    updateTime: String!
}

"Information for FOTA licenses assigned to devices."
type V3LicenseSummary {
    "Account identifier."
    accountName: String!
    "Total FOTA license count."
    totalLicenses: Int!
    "Assigned FOTA license count."
    assignedLicenses: Int!
    "True if there are more devices to retrieve."
    hasMoreData: Boolean!
    "Last seen device identifier."
    lastSeenDeviceId: String!
    "Maximum page size."
    maxPageSize: Int!
    "Device IMEI list."
    deviceList: [V3LicenseDevice!]
}

"Device IMEI."
type V3LicenseDevice {
    "Device IMEI."
    deviceId: String!
    "License assignment time."
    assignmentTime: String!
}

"License assignment/removal response."
type V3LicenseAssignedRemovedResult {
    "Account name."
    accountName: String!
    "Total license count."
    licCount: Int!
    "Assigned license count."
    licUsedCount: Int!
    "List of devices with id in IMEI."
    deviceList: [V3DeviceStatus!]
}

"List of devices."
type V3LicenseIMEI {
    "Device IMEI list."
    deviceList: [String!]
}

"Firmware upgrade for devices."
type CampaignFirmwareUpgrade {
    "Campaign name."
    campaignName: String!
    "Firmware name to upgrade to."
    firmwareName: String!
    "Old firmware version."
    firmwareFrom: String!
    "New firmware version."
    firmwareTo: String!
    "Valid values include: LWM2M, OMA and HTTP."
    protocol: String!
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "List of allowed campaign time windows."
    campaignTimeWindowList: [V3TimeWindow!]
    "Device IMEI list."
    deviceList: [String!]
}

"Firmware upgrade information."
type FirmwareCampaign {
    "Upgrade identifier."
    id: String!
    "Account identifier."
    accountName: String!
    "Campaign name."
    campaignName: String!
    "Firmware name (for firmware upgrade only)."
    firmwareName: String!
    "Old firmware version (for firmware upgrade only)."
    firmwareFrom: String!
    "New firmware version (for firmware upgrade only)."
    firmwareTo: String!
    "Available values: LWM2M."
    protocol: String!
    make: String!
    model: String!
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "List of allowed campaign time windows."
    campaignTimeWindowList: [V3TimeWindow!]
    "Campaign status."
    status: String!
}

"Firmware upgrades information."
type DeviceFirmwareUpgrade {
    "Device identifier."
    deviceId: String!
    "Campaign identifier."
    campaignId: String!
    "Account identifier."
    accountName: String!
    "Firmware name."
    firmwareName: String!
    "Old firmware version."
    firmwareFrom: String!
    "New firmware version."
    firmwareTo: String!
    "Firmware upgrade start date."
    startDate: String!
    "Firmware upgrade status."
    status: String!
    "Software upgrade result reason."
    reason: String!
    "Report updated time."
    reportUpdatedTime: String!
}

"Device IMEI list."
type DeviceIMEI {
    "Device IMEI list."
    deviceList: [String!]
}

"A list of IMEIs for devices to be synchronized between ThingSpace and the FOTA server."
type FirmwareIMEI {
    "Device IMEI list."
    deviceList: [String!]
}

"Device Firmware Information."
type DeviceFirmwareList {
    "Account name."
    accountName: String!
    "List of device & firmware."
    deviceFirmwarVersionList: [DeviceFirmwareVersion!]
}

"Device and firmware information."
type DeviceFirmwareVersion {
    status: String!
    reason: String!
    "Device IMEI."
    deviceId: String!
    "Device Firmware Version."
    firmwareVersion: String!
    firmwareVersionUpdateTime: String!
}

"Campaign history."
type V3CampaignHistory {
    "Has more report flag?"
    hasMoreData: Boolean!
    "Campaign identifier."
    lastSeenCampaignId: String!
    "Firmware upgrade list."
    campaignList: [V3CampaignMetaInfo]
}

"Campaign and campaign details."
type V3CampaignMetaInfo {
    "Account identifier."
    accountName: String!
    "Campaign identifier."
    id: String!
    "Campaign name."
    campaignName: String!
    "Firmware name."
    firmwareName: String!
    "Old firmware version."
    firmwareFrom: String!
    "New software version."
    firmwareTo: String!
    "Firmware protocol. Valid values include: LWM2M, OMD-DM."
    protocol: CampaignMetaInfoProtocol!
    "Device make."
    make: String!
    "Device model."
    model: String!
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "List of allowed campaign time windows."
    campaignTimeWindowList: [V3TimeWindow!]
    "Firmware upgrade status."
    status: String!
}

"Device list information."
type DeviceListResult {
    "Account name."
    accountName: String!
    "Total device count."
    deviceCount: Int!
    "List of devices with id in IMEI."
    deviceList: [V3Device!]
}

"Device information."
type V3Device {
    "Device IMEI."
    deviceId: String!
    "Success or failure."
    requestStatus: String!
    resultReason: String!
    "MDN."
    mdn: String!
    "Device model."
    model: String!
    "Device make."
    make: String!
    "Device firmware version."
    firmware: String!
    "Value=true if the device software can be upgraded over the air using the Software Management Services API."
    fotaEligible: Boolean!
    "Device status."
    status: String!
    "License assigned device."
    licenseAssigned: Boolean!
    "Firmware protocol. Valid values include: LWM2M, OMADM, HTTP or NONE."
    protocol: String!
    "List of sofware."
    softwareList: [V3SoftwareInfo!]
    "List of files."
    fileList: [V3SoftwareInfo!]
    "The date and time of when the device is created."
    createTime: String!
    "The date and time of when the device firmware or software is updated."
    statusTime: String!
    "The date and time of when the device is updated."
    updateTime: String!
    "The date and time of when the device is refreshed."
    refreshTime: String!
    "The date and time of when the device reachability is checked."
    lastConnectionTime: String!
}

"Device firmware version update response."
type DeviceFirmwareVersionUpdateResult {
    "Account identifier."
    accountName: String!
    "Request identifier."
    requestId: String!
}

"Firmware upgrade information."
type Campaign {
    "Upgrade identifier."
    id: String!
    "Account identifier."
    accountName: String!
    "Campaign name."
    campaignName: String!
    "Name of firmware."
    firmwareName: String!
    "Old firmware version."
    firmwareFrom: String!
    "New firmware version."
    firmwareTo: String!
    "The protocol of the firmware distribution. Default: LWM2M."
    protocol: String!
    "Applicable make."
    make: String!
    "Applicable model."
    model: String!
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "List of allowed campaign time windows."
    campaignTimeWindowList: [V3TimeWindow!]
    "Firmware upgrade status."
    status: String!
}

"Callback URL where the listening service is running."
type FotaV3CallbackRegistrationRequest {
    "Callback URL for an subscribed service."
    url: String!
}

"Callback registration information."
type FotaV3CallbackRegistrationResult {
    "Callback URL."
    url: String!
}

"Callback registration information."
type FotaV3CallbackSummary {
    "Callback URL for an subscribed service."
    url: String!
}

"Available firmware."
type FirmwarePackage {
    "Firmware name."
    firmwareName: String!
    "Firmware from version."
    firmwareFrom: String!
    "Firmware to version."
    firmwareTo: String!
    "Firmware launch date."
    launchDate: String!
    "Firmware release note."
    releaseNote: String!
    "Firmware applicable device model."
    model: String!
    "Firmware applicable device make."
    make: String!
    "Firmware protocol. Valid values include: LWM2M, OMD-DM."
    protocol: CampaignMetaInfoProtocol!
}

"Campaign history."
type V3CampaignDevice {
    "Total device count."
    totalDevice: Int!
    "Has more report flag."
    hasMoreData: Boolean!
    "Device identifier."
    lastSeenDeviceId: String!
    "Maximum page size."
    maxPageSize: Int!
    "List of devices with id in IMEI."
    deviceList: [V3DeviceStatus!]
}

"Array of devices."
type V3AccountDeviceList {
    "Account name."
    accountName: String!
    "Has more device flag?"
    hasMoreData: Boolean!
    "Last seen device identifier."
    lastSeenDeviceId: String!
    "Maximum page size."
    maxPageSize: Int!
    "Account device list."
    deviceList: [V3AccountDevice!]
}

"Device information."
type V3AccountDevice {
    "Device identifier."
    deviceId: String!
    "MDN."
    mdn: String!
    "Device model."
    model: String!
    "Device make."
    make: String!
    "Device firmware version."
    firmware: String!
    "Value=true if the device software can be upgraded over the air using the Software Management Services API."
    fotaEligible: Boolean!
    "Device status."
    status: String!
    "License assigned device."
    licenseAssigned: Boolean!
    "Firmware protocol. Valid values include: LWM2M, OMADM, HTTP or NONE."
    protocol: String!
    "List of sofware."
    softwareList: [V3SoftwareInfo!]
    "List of files."
    fileList: [V3SoftwareInfo!]
    "The date and time of when the device is created."
    createTime: String!
    "The date and time of when the device firmware or software is updated."
    upgradeTime: String!
    "The date and time of when the device is updated."
    updateTime: String!
    "The date and time of when the device is refreshed."
    refreshTime: String!
}

"Software information."
type V3SoftwareInfo {
    "Software name."
    name: String!
    "Software version."
    version: String!
    "Upgrade time."
    upgradeTime: String!
}

"Device status."
type V3DeviceStatus {
    "Device IMEI."
    deviceId: String!
    "Success or failure."
    status: String!
    "Result reason."
    resultReason: String!
    "Updated Time."
    updatedTime: String!
    "The most recent attempt time."
    recentAttemptTime: String!
    "Next attempt time."
    nextAttemptTime: String!
}

"Cancelation status."
type FotaV3SuccessResult {
    "True or false."
    success: Boolean!
}

"Error response."
type FotaV3Result {
    "Error code string."
    errorCode: String!
    "Error message string."
    errorMessage: String!
}

"Request to assign license."
type AssignLicenseRequest {
    "The name of a billing account.This parameter is required only if the UWS account used for the current API session has access to multiple accounts. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "A list of 4G devices."
    devices: [LicenseDeviceList!]
    "The Stock Keeping Unit (SKU). Valid skuNumbers for license types: “SIMSec-IoT-Lt”. (Lifetime) Once a license is assigned to a SIM, the SIM-Secure feature is enabled for the life of the SIM.“TS-BUNDLE-KTO-SIMSEC-MRC”. (Bundle) The SIM-Secure Flex license can be assigned to or removed from a SIM at any time. This SKU is bundled with other ThingSpace Services.“SIMSec-IoT”. (Flex) The SIM-Secure Flex license can be assigned to or removed from a SIM at any time. This SKU is purchased a la carte."
    skuNumber: String!
}

"Subscription of the device."
type SecuritySubscription {
    "Attributes of the subscription."
    extendedAttributes: [ExtendedAttributes!]
    "The total number of licenses for this license type that are assigned to device SIMs."
    licenseAssigned: Int!
    "The total number of licenses for this license type that are available to assign to device SIMs."
    licenseAvailable: Int!
    "The total number of licenses purchased for the license type."
    licensePurchased: Int!
    "The license type associated with the skuNumber."
    licenseType: String!
    "The skuNumber that identifies the license type."
    skuNumber: String!
}

"Additional properties associated with data."
type ExtendedAttributes {
    key: String!
    value: String!
}

"Request for a subscription."
type SecuritySubscriptionRequest {
    "The name of a billing account."
    accountName: String!
    "The Stock Keeping Unit (SKU). Valid skuNumbers for SIM-Secure for IoT are:SIMSec-IoT-Lt”. (Lifetime) Once a license is assigned to a SIM, the SIM-Secure feature is enabled for the life of the SIM.“TS-BUNDLE-KTO-SIMSEC-MRC”. (Bundle) The SIM-Secure Flex license can be assigned to or removed from a SIM at any time. This SKU is bundled with other ThingSpace Services.*“SIMSec-IoT”. (Flex) The SIM-Secure Flex license can be assigned to or removed from a SIM at any time. This SKU is purchased a la carte."
    skuNumber: String!
}

"Response for a subscription request."
type SecuritySubscriptionResult {
    "The name of a billing account."
    accountName: String!
    "The list of SKU numbers and counts for each license type specified in the request."
    subscriptionList: [SecuritySubscription!]
}

"List of all devices."
type LicenseDeviceList {
    "For 4G devices, IMEI (decimal, up to 15 digits)."
    deviceIds: [LicenseDeviceId!]
    ipAddress: String!
}

"Id of the devices."
type LicenseDeviceId {
    "For 4G devices, IMEI (decimal, up to 15 digits) for unassign and ICCID (decimal, up to 20 digits) for assign."
    id: String!
    "For 4G devices, ICCID (decimal, up to 20 digits) for unassign and IMEI (decimal, up to 15 digits) for assign."
    kind: String!
}

"Success response."
type SecuritySuccessResult {
    "A unique string that associates the request with the results that are sent via a callback message.The ThingSpace Platform sends a separate callback message for each device that matches the request criteria, indicating whether the operation succeeded for that device and containing any requested information. All callback messages will have the same requestId."
    requestId: String!
}

"Error response."
type SecurityResult {
    errorCode: String!
    errorMessage: String!
    errorUrl: String!
}

"MEC performance metrics request."
type QueryMECPerformanceMetricsRequest {
    "The 15-digit International Mobile Equipment Identifier."
    iMEI: String!
    "The 12-digit Mobile Station International Subscriber Directory Number."
    mSISDN: String!
}

"Response to query the most recent data for Key Performance Indicators (KPIs) like network availability, MEC hostnames and more."
type MECPerformanceMetrics {
    "Success or Failed."
    queryStatus: String!
    "Timestamp of the query's start, format:mm/dd/yyyy,hr:min:sec."
    start: String!
    "Timestamp of the query's end , format:mm/dd/yyyy, hr:min:sec."
    end: String!
    "MEC performance query result."
    queryResult: [MECPerformanceQueryResult!]
}

"Result of the query for obtaining MEC performance metrics."
type MECPerformanceQueryResult {
    "Name of the parameter."
    name: String!
    "Parameter values."
    data: [String!]
}

"Types of errors in response."
type EdgePerformanceResult {
    "HTTP status code."
    status: String!
    "Error details."
    message: String!
}

"Status of the diagnostic services subscription."
type DiagnosticsSubscription {
    "Account identifier in \"##########-#####\". An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "The date and time of when the subscription was created."
    createdOn: String!
    "The date and time of when the subscription was last updated."
    lastUpdated: String!
    "Number of licenses currently assigned to devices."
    totalAllowed: Int!
    "Number of licenses currently used by the devices."
    totalUsed: Int!
    "Name of the SKU for the account."
    skuName: String!
}

"Used to define callbacks including the device identity, the attribute names, corresponding attribute values and the date/timestamp of when the observation was made."
type ObservationRequest {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "List of devices."
    devices: [Device!]
    "Attributes are streaming RF parameters that you want to observe."
    attributes: [ObservationRequestAttribute!]
    "Describes value and unit of time."
    frequency: NumericalData!
    "Describes value and unit of time."
    duration: NumericalData!
}

"Streaming RF parameter that you want to observe."
type ObservationRequestAttribute {
    "Attribute identifier."
    name: AttributeIdentifier!
}

"A success response containing the current status of the request."
type DiagnosticsObservationResult {
    "Transaction identifier."
    transactionID: String!
    "Status of the request."
    status: String!
    "The date and time of when this request was created."
    createdOn: String!
}

"Streaming RF parameter for which you want to retrieve history data."
type HistoryAttributeValue {
    "Attribute identifier."
    name: AttributeIdentifier!
    "Attribute value."
    value: String!
    "Date and time the request was created."
    createdOn: String!
}

"Specifies the callback service that is being subscribed to and the URL where the listening service is running."
type CallbackRegistrationRequest {
    "The name of the billing account for which callback messages will be sent. Format: \"##########-#####\"."
    accountName: String!
    "The name of the callback service, which identifies the type and format of messages that will be sent to the registered URL."
    serviceName: String!
    "The URL for your web server."
    endpoint: String!
    "Your HTTP headers."
    httpHeaders: String!
}

"Callback information of an existing diagnostics subscription."
type DeviceDiagnosticsCallback {
    "The name of the billing account for which callback messages will be sent. Format: \"##########-#####\"."
    accountName: String!
    "The name of the callback service, which identifies the type and format of messages that will be sent to the registered URL."
    serviceName: String!
    "The URL for your web server."
    endpoint: String!
    "The date and time of when this request was created."
    createdOn: String!
    "Your HTTP headers."
    httpHeaders: String!
}

"Describes an attribute being observed and the frequency with which the attribute is being observed."
type AttributeSetting {
    "Attribute identifier."
    name: AttributeIdentifier!
    "Attribute value."
    value: String!
    "Date and time request was created."
    createdOn: String!
    "Is the attribute observable?"
    isObservable: Boolean!
    "Is the attribute being observed?"
    isObserving: Boolean!
    "Describes value and unit of time."
    frequency: NumericalData!
}

"Diagnostic observation settings and attributes for a device."
type DiagnosticObservationSetting {
    "The name of the billing account for which callback messages will be sent. Format: \"##########-#####\"."
    accountName: String!
    "Identifies a particular IoT device."
    device: Device!
    "Streaming RF parameters for which you want to retrieve diagnostic settings."
    attributes: [AttributeSetting!]
}

"The selected device and attributes for which a request should retrieve data."
type HistorySearchFilter {
    "Account name identifier."
    accountName: String!
    "Identifies a particular IoT device."
    device: Device!
    "Streaming RF parameters for which you want to retrieve history data."
    attributes: HistorySearchFilterAttributes!
}

"Streaming RF parameters for which you want to retrieve history data."
type HistorySearchFilterAttributes {
    "Attribute identifier."
    name: AttributeIdentifier!
}

"The time period for which a request should retrieve data, beginning with the limitTime.startOn and proceeding with the limitTime.duration."
type HistorySearchLimitTime {
    "The starting date-time for this request."
    startOn: String!
    "Describes value and unit of time."
    duration: NumericalData!
}

"Used to filter data by time period or number of devices."
type HistorySearchRequest {
    "The selected device and attributes for which a request should retrieve data."
    _filter: HistorySearchFilter!
    "The maximum number of historical attributes to include in the response. If the request matches more than this number of attributes, the response will contain an X-Next value in the header that can be used as the page value in the next request to retrieve the next page of events."
    _limitNumber: Int!
    "The time period for which a request should retrieve data, beginning with the limitTime.startOn and proceeding with the limitTime.duration."
    _limitTime: HistorySearchLimitTime!
    "Page number for pagination purposes."
    _page: String!
}

"History data for a selected device and its attributes at a specific time."
type History {
    "The name of the billing account for which you want retrieve history data. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "Identifies a particular IoT device."
    device: Device!
    "Streaming RF parameter for which you want to retrieve history data."
    attributes: HistoryAttributeValue!
}

"Identifies a particular IoT device."
type Device {
    "Device identifier."
    id: String!
    "Device kind identifier."
    kind: String!
}

"Describes value and unit of time."
type NumericalData {
    "Numerical value."
    value: Int!
    "Unit of time."
    unit: NumericalDataUnit!
}

"All error messages are returned in this format. Error codes and messages are listed on the Error Codes page, along with explanations and suggestions for corrective actions."
type DeviceDiagnosticsResult {
    "Simple error code."
    errorCode: String!
    "Detailed error message."
    errorMessage: String!
}

"Request body to Performs a device reboot."
type DeviceResetRequest {
    "The name of the account. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "The action you want to take on the device."
    action: String!
    "The devices for which you want to perform a factory reset or reboot."
    devices: [Device!]
}

"A new external ID."
type GenerateExternalIDResult {
    "Newly created security string."
    externalid: String!
}

"Authenticating account ID."
type GenerateExternalIDRequest {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifier!
}

"Subscription resource definition."
type Subscription {
    "The number of streaming failures due to faulty configuration."
    configurationfailures: Int!
    "The number of streaming failures due to faulty configuration."
    createdon: String!
    "Not currently used."
    delegateid: String!
    "Description of the subscription."
    description: String!
    "Whether the subscription is currently sending data."
    disabled: Boolean!
    "The address to which any error reports should be delivered."
    email: String!
    "Filter for events."
    filter: String!
    "ThingSpace unique ID for the subscription that was created."
    id: String!
    "Identifies the resource kind."
    kind: String!
    "Possible values: success or fail."
    laststreamingstatus: String!
    "The date and time that the last stream send was attempted."
    laststreamingtime: String!
    "The date the resource was last updated."
    lastupdated: String!
    "Name of the subscription."
    name: String!
    "The number of failures due to network problems."
    networkfailures: Int!
    streamfailures: Int!
    "The event type that will be sent in the data stream."
    streamkind: String!
    "Target to be used for dispatching events."
    targetid: String!
    targettype: String!
    "Version of the underlying schema resource."
    version: String!
    "The version of the resource."
    versionid: String!
}

"Target resource definition."
type Target {
    "The endpoint for data streams."
    address: String!
    "The transport format."
    addressscheme: String!
    "The billing account ID."
    billingaccountid: String!
    "The date the resource was created."
    createdon: String!
    "Security identification string."
    externalid: String!
    "ThingSpace unique ID for the target that was created."
    id: String!
    "Identifies the resource kind. Targets are ts.target."
    kind: String!
    "The date the resource was last updated."
    lastupdated: String!
    "Name of the target."
    name: String!
    "AWS region value."
    region: String!
    "Version of the underlying schema resource."
    version: String!
    "The version of the resource."
    versionid: String!
    "Description of the target."
    description: String!
}

"Search for targets by property values."
type QueryTargetRequest {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifier!
    "A comma-separated list of properties and comparator values to match against subscriptions in the ThingSpace account. See Working with Query Filters for more information. If the request does not include `$selection`, the response will include all subscriptions to which the requesting user has access."
    _selection: String!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifier!
}

"The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
type AccountIdentifier {
    billingaccountid: String!
}

"Target to delete."
type DeleteTargetRequest {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifier!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifier!
}

"The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
type ResourceIdentifier {
    "Target ID."
    id: String!
    "Device IMEI."
    imei: String!
}

"Details of the target that you want to create."
type CreateTargetRequest {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifier!
    "The ID of the authenticating billing account."
    billingaccountid: String!
    "Identifies the resource kind. Targets are ts.target."
    kind: String!
    "The endpoint for notifications or data streams. The format depends on the selected `addressscheme`.<br />`streamrest` requires a `host:port` value <br />`streamawsiot` requres a valid ARN."
    address: String!
    "The transport format. Valid values are: <br />streamawsiot - streamed data to an AWS account <br />streamrest - streamed REST data to a defined endpoint."
    addressscheme: String!
    fields: CreateTargetRequestFields!
    "Descriptive information about the target."
    description: String!
    "Security identification string created by a POST /targets/actions/newextid request."
    externalid: String!
    "Name of the target."
    name: String!
    "AWS region value."
    region: String!
    "OAuth 2.0 bearer token."
    key1: String!
    "OAuth 2 token and refresh token for TS to stream events to Target."
    oauth: TargetAuthentication!
}

"OAuth 2 token and refresh token for TS to stream events to Target."
type TargetAuthentication {
    body: TargetAuthenticationBody!
    version: String!
}

type TargetAuthenticationBody {
    "Authentication grant type."
    grantType: String!
    "Refresh token."
    refreshToken: String!
    "Authentication scopes."
    scope: String!
    "Authentication headers."
    headers: TargetAuthenticationBodyHeaders!
    "Host information."
    host: TargetAuthenticationBodyHost!
}

"Host information."
type TargetAuthenticationBodyHost {
    hostandpath: String!
}

"Authentication headers."
type TargetAuthenticationBodyHeaders {
    "Authorization header."
    authorization: String!
    "Content-Type header."
    contentType: String!
}

type CreateTargetRequestFields {
    httpheaders: FieldsHttpHeaders!
    "List of device types."
    devicetypes: [String!]
}

type FieldsHttpHeaders {
    authorization: String!
}

"The details of the subscription that you want to create."
type CreateSubscriptionRequest {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifier!
    "Descriptive information about the subscription."
    description: String!
    "Enable or disable the subscription. A disabled subscription will not send any data."
    disabled: Boolean!
    "The address to which any error reports should be delivered."
    email: String!
    "String containing a $filter object with a property and value to filter out non-matching events."
    filter: String!
    billingaccountid: String!
    "The type of event data to send via this subscription. This will be `ts.event` in most cases. Other event types are `ts.event.diagnostics` for device diagnostic data, `ts.event.configuration` for device configuration events, or `ts.event.security`. Note that the device ThingSpace client must support sending specific event types for anything other than `ts.event`."
    streamkind: String!
    "The ID of the target resource to be used when dispatching events. The corresponding target should have a “stream” addressscheme."
    targetid: String!
    "Name of the subscription."
    name: String!
    "Setting this value to `false` prevents the data returned from being aggregated and makes the data easier to parse."
    allowaggregation: Boolean!
}

"Fields and values to match."
type QuerySubscriptionRequest {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifier!
    "A comma-separated list of properties and comparator values to match against subscriptions in the ThingSpace account. See Working with Query Filters for more information. If the request does not include `$selection`, the response will include all subscriptions to which the requesting user has access."
    _selection: String!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifier!
}

"The subscription to delete."
type DeleteSubscriptionRequest {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifier!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifier!
}

"The request body identifies the device and the values to set."
type ChangeConfigurationRequest {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifier!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifier!
    "List of the field names and values to set."
    configuration: Configuration!
}

"List of the field names and values to set."
type Configuration {
    frequency: String!
}

"Change Configuration resource definition."
type ChangeConfigurationResponse {
    "The action requested in this event; “change” for device configuration changes."
    action: String!
    "The date and time of the change request."
    createdon: String!
    "The device’s ThingSpace UUID."
    deviceid: String!
    "List of fields affected by the event."
    fields: Fields!
    "foreign id"
    foreignid: String!
    "The unique ID of this ts.event.configuration event."
    id: String!
    "The kind of the ThingSpace resource that is being reported"
    kind: String!
    "The date and time that the event was last updated."
    lastupdated: String!
    "The name of the event; “SetConfigurationReq” for device configuration changes."
    name: String!
    "The current status of the request. The value will be “pending” until the device wakes up and ThingSpace can send the request to the device."
    state: String!
    "transaction id"
    transactionid: String!
    "version"
    version: String!
}

"Change Configuration resource definition."
type FindDeviceByPropertyResponse {
    "Billing account ID of the resource."
    billingaccountid: String!
    "The date the resource was created."
    createdon: String!
    eventretention: String!
    "Cellular SIM card identifier."
    iccid: String!
    "ThingSpace unique ID for the device that was added."
    id: String!
    "4G hardware device identifier."
    imei: String!
    "Identifies the resource kind."
    kind: String!
    "The date the resource was last updated."
    lastupdated: String!
    "The device’s service provider."
    providerid: String!
    "The value of the refidtype identifier."
    refid: String!
    "The device identifier type used to refer to this device."
    refidtype: String!
    "Service state of the device."
    state: String!
    "Version of the underlying schema resource."
    version: String!
    "The version of the resource."
    versionid: String!
}

"A success response includes an array of all matching devices. Each device includes the full device resource definition."
type FindDeviceByPropertyResponseList {
    deviceProperty: [FindDeviceByPropertyResponse!]
}

"A success response includes an array of all matching devices."
type SearchDeviceByPropertyResponseList {
    deviceProperty: [SearchDeviceByPropertyResponse!]
}

"The device identifier and fields to match in the search."
type SearchDeviceByPropertyResponse {
    "Billing account ID of the resource."
    billingaccountid: String!
    "The date the resource was created."
    createdon: String!
    eventretention: String!
    fields: Fields1!
    "Cellular SIM card identifier."
    iccid: String!
    "ThingSpace unique ID for the device that was added."
    id: String!
    "4G hardware device identifier."
    imei: String!
    "Identifies the resource kind."
    kind: String!
    "The date the resource was last updated."
    lastupdated: String!
    "The device’s service provider."
    providerid: String!
    "The value of the refidtype identifier."
    refid: String!
    "The device identifier type used to refer to this device."
    refidtype: String!
    "Service state of the device."
    state: String!
    "Version of the underlying schema resource."
    version: String!
    "The version of the resource."
    versionid: String!
}

"List of device sensors and their most recently reported values."
type SearchDeviceByPropertyFields {
    acceleration: Acceleration!
    battery: String!
    humidity: String!
    light: String!
    pressure: String!
    signalStrength: String!
    temperature: String!
    devicePropertylocation: DevicePropertylocation!
}

type DevicePropertylocation {
    latitude: String!
    longitude: String!
}

type Acceleration {
    x: String!
    y: String!
    z: String!
}

"Search Device By Property resource definition."
type SearchDeviceEventHistoryRequest {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifier!
    "A comma-separated list of properties and comparator values to match against subscriptions in the ThingSpace account. See Working with Query Filters for more information. If the request does not include `$selection`, the response will include all subscriptions to which the requesting user has access."
    _selection: String!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifier!
    "The maximum number of events to include in the response."
    _limitnumber: Int!
    "The maximum number of events to include in the response."
    _page: String!
}

"A success response includes an array of all matching events."
type SearchDeviceEventHistoryResponseList {
    searchDeviceEventHistory: [SearchDeviceResponse!]
}

"A success response includes an array of all matching events. Each event includes the full event resource definition."
type SearchDeviceResponse {
    "The action requested in this event; “change” for device configuration changes."
    action: String!
    "The date and time of the change request."
    createdon: String!
    "The device’s ThingSpace UUID."
    deviceid: String!
    "List of fields affected by the event."
    fields: Fields2!
    "The unique ID of this ts.event.configuration event."
    id: String!
    "The kind of the ThingSpace resource that is being reported; “ts.event.configuration” for device configuration changes."
    kind: String!
    "The date and time that the event was last updated."
    lastupdated: String!
    "The name of the event"
    name: String!
    "The current status of the request."
    state: String!
    "UUIDs of tag resources that are applied to this device."
    tagids: [String!]
    "transaction id"
    transactionid: String!
    "The version of the resource."
    version: String!
    "The version of the resource."
    versionid: String!
}

"Search Device By Property resource definition."
type SearchSensorHistoryRequest {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifier!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifier!
    "The maximum number of events to include in the response."
    _limitnumber: Int!
    "The maximum number of events to include in the response."
    _page: String!
}

"A success response includes an array of all matching events."
type SearchSensorHistoryResponseList {
    searchSensorHistory: [SearchDeviceResponse!]
}

"The request body identifies the device to delete."
type RemoveDeviceRequest {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifier!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifier!
}

"The request body must include the UUID of the subscription that you want to update plus any properties that you want to change."
type CreateIoTApplicationRequest {
    "A user defined name for the application being deployed in Azure IoT Central."
    appName: String!
    "The ThingSpace ID of the authenticating billing account"
    billingAccountID: String!
    "The Azure ClientID of the associated Azure target account"
    clientID: String!
    "The Azure Client Secret of the associated Azure target account"
    clientSecret: String!
    "The “email IDs” to be added to/sent to with this API."
    emailIDs: String!
    "The Azure Resource group of the associated Azure target account"
    resourcegroup: String!
    "This is the reference Azure IoT Central application developed by Verizon."
    sampleIOTcApp: String!
    "The Azure Subscription ID of the associated Azure target account"
    subscriptionID: String!
    "The Azure Tenant ID of the associated Azure target account"
    tenantID: String!
}

"A success response includes an array of all matching events. Each event includes the full event resource definition."
type CreateIoTApplicationResponse {
    "An application will be created under the user's Azure subscription with this name and of type IOT central."
    appName: String!
    "Part of the user credentials (from Azure) the user needs to use for calling further TS Core APIs for setting up Azure cloud connector."
    sharedSecret: String!
    "An IOT central endpoint the user can use to see the data that is being streamed."
    url: String!
}

"List of fields affected by the event."
type Fields {
    "List of the field names and values to set."
    configuration: Configuration!
}

type Fields1 {
    "List of device sensors and their most recently reported values."
    item: SearchDeviceByPropertyFields!
}

"List of fields affected by the event."
type Fields2 {
    temperature: String!
}

"Status of Hyper Precise Location on the device."
type BullseyeServiceResult {
    "The account the device belongs to."
    accountNumber: String!
    "List of devices."
    deviceList: [DeviceServiceInformation!]
    "ResponseCode and/or a message indicating success or failure of the request."
    responseType: ApiResponseCode!
}

"Device service information."
type DeviceServiceInformation {
    "ResponseCode and/or a message indicating success or failure of the request."
    responseType: ApiResponseCode!
    "The International Mobile Equipment Identifier of the device."
    imei: String!
    "Shows if Hyper Precise is enabled (true) or disabled (false)."
    bullseyeEnable: Boolean!
}

"Account number and list of devices."
type BullseyeServiceRequest {
    "A list of devices."
    deviceList: [DeviceServiceRequest!]
    "A unique identifier for an account."
    accountNumber: String!
}

"Device information."
type DeviceServiceRequest {
    "International Mobile Equipment Identifier. The unique ID of a device."
    imei: String!
    "Set to Enable (true) or Disable (false)."
    bullseyeEnable: Boolean!
}

"Error response."
type HyperPreciseLocationResult {
    "Error Code."
    responseCode: ErrorResponseCode!
    "Error message."
    message: String!
    "Fault occurred while responding."
    fault: HyperPreciseLocationFault!
    example: String!
}

"Fault occurred while responding."
type HyperPreciseLocationFault {
    "Hyper precise location fault code."
    code: String!
    "Hyper precise location fault message."
    message: String!
    "Hyper precise location fault description."
    description: String!
}

"ResponseCode and/or a message indicating success or failure of the request."
type ApiResponseCode {
    "Possible response codes."
    responseCode: ResponseCode!
    "More details about the responseCode received."
    message: String!
}

"Request for getting an aggregated session report."
type AggregateSessionReportRequest {
    "The unique identifier for the account."
    accountNumber: String!
    "Start date of session to include. If not specified  information will be shown from the earliest available (180 days). Can be either date in ISO 8601 format or predefined constants."
    startDate: String!
    "End date of session to include. If not specified  information will be shown to the latest available. Can be either date in ISO 8601 format or predefined constants."
    endDate: String!
    "Devices for which return usage info. Could be 0, 1 or more. In case of 0 will return all devices belonging to customer (except of filtered by other parameters)."
    imei: [String!]
    "User defined group name the devices are a member of."
    deviceGroup: String
    "Optional filter parameter."
    deviceLabel: String
    "The data plan the devices beign queried belong to."
    dataPlan: String
    "Optional filter parameter which return only devices with no sessions."
    noSessionFlag: String!
}

"Error reported by a device."
type AggregateUsageError {
    "International Mobile Equipment Identifier. This is the ID of the device reporting errors."
    imei: String!
    "A general error message."
    errorMessage: String!
    "Error message."
    errorResponse: IErrorMessage!
}

"Contains usage information per device."
type AggregateUsageItem {
    "International Mobile Equipment Identifier. This is the ID of the device reporting usage."
    imei: String!
    "Number of sessions established by the device reporting usage."
    numberOfSessions: Int!
    "The amount of data transferred by the device reporting usage, measured in Bytes."
    bytesTransferred: Int!
    example: String!
}

"Error message."
type IErrorMessage {
    "Error Code."
    errorCode: ErrorResponseCode!
    "Details and additional information about the error code."
    errorMessage: String!
    "HTML error code and description."
    httpStatusCode: HttpStatusCode!
    "More detail and information about the HTML error code."
    detailErrorMessage: String!
}

"Session and usage details for up to 10 devices."
type AggregateSessionReport {
    "A unique string that associates the request with the location report information that is sent in asynchronous callback message.ThingSpace will send a separate callback message for each device that was in the request. All of the callback messages will have the same txid."
    txid: String
    "Contains usage per device."
    usage: [AggregateUsageItem!]
    "An object containing any errors reported by the device."
    errors: [AggregateUsageError!]
}

"Aggregated usage report (Asynchronous)."
type AggregatedReportCallbackResult {
    "A unique string that associates the request with the location report information that is sent in asynchronous callback message.ThingSpace will send a separate callback message for each device that was in the request. All of the callback messages will have the same txid."
    txid: String!
    "QUEUED or COMPLETED. Requests for IoT devices with cacheMode=0 (cached) have status=COMPLETED; all other requests are QUEUED."
    status: AggregatedReportCallbackStatus!
}

"Request for obtaining a session report."
type SessionReportRequest {
    "Account Number."
    accountNumber: String!
    "Device ids."
    imei: String!
    "Start date of session to include. If not specified  information will be shown from the earliest available (180 days). Can be either date in ISO 8601 format or predefined constants."
    startDate: String!
    "End date of session to include. If not specified  information will be shown to the latest available. Can be either date in ISO 8601 format or predefined constants."
    endDate: String!
    "The Low value of session duration."
    durationLow: Int
    "The High value of session duration."
    durationHigh: Int
}

"Contains only dates when device had sessions."
type DailyUsageItem {
    "Start date of session. ISO 8601 format."
    startTime: String!
    "End date of session. ISO 8601 format."
    endTime: String!
    "Amount of data transferred, measured in Bytes."
    numBytes: Int!
}

"Session report for a device."
type SessionReport {
    "An object containing the start and end time of the session with the amount of data transferred."
    sessions: [DailyUsageItem!]
    "The 10-digit ID of the device."
    id: String!
    "A unique string that associates the request with the location report information that is sent in asynchronous callback message.ThingSpace will send a separate callback message for each device that was in the request. All of the callback messages will have the same txid."
    txid: String
    example: String!
}

type CallbackCreated {
    "The billing account number for which callback messages will be sent."
    aname: String!
    "The name of the callback service, which identifies the type and format of messages that will be sent to the registered URL."
    name: String!
    "The address of the callback listening service where the ThingSpace Platform will send callback messages for the service type."
    url: String!
}

"Registered callback listener."
type CallbackRegistered {
    "The billing account number for which callback messages will be sent."
    accountName: String!
    "The name of the callback service, which identifies the type and format of messages that will be sent to the registered URL."
    name: String!
}

"Callback registration request."
type HyperPreciseLocationCallback {
    "The name of the callback service that you want to subscribe to."
    name: String!
    "The address on your server where you have enabled a listening service for the specific type of callback messages. Specify a URL that is reachable from the Verizon data centers. If your service is running on HTTPS, you should use a one-way authentication certificate with a white-listed IP address."
    url: String!
}

"Trigger details."
type TriggerType1 {
    "Trigger name."
    name: String!
    "This is the value to use in the request body to detect anomalous behaivior. The values in this table will only be relevant when this parameter is set to this value."
    triggerCategory: String!
    "Account name."
    accountName: String!
    "The details of the UsageAnomaly trigger."
    anomalyTriggerRequest: AnomalyTriggerRequest!
    "The notification details of the trigger."
    notification: Notification!
}

"Trigger details."
type TriggerType2 {
    "The details of the UsageAnomaly trigger."
    anomalyattributes: UsageAnomalyAttributes!
    "The notification details of the trigger."
    notification: Notification!
}

"Trigger details."
type TriggerType3 {
    "Trigger ID."
    triggerId: String!
    "Trigger name."
    triggerName: String!
    "This is the value to use in the request body to detect anomalous behaivior. The values in this table will only be relevant when this parameter is set to this value."
    triggerCategory: String!
    "Account name."
    accountName: String!
    "The details of the UsageAnomaly trigger."
    anomalyTriggerRequest: AnomalyTriggerRequest!
    "The notification details of the trigger."
    notification: Notification!
}

"The details of the UsageAnomaly trigger."
type AnomalyTriggerRequest {
    "The Verizon billing accounts associated with the anomaly triggers for this trigger to be active for devices in those accounts. An account name is usually numeric, and must include any leading zeros."
    accountNames: String!
    "Whether or not to include anomalies classified as 'abnormal'.<br />true<br />false<br />Classification is set as part of ThingSpace Intelligence anomaly detection settings."
    includeAbnormal: Boolean!
    "Whether or not to include anomalies classified as 'very abnormal'.<br />true<br />false<br />Classification is set as part of ThingSpace Intelligence anomaly detection settings."
    includeVeryAbnormal: Boolean!
    "Whether or not to include anomalies that are directionally under the expected usage.<br />true<br />false."
    includeUnderExpectedUsage: Boolean!
    "Whether or not to include anomalies that are directionally over the expected usage. <br />true<br />false."
    includeOverExpectedUsage: Boolean!
}

"The details of the UsageAnomaly trigger."
type UsageAnomalyAttributes {
    "The Verizon billing account associated with the anomaly triggers for this trigger to be active for devices in those accounts. An account name is usually numeric, and must include any leading zeros."
    accountNames: String!
    "The names of device groups associated with the anomaly triggers for this trigger to be active for devices in those groups."
    deviceGroup: String!
    "Whether or not to include anomalies classified as 'abnormal'.<br />true<br />false<br />Classification is set as part of ThingSpace Intelligence anomaly detection settings."
    includeAbnormal: Boolean!
    "Whether or not to include anomalies classified as 'very abnormal'.<br />true<br />false<br />Classification is set as part of ThingSpace Intelligence anomaly detection settings."
    includeVeryAbnormal: Boolean!
    "Whether or not to include anomalies that are directionally under the expected usage.<br />true<br />false."
    includeUnderExpectedUsage: Boolean!
    "Whether or not to include anomalies that are directionally over the expected usage. <br />true<br />false."
    includeOverExpectedUsage: Boolean!
}

"Notification SMS details."
type SMSNumber {
    carrier: String!
    number: String!
}

"The notification details of the trigger."
type Notification {
    "The type of notification, i.e. 'DailySummary'."
    notificationType: String!
    "Whether or not the notification should be sent via callback.<br />true<br />false."
    callback: Boolean!
    "Whether or not the notification should be sent via e-mail.<br />true<br />false."
    emailNotification: Boolean!
    "Name for the notification group."
    notificationGroupName: String!
    "Frequency factor for notification."
    notificationFrequencyFactor: Int!
    "Frequency interval for notification."
    notificationFrequencyInterval: String!
    "E-mail address(es) where the notification should be delivered."
    externalEmailRecipients: String!
    "SMS notification."
    smsNotification: Boolean!
    "List of SMS numbers."
    smsNumbers: [SMSNumber!]
    reminder: Boolean!
    "Severity level associated with the notification. Examples would be:<br />Major<br />Minor<br />Critical<br />NotApplicable."
    severity: String!
}

type UpdateTriggerRequest {
    accountName: String!
    active: Boolean!
    "The details of the UsageAnomaly trigger."
    anomalyTriggerRequest: AnomalyTriggerRequest!
    cycleType: CycleType!
    dataTriggerRequest: DataTriggerRequest!
    groupName: String!
    promoAlertTriggerRequest: PromoAlertTriggerRequest!
    sessionTriggerRequest: SessionTriggerRequest!
    smsTriggerRequest: SMSTriggerRequest!
    triggerCategory: String!
    triggerId: String!
    triggerName: String!
}

type PromoAlertTriggerRequest {
    dataPercentage50: Boolean!
    dataPercentage75: Boolean!
    dataPercentage90: Boolean!
    noOfDaysB4PromoExp: Int!
    smsPercentage50: Boolean!
    smsPercentage75: Boolean!
    smsPercentage90: Boolean!
}

type CreateTriggerRequest {
    accountName: String!
    "The details of the UsageAnomaly trigger."
    anomalyTriggerRequest: AnomalyTriggerRequest!
    dataTriggerRequest: DataTriggerRequest!
    groupName: String!
    name: String!
    sessionTriggerRequest: SessionTriggerRequest!
    smsTriggerRequest: SMSTriggerRequest!
    triggerCategory: String!
    triggerCycle: String!
}

type DataTriggerRequest {
    comparator: String!
    threshold: Int!
    thresholdUnit: String!
}

type SessionTriggerRequest {
    comparator: String!
    threshold: Int!
}

type SMSTriggerRequest {
    comparator: String!
    smsType: String!
    threshold: Int!
}

type CreateTriggerRequestOptions {
    "Trigger name."
    name: String!
    "This is the value to use in the request body to detect anomalous behaivior. The values in this table will only be relevant when this parameter is set to this value."
    triggerCategory: String!
    "Account name."
    accountName: String!
    "The details of the UsageAnomaly trigger."
    anomalyTriggerRequest: AnomalyTriggerRequest!
    "The notification details of the trigger."
    notification: Notification!
    "Indicates anomaly detection is active<br />True - Anomaly detection is active.<br />False - Anomaly detection is not active."
    active: Boolean!
}

type UpdateTriggerRequestOptions {
    "Trigger ID."
    triggerId: String!
    "Trigger name."
    triggerName: String!
    "This is the value to use in the request body to detect anomalous behaivior. The values in this table will only be relevant when this parameter is set to this value."
    triggerCategory: String!
    "Account name."
    accountName: String!
    "The details of the UsageAnomaly trigger."
    anomalyTriggerRequest: AnomalyTriggerRequest!
    "The notification details of the trigger."
    notification: Notification!
    "Indicates anomaly detection is active<br />True - Anomaly detection is active.<br />False - Anomaly detection is not active."
    active: Boolean!
}

type GetTriggerResponse {
    accountName: String!
    comparator: String!
    createdAt: String!
    groupName: String!
    modifiedAt: String!
    notificationGroupName: String!
    organizationName: String!
    smsType: String!
    threshold: String!
    thresholdUnit: String!
    triggerCategory: String!
    triggerCycle: String!
    triggerId: String!
    triggerName: String!
}

type GetTriggerResponseList {
    triggers: [GetTriggerResponse!]
}

"Whether the anomaly detection is active or not."
type ActiveAnomalyIndicator {
    "Indicates anomaly detection is active<br />True - Anomaly detection is active.<br />False - Anomaly detection is not active."
    active: Boolean!
}

"Whether the trigger is active or not."
type ActiveTriggerIndicator {
    "Indicates if the trigger is active<br />True - trigger is active<br />False - trigger is not active."
    active: Boolean!
}

"A result containing a list of anomaly triggers."
type AnomalyTriggerResult {
    "Trigger value chunk details."
    triggers: [TriggersListOptions!]
}

type TriggersListOptions {
    "The system assigned name of the trigger being updated."
    triggerId: String!
    "The user defined name of the trigger."
    triggerName: String!
    "The user assigned name of the organization associated with the trigger."
    organizationName: String!
    "This is the value to use in the request body to detect anomalous behaivior. The values in this table will only be relevant when this parameter is set to this value."
    triggerCategory: String!
    "Additional details and keys for the trigger."
    triggerAttributes: [TriggerAttributesOptions!]
    "Timestamp for whe the trigger was created."
    createdAt: String!
    "Timestamp for the most recent time the trigger was modified."
    modifiedAt: String!
    "The details of the UsageAnomaly trigger."
    anomalyattributes: UsageAnomalyAttributes!
    "The notification details of the trigger."
    notification: Notification!
}

"Trigger details."
type AnomalyTriggerValue {
    "The system assigned name of the trigger being updated."
    triggerId: String!
    "The user defined name of the trigger."
    triggerName: String!
    "The user assigned name of the organization associated with the trigger."
    organizationName: String!
    "This is the value to use in the request body to detect anomalous behaivior. The values in this table will only be relevant when this parameter is set to this value."
    triggerCategory: String!
    "Additional details and keys for the trigger."
    triggerAttributes: [TriggerAttributesOptions!]
    "Timestamp for whe the trigger was created."
    createdAt: String!
    "Timestamp for the most recent time the trigger was modified."
    modifiedAt: String!
}

type TriggerAttributesOptions {
    "If present, the NotificationGroupName will be listed here."
    key: String!
    "DataPercentage50<br />True - Trigger on Data percentage is over 50% used<br />False - Do not trigger when over 50% used."
    value: Boolean!
}

"Notification group name trigger attribute."
type NotificationGroupNameTriggerAttribute {
    "If present, the NotificationGroupName will be listed here."
    key: String!
}

"Key service plan trigger attribute."
type ServicePlanTriggerAttribute {
    "The ServicePlan name will be listed here."
    key: String!
}

"Trigger attribute for when data percentage is over 50% used."
type DataPercentage50TriggerAttribute {
    "Key data percentage 50."
    key: String!
    "DataPercentage50<br />True - Trigger on Data percentage is over 50% used<br />False - Do not trigger when over 50% used."
    value: Boolean!
}

"Trigger attribute for when data percentage is over 75% used."
type DataPercentage75TriggerAttribute {
    "Key data percentage 75."
    key: String!
    "DataPercentage75<br />True - Trigger on Data percentage is over 75% used<br />False - Do not trigger when over 75% used."
    value: Boolean!
}

"Trigger attribute for when data percentage is over 90% used."
type DataPercentage90TriggerAttribute {
    "Key data percentage 90."
    key: String!
    "DataPercentage90<br />True - Trigger on Data percentage is over 90% used<br />False - Do not trigger when over 90% used."
    value: Boolean!
}

"Trigger attribute for when data percentage is over 100% used."
type DataPercentage100TriggerAttribute {
    "Key data percentage 100."
    key: String!
    "DataPercentage100<br />True - Trigger on Data percentage is over 100% used<br />False - Do not trigger when over 100% used."
    value: Boolean!
}

"Settings for anomaly detection."
type AnomalyDetectionSettings {
    "Indicates if the account name used has anomaly detection.<br />Success - The account has anomaly detection.<br />Failure - The account does not have anomaly detection."
    accountName: String!
    "Details for sensitivity parameters."
    sensitivityParameter: SensitivityParameters!
    "Indicates if anomaly detection is active on the account<br />Active - Anomaly detection is active<br />Disabled- Anomaly detection is not active."
    status: String!
}

"Anomaly detection request."
type AnomalyDetectionRequest {
    "The name of a billing account. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "The type of request being made. anomaly is the request to activate anomaly detection."
    requestType: String!
    "Details for sensitivity parameters."
    sensitivityParameter: SensitivityParameters!
}

"Details for sensitivity parameters."
type SensitivityParameters {
    "The maximum value of the threshold in the units being measured."
    abnormalMaxValue: Float!
    "If abnormal values are being monitored.<br />true - Monitor for abnormal values<br />false - Do not monitor for abnormal values."
    enableAbnormal: Boolean!
    "If very abnormal values are being monitored.<br />true - Monitor for very abnormal values<br />false - Do not monitor for very abnormal values."
    enableVeryAbnormal: Boolean!
    "The maximum value of the threshold in the units being measured."
    veryAbnormalMaxValue: Float!
}

"Success response."
type IntelligenceSuccessResult {
    "Anomaly detection status."
    status: String!
}

"Trigger for anomaly detection."
type AnomalyDetectionTrigger {
    "Trigger ID to identify the request in a callback."
    triggerId: String!
}

"An error occurred."
type IntelligenceResult {
    "The 3-digit HTML error code."
    errorCode: String!
    "Error Message."
    errorMessage: String!
}

"Get device experience score history."
type GetDeviceExperienceScoreHistoryRequest {
    "Account name."
    accountName: String!
    "Device Id details."
    deviceId: DeviceIdentifier!
}

"Get device experience score bulk request."
type GetDeviceExperienceScoreBulkRequest {
    "Account name."
    accountName: String!
    deviceList: [DeviceIdentifier!]
}

"Get network conditions."
type GetNetworkConditionsRequest {
    "Account name."
    accountName: String!
    "Type of location detail."
    locationType: String!
    "Coordinates information."
    coordinates: Coordinates!
}

"Get wireless coverage."
type GetWirelessCoverageRequest {
    "Account name."
    accountName: String!
    "Type of request."
    requestType: String!
    "Type of location detail."
    locationType: String!
    "Location coordinates."
    locations: Locationscoord!
    networkTypesList: [NetworkType!]
}

"Get wireless coverage FWA."
type GetWirelessCoverageRequestFWA {
    "Account name."
    accountName: String!
    "Type of request."
    requestType: String!
    "Type of location detail."
    locationType: String!
    "Location details."
    locations: Locations!
    networkTypesList: [NetworkType!]
}

"Location coordinates."
type Locationscoord {
    coordinatesList: [Coordinates!]
}

"Location details."
type Locations {
    addressList: [AddressItem!]
}

"Network type."
type NetworkType {
    networkType: String!
}

"Coordinates information."
type Coordinates {
    "Latitude value of location."
    latitude: String!
    "Longitude value of location."
    longitude: String!
}

"Address details."
type AddressItem {
    "Street Address."
    addressLine1: String!
    "Optional address information."
    addressLine2: String!
    "Name of the city."
    city: String!
    "State code."
    state: String!
    "Country."
    country: String!
    "Five digit zipcode."
    zip: String!
    "Four digit zip code."
    zip4: String!
}

"Device Id details."
type DeviceIdentifier {
    "Kind of device."
    kind: String!
    "Device Identity number."
    id: String!
    "Device MDN number."
    mdn: String!
}

"Wireless network performance request response."
type WNPRequestResponse {
    "Request id."
    requestId: String!
}

"Wireless network performance rest error response."
type WNPRestErrorResponse {
    "Rest error response."
    errorCode: String!
    "Error message details."
    errorMessage: String!
}

type StatusResponse {
    requestId: String!
    status: String!
    subrequests: [Subrequest!]
}

type Subrequest {
    ids: GIODeviceId!
    status: String!
}

type ProvhistoryRequest {
    accountName: String!
    deviceFilter: [GIODeviceId!]
    earliest: String!
    latest: String!
}

type GetDeviceListWithProfilesRequest {
    accountName: String!
    provisioningStatusFilter: String!
    profileStatusFilter: String!
    carrierNameFilter: String!
    deviceFilter: [GIODeviceId!]
}

type SMSEventHistoryRequest {
    deviceId: GIODeviceId!
    earliest: String!
    latest: String!
}

type SmsMessagesResponse {
    messages: [GIOSmsMessage!]
    hasMoreData: Boolean!
}

type GIOSmsMessage {
    deviceIds: [GIODeviceId!]
    message: String!
    timestamp: String!
}

type GIOSMSSendRequest {
    accountName: String!
    customFields: [KvPair!]
    dataEncoding: String!
    groupName: String!
    servicePlan: String!
    timeToLive: String!
    deviceIds: [GIODeviceId!]
    smsMessage: String!
}

type KvPair {
    key: String!
    value: String!
}

type SMSOptionsSendRequest {
    servicePlan: String!
    smsMessage: String!
}

type GIOProfileRequest {
    devices: [GIODeviceList!]
    accountName: String!
    mdnZipCode: String!
    servicePlan: String!
}

type GIODeactivateDeviceProfileRequest {
    devices: [GIODeviceList!]
    accountName: String!
    servicePlan: String!
    etfWaiver: Boolean!
    reasonCode: String!
}

type DeviceProfileRequest {
    devices: [GIODeviceList!]
    accountName: String!
    servicePlan: String!
}

type GIODeviceId {
    kind: String!
    id: String!
}

type GIODeviceList {
    deviceIds: [GIODeviceId!]
}

type GIORequestResponse {
    requestId: String!
}

type SuccessResponse {
    success: Boolean!
}

type GIORestErrorResponse {
    errorCode: String!
    errorMessage: String!
}

type SubscribeRequest {
    accountName: String!
    deviceInfo: [QOSdeviceInfo!]
}

type QOSdeviceId {
    id: String!
    kind: String!
}

type DefaultResponse {
    errorCode: String!
    errorMessage: String!
}

type 201success {
    requestId: String!
}

type FlowInfo {
    flowServer: String!
    flowDevice: String!
    flowDirection: String!
    flowProtocol: String!
    qciOption: String!
}

type QOSdeviceInfo {
    deviceId: QOSdeviceId!
    deviceIPv6Addr: String!
    flowInfo: [FlowInfo!]
}

type ChangePmecDeviceStateActivateRequest {
    accountName: String!
    deviceList: [MECDeviceList!]
    activate: Activate!
}

type MECDeviceList {
    deviceIds: [MECDeviceId!]
}

type MECDeviceId {
    id: String!
    kind: String!
}

type Activate {
    profile: String!
}

type ChangePmecDeviceStateBulkActivateRequest {
    accountName: String!
    deviceList: [DeviceList1!]
    activate: Activate!
}

type DeviceList1 {
    deviceIds: [MECDeviceId!]
    ipAddress: String!
    apn: String!
}

type ChangePmecDeviceStateBulkDeactivateRequest {
    accountName: String!
    deviceList: [MECDeviceList!]
}

type ChangePmecDeviceStateDeactivateRequest {
    accountName: String!
    deviceList: [MECDeviceList!]
}

type ChangePmecDeviceProfileRequest {
    accountName: String!
    deviceList: [MECDeviceList!]
    newProfile: String!
}

type ChangePmecDeviceProfileBulkRequest {
    accountName: String!
    deviceList: [MECDeviceList!]
    newProfile: String!
}

type ChangePmecDeviceIPaddressBulkRequest {
    accountName: String!
    deviceList: [MECDeviceList!]
}

type ChangePmecDeviceIPaddressRequest {
    accountName: String!
    deviceList: [DeviceList7!]
}

type DeviceList7 {
    deviceIds: [MECDeviceId!]
    ipAddress: String!
}

"Response to change mec device state"
type ChangeMecDeviceStateResponse {
    "A unique string that associates the request with the results that are sent via a callback service."
    requestId: String!
}

"Response to change mec device profile"
type ChangeMecDeviceProfileResponse {
    "A unique string that associates the request with the results that are sent via a callback service."
    requestId: String!
}

"Response to change mec device ip address."
type ChangeMecDeviceIPAddressResponse {
    "A unique string that associates the request with the results that are sent via a callback service."
    requestId: String!
}

"MEC Performance Consent Response"
type GetMECPerformanceConsentResponse {
    "MEC Performance Consent Response."
    consent: String!
}

"KPI Info Object"
type KPIInfo {
    name: String!
    value: String!
    nodeName: String!
    nodeType: String!
    description: String!
    unit: String!
    category: String!
    timeOfLastUpdate: String!
}

type KPIInfoList {
    kpiInfoList: [KPIInfo!]
}

type MECProfileList {
    profiles: [MECProfile!]
}

type MECProfile {
    profileId: String!
    profileName: String!
}

type ResponsetoUsageQuery {
    hasmoredata: Boolean!
    deviceId: ReadySimDeviceId!
    usageHistory: [Usagehistory!]
}

type RequestBodyforUsage {
    accountId: String!
    deviceId: [ReadySimDeviceId!]
    startTime: String!
    endTime: String!
}

type RequestBodyforUsage1 {
    deviceId: [ReadySimDeviceId!]
    startTime: String!
    endTime: String!
}

type ReadySimDeviceId {
    kind: String!
    id: String!
}

type Usagehistory {
    bytesUsed: Int!
    serviceplan: String!
    smsUsed: Int!
    moSMS: Int!
    mtSMS: Int!
    source: String!
    eventDateTime: String!
}

type TriggerValueResponse {
    triggers: [Triggervalues!]
}

type Triggervalues {
    triggerId: String!
    triggerName: String!
    accountName: String!
    organizationName: String!
    triggerCategory: String!
    triggerAttributes: [KeyDataPercentage50!]
    createdAt: String!
    modifiedAt: String!
}

type TriggerValueResponse2 {
    triggers: [Triggervalues2!]
}

type Triggervalues2 {
    triggerId: String!
    triggerName: String!
    accountName: String!
    organizationName: String!
    triggerCategory: String!
    promoAlerts: [PromoAlert!]
    active: Boolean!
    createdAt: String!
    modifiedAt: String!
}

type RequestTrigger {
    triggerId: String!
    triggerName: String!
    accountName: String!
    organizationName: String!
    triggerCategory: String!
    promoAlerts: [PromoAlert1!]
}

type Condition {
    condition: [Keyschunk2!]
}

type Keyschunk2 {
    dataPercentage50: Boolean!
    dataPercentage75: Boolean!
    dataPercentage90: Boolean!
    dataPercentage100: Boolean!
    smsPercentage50: Boolean!
    smsPercentage75: Boolean!
    smsPercentage90: Boolean!
    smsPercentage100: Boolean!
    noOfDaysB4PromoExp: Int!
}

type EnablePromoExp {
    enablePromoExp: Boolean!
}

type Filtercriteria {
    filterCriteria: [ReadySimServicePlan!]
}

type Filtercriteria2 {
    filterCriteria: [String!]
}

type ReadySimServicePlan {
    servicePlan: String!
}

type KeyServicePlan {
    key: String!
}

type KeyDataPercentage50 {
    key: String!
    value: Boolean!
}

type KeysmsPercentage50 {
    key: String!
    value: Boolean!
}

type NoOfDaysB4PromoExp {
    key: String!
    value: Int!
}

type EnablePromoExp1 {
    key: String!
    value: Boolean!
}

type UsageRequestResponse {
    requestId: String!
}

type Success {
    status: String!
}

type ReadySimRestErrorResponse {
    errorCode: String!
    errorMessage: String!
}

type PromoAlert {
    filterCriteria: [ReadySimServicePlan!]
    condition: [Keyschunk2!]
    enablePromoExp: Boolean!
}

type PromoAlert1 {
    filterCriteria: [String!]
    condition: [Keyschunk2!]
    enablePromoExp: Boolean!
}

type Status {
    status: Status1!
}

type ESIMDeviceId {
    id: String!
    kind: String!
}

type DeviceId2 {
    id: String!
    kind: String!
}

type ESIMDeviceList {
    deviceIds: [ESIMDeviceId!]
}

type DeviceList2 {
    ids: [ESIMDeviceId!]
}

type ESIMProfileRequest {
    devices: [ESIMDeviceList!]
    carrierName: String!
    accountName: String!
    servicePlan: String!
    mdnZipCode: String!
}

type ProfileRequest2 {
    devices: [DeviceList2!]
    accountName: String!
    carrierName: String!
    reasonCode: String!
    etfWaiver: Boolean!
    checkFallbackProfile: Boolean!
}

type ESIMRequestResponse {
    requestId: String!
}

type ESIMRestErrorResponse {
    errorCode: String!
    errorMessage: String!
}

type ESIMProvhistoryRequest {
    accountName: String!
    deviceFilter: [DeviceId2!]
    earliest: String!
    latest: String!
}

type ESIMStatusResponse {
    requestId: String!
    status: String!
    subrequests: [ESIMsubrequest!]
}

type ESIMsubrequest {
    id: String!
    kind: String!
    status: Status1!
}

"Request for /vendors/registration endpoint. It requires the VendorID and ThingSpace Billing Account number to be defined."
type VendorRegistrationRequest {
    "The ID the vendor wants it's devices to be registered under. E.g. Verizon, GM, Ford, etc."
    vendorID: String!
    "The ThingSpace Billing Account number."
    thingSpaceBillingAccount: String!
}

"Response for /vendors/registration. It provides a response if the vendor wa added to the system or updated with the new data."
type VendorRegistrationResponse {
    "The type of action the vendor registration service took for the request\n\nValues:\n- **Added** - A new vendor was added to the system\n- **Updated** - The existing vendor was updated with the newly provided properties"
    actionType: ActionType!
}

"Request for /clients/registration endpoint. It requires the Client Type, Subtype and Vendor to be defined."
type ClientRegistrationRequest {
    clientType: String!
    "The subtype or subgroup of the client type. This further specifies the client type. For example it will specify if the client is a passenger car or a truck. See the ClientType description for the supported Subtypes for each client type."
    clientSubtype: ClientSubtype!
    "The vendor that the client belongs to. E.g. Verizon, GM, Ford, etc."
    vendorID: String!
}

"Response for /clients/registration. It provides a generated device ID and the certificates needed to connect the IMP Message Exchange."
type ClientRegistrationResponse {
    "The generated ID for the device. It has to be used as the MQTT Client ID when connecting to the Message Exchange system or when asking for the connection endpoint."
    deviceID: ID!
    "Structure for the credentials required to connect to the IMP MQTT Message Exchange."
    certificate: Certificate!
}

"Request for /clients/connection. It requires the device ID acquired in the registration request call; the geolocation of the device at the time of the request; and the network type (Verizon or non-Verizon). The system uses this information to determine with MQTT endpoint the device should use to connect the IMP Message Exchange."
type ConnectionRequest {
    "The device ID acquired through the registration API."
    deviceID: ID!
    "Geolocation of the device at the time of the connection request in GPS coordinates."
    geolocation: Geolocation!
    networkType: String!
}

"response for /clients/connection"
type ConnectionResponse {
    mqttURL: String!
}

"Structure for the credentials required to connect to the IMP MQTT Message Exchange."
type Certificate {
    "The string containing the certificate"
    certpem: String!
    "The string containing the private key"
    keypem: String!
}

"Geolocation of the device at the time of the connection request in GPS coordinates."
type Geolocation {
    "The GPS Latitude value"
    latitude: Float!
    "The GPS Longitude value"
    longitude: Float!
}

"error response structure"
type IMPResponseError {
    "The short summary of the error"
    error: String!
    "The detailed description of the error"
    description: String!
}

type Polygon {
    type: String!
    coordinates: [Coordinate!]
}

"error response structure"
type MapDataResponseError {
    "The short summary of the error"
    error: String!
    "The detailed description of the error"
    description: String!
}

type Coordinate {
    latitude: String!
    longitude: String!
}

input ListMECPlatformsInput {
    "MEC region name. Current valid values are US_WEST_2 and US_EAST_1."
    region: String!
    "Unique identifier of the service profile."
    serviceProfileId: String!
    "Minimum number of 4G/5G subscribers per square kilometer."
    subscriberDensity: Int!
    "Type of User Equipment identifier used in `UEIdentity`."
    uEIdentityType: UserEquipmentIdentityType!
    "The identifier value for User Equipment. The type of identifier is defined by the 'UEIdentityType' parameter. The`IPAddress`format can be IPv4 or IPv6."
    uEIdentity: String!
}

input ListOptimalServiceEndpointsInput {
    "MEC region name. Current valid values are US_WEST_2 and US_EAST_1."
    region: String!
    "Minimum number of 4G/5G subscribers per square kilometer."
    subscriberDensity: Int!
    "Type of User Equipment identifier used in `UEIdentity`."
    uEIdentityType: UserEquipmentIdentityType!
    "The identifier value for User Equipment. The type of identifier is defined by the 'UEIdentityType' parameter. The`IPAddress`format can be IPv4 or IPv6."
    uEIdentity: String!
    "A system-defined string identifier representing one or more registered Service Endpoints."
    serviceEndpointsIds: String!
}

"Service Endpoint path, address, and port."
input ResourcesServiceEndpointInput {
    "URI of Service Endpoint if available."
    uRI: String!
    "FQDN of Service Endpoint if available."
    fQDN: String!
    "IPv4 Address of Service Endpoint if available."
    iPv4Address: String!
    "IPv6 Address of Service Endpoint if available."
    iPv6Address: String!
    "Port information of Service Endpoint if IPv4 or IPv6 is mentioned."
    port: Int!
}

"Edge hosted service represented by Service Endpoint definition."
input ResourcesEdgeHostedServiceWithProfileIdInput {
    "Edge Resource Name. A string identifier for a set of edge resources."
    ern: String!
    "Service Endpoint path, address, and port."
    serviceEndpoint: ResourcesServiceEndpointInput!
    "Unique ID representing the Edge Application Provider."
    applicationServerProviderId: String!
    "Unique ID representing the Edge Application."
    applicationId: String!
    serviceDescription: String!
    "The system assigned ID of the service profile."
    serviceProfileID: String!
}

input CreateRegisterserviceendpointsInput {
    contentType: String!
    "An array of Service Endpoint data for a deployed application. The request body passes all of the needed parameters to create a service endpoint. Parameters will be edited here rather than the **Parameters** section above. The `ern`,`applicationServerProviderId`, `applicationId` and `serviceProfileID` parameters are required. **Note:** Currently, the only valid value for `applicationServerProviderId`is **AWS**. Also, if you do not know one of the optional values (i.e. URI), you can erase the line from the query by back-spacing over it."
    body: [ResourcesEdgeHostedServiceWithProfileIdInput!]
}

input GetServiceEndpointInput {
    "A system-defined string identifier representing one or more registered Service Endpoints."
    serviceEndpointsId: String!
}

input UpdateServiceEndpointInput {
    "A system-defined string identifier representing one or more registered Service Endpoints."
    serviceEndpointsId: String!
    contentType: String!
    "Data needed for Service Endpoint information. The request body passes the rest of the needed parameters to create a service endpoint. Parameters other than `serviceEndpointsId` will be edited here rather than the **Parameters** section above. The `ern`,`applicationServerProviderId` and `applicationId` parameters are required. **Note:** Currently, the only valid value for `applicationServerProviderId`is **AWS**."
    body: [ResourcesEdgeHostedServiceWithProfileIdInput!]
}

input DeleteDeregisterserviceendpointInput {
    "A system-defined string identifier representing one or more registered Service Endpoints."
    serviceEndpointsId: String!
}

"Network resources of a service profile."
input NetworkResourcesTypeInput {
    "Minimum required connection bandwidth in Kbit/s for the application."
    minBandwidthKbits: Int!
    "Indicates if service continuity support is required or not for the application."
    serviceContinuitySupport: Boolean!
    "Maximum request rate that the application can handle."
    maxRequestRate: Int!
    "Maximum response time or latency that the application can handle, in milliseconds. Note: this value must be in multiples of 5."
    maxLatencyMs: Int!
    "Minimum availability required for the server."
    minAvailability: Int!
}

"GPU resources of a service profile."
input GPUInput {
    "Minimum Core Clock value in megahertz."
    minCoreClockMHz: Int!
    "Minimum Memory Clock value in megahertz."
    minMemoryClockMHz: Int!
    "Minimum GPU bandwidth in GB/s."
    minBandwidthGBs: Int!
    "Minimum Floating Point Operations Per Second in Teraflops."
    minTFLOPS: Int!
}

"Compute resources of a service profile."
input ComputeResourcesTypeInput {
    "GPU resources of a service profile."
    gPU: GPUInput!
    "Minimum RAM required in Gigabytes."
    minRAMGB: Int!
    "Minimum storage requirement in Gigabytes."
    minStorageGB: Int!
}

"Data about additional service support information for the MEC platform."
input MECPlatformsAdditionalSupportInfoDataInput {
    additionalInfo: String!
}

"Additional service support information for the MEC platform."
input MECPlatformsAdditionalSupportInfoInput {
    "Type of additional service support information for the MEC platform."
    type: String!
    "Data about additional service support information for the MEC platform."
    data: MECPlatformsAdditionalSupportInfoDataInput!
}

"Information about the resource requirements and service characteristics of an edge application. The `maxLatencyMs` and `clientType` parameters are both required in the request body. **Note:** The `maxLatencyMs` value must be submitted in multiples of 5. Does not include serviceProfileId"
input ResourcesServiceProfileInput {
    "The category of application client."
    clientType: ClientType!
    "Identity of the preferred Edge Computing Service Provider."
    ecspFilter: String!
    "The expected operation schedule of the application client (e.g. time windows)."
    clientSchedule: String!
    "The expected location(s) (e.g. route) of the hosting UE during the Client's operation schedule."
    clientServiceArea: String!
    "Network resources of a service profile."
    networkResources: NetworkResourcesTypeInput!
    "Compute resources of a service profile."
    computeResources: ComputeResourcesTypeInput!
    "Additional service support information for the MEC platform."
    properties: MECPlatformsAdditionalSupportInfoInput!
}

input CreateServiceProfileInput {
    contentType: String!
    "The request body passes all of the needed parameters to create a service profile. Parameters will be edited here rather than the **Parameters** section above. The `maxLatencyMs` and `clientType` parameters are both required in the request body. **Note:** The `maxLatencyMs` value must be submitted in multiples of 5. Additionally, \"GPU\" is future functionality and the values are not captured."
    body: ResourcesServiceProfileInput!
}

input GetServiceProfileInput {
    serviceProfileId: String!
}

input UpdateServiceProfileInput {
    serviceProfileId: String!
    contentType: String!
    "The request body passes the rest of the needed parameters to create a service profile. The `maxLatencyMs` and `clientType` parameters are both required in the request body. **Note:** The `maxLatencyMs` value must be submitted in multiples of 5. Additionally, \"GPU\" is future functionality and the values are not captured. Default values to use are shown."
    body: ResourcesServiceProfileInput!
}

input DeleteServiceProfileInput {
    serviceProfileId: String!
}

"Custom data that can be included using key-value pairs."
input CustomFieldsInput {
    "The key for an extended attribute."
    key: String!
    "The value of an extended attribute."
    value: String!
}

"An identifier for a single device."
input DeviceIdInput {
    "The value of the device identifier."
    id: String!
    "The type of the device identifier. Valid types of identifiers are:ESN (decimal),EID,ICCID (up to 20 digits),IMEI (up to 16 digits),MDN,MEID (hexadecimal),MSISDN."
    kind: String!
}

"A list of deviceId objects to use when requesting information from multiple devices."
input AccountDeviceListInput {
    "All identifiers for the device."
    deviceIds: [DeviceIdInput!]
    ipAddress: String!
}

"The customer address for the line's primary place of use, for line usage taxation."
input AddressInput {
    "The street address for the line's primary place of use. This must be a physical address for taxation; it cannot be a P.O. box."
    addressLine1: String!
    "Optional additional street address information."
    addressLine2: String!
    "The city for the line's primary place of use."
    city: String!
    "The state for the line's primary place of use."
    state: String!
    "The ZIP code for the line's primary place of use."
    zip: String!
    "The ZIP+4 for the line's primary place of use."
    zip4: String!
    "Either “US” or “USA” for the country of the line's primary place of use."
    country: String!
    "A phone number where the customer can be reached."
    phone: String!
    "A single letter to indicate the customer phone type."
    phoneType: String!
    "An email address for the customer."
    emailAddress: String!
}

"The customer name to be used for line usage taxation."
input CustomerNameInput {
    "An optional title for the customer, such as “Mr.” or “Dr.”"
    title: String!
    "The customer's first name."
    firstName: String!
    "The customer's middle name."
    middleName: String!
    "The customer's last name."
    lastName: String!
    "An optional suffix for the customer name, such as “Jr.” or “III.”"
    suffix: String!
}

"The customer name and the address of the device's primary place of use. Leave these fields empty to use the account profile address as the primary place of use. These values will be applied to all devices in the request.If the account is enabled for non-geographic MDNs and the device supports it, the primaryPlaceOfUse address will also be used to derive the MDN for the device."
input PlaceOfUseInput {
    "The customer address for the line's primary place of use, for line usage taxation."
    address: AddressInput!
    "The customer name to be used for line usage taxation."
    customerName: CustomerNameInput!
}

"Request for carrier activation."
input CarrierActivateRequestInput {
    "The name of a billing account."
    accountName: String!
    "The private IP pool (Carrier Group Name) from which your device IP addresses will be derived."
    carrierIpPoolName: String!
    "The carrier that will perform the activation."
    carrierName: String!
    "A string to identify the cost center that the device is associated with."
    costCenterCode: String!
    "A user-defined descriptive field, limited to 50 characters."
    customFields: [CustomFieldsInput!]
    "Up to 10,000 devices for which you want to activate service, specified by device identifier."
    devices: [AccountDeviceListInput!]
    "If you specify devices by ID in the devices parameters, this is the name of a device group that the devices should be added to.If you don't specify individual devices with the devices parameter, you can provide the name of a device group to activate all devices in that group."
    groupName: String!
    "The ID of a “Qualified” or “Closed - Won” VPP customer lead, which is used with other values to determine MDN assignment, taxation, and compensation."
    leadId: String!
    "The Zip code of the location where the line of service will primarily be used, or a Zip code that you have been told to use with these devices. For accounts that are configured for geographic numbering, this is the ZIP code from which the MDN will be derived."
    mdnZipCode: String!
    "The customer name and the address of the device's primary place of use. Leave these fields empty to use the account profile address as the primary place of use. These values will be applied to all devices in the request.If the account is enabled for non-geographic MDNs and the device supports it, the primaryPlaceOfUse address will also be used to derive the MDN for the device."
    primaryPlaceOfUse: PlaceOfUseInput!
    "For devices with static IP addresses on the public network, this specifies whether the devices have general access to the Internet."
    publicIpRestriction: String!
    "The service plan code that you want to assign to all specified devices."
    servicePlan: String!
    "The Stock Keeping Unit (SKU) of a 4G device type can be used with ICCID device identifiers in lieu of an IMEI when activating 4G devices. The SkuNumber will be used with all devices in the request, so all devices must be of the same type."
    skuNumber: String!
}

input CreateActivateservicefordevicesInput {
    contentType: String!
    "Request for activating a service on devices."
    body: CarrierActivateRequestInput!
}

"Request to add the devices."
input AddDevicesRequestInput {
    "The billing account to which the devices are added."
    accountName: String!
    "The names and values for any custom fields that you want set for the devices as they are added to the account."
    customFields: [CustomFieldsInput!]
    "The devices that you want to add."
    devicesToAdd: [AccountDeviceListInput!]
    "The name of a device group to add the devices to. They are added to the default device group if you don't include this parameter."
    groupName: String!
    "The Stock Keeping Unit (SKU) number of a 4G device type with an embedded SIM."
    skuNumber: String!
    "The initial service state for the devices. The only valid state is “Preactive.”"
    state: String!
    smsrOid: String!
}

input AddDevicesInput {
    contentType: String!
    "Devices to add."
    body: AddDevicesRequestInput!
}

"Request to update contact information."
input ContactInfoUpdateRequestInput {
    "The name of the billing account that the devices belong to. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "A list of the devices that you want to change, specified by device identifier. You only need to provide one identifier per device. Do not include accountName, groupName, customFields, or servicePlan if you use this parameter."
    devices: [AccountDeviceListInput!]
    "The customer name and the address of the device's primary place of use. These values are applied to all devices in the request.The Primary Place of Use location may affect taxation or have other legal implications. You may want to speak with legal and/or financial advisers before entering values for these fields."
    primaryPlaceOfUse: String!
}

input UpdateDevicesContactInformationInput {
    contentType: String!
    "Request to update contact information for devices."
    body: ContactInfoUpdateRequestInput!
}

"Request to assign or change custom field values for one or more devices."
input CustomFieldsUpdateRequestInput {
    "The name of a billing account.This parameter is only required if the UWS account used for the current API session has access to multiple billing accounts.An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFieldsInput!]
    "The names and new values of any custom fields that you want to change."
    customFieldsToUpdate: [CustomFieldsInput!]
    "The devices that you want to change."
    devices: [AccountDeviceListInput!]
    "The name of a device group, if you want to only include devices in that group."
    groupName: String!
    "The name of a service plan, if you want to only include devices that have that service plan."
    servicePlan: String!
}

input UpdateDevicesCustomFieldsInput {
    contentType: String!
    "Request to update custom field of devices."
    body: CustomFieldsUpdateRequestInput!
}

"Request to deactivate a carrier."
input CarrierDeactivateRequestInput {
    "The name of a billing account."
    accountName: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFieldsInput!]
    "The devices for which you want to deactivate service, specified by device identifier."
    devices: [AccountDeviceListInput!]
    "Fees may be assessed for deactivating Verizon Wireless devices, depending on the account contract. The etfWaiver parameter waives the Early Termination Fee (ETF), if applicable."
    etfWaiver: Boolean!
    "The name of a device group, if you want to deactivate all devices in that group."
    groupName: String!
    "Code identifying the reason for the deactivation. Currently the only valid reason code is “FF”, which corresponds to General Admin/Maintenance."
    reasonCode: String!
    "The name of a service plan, if you want to only include devices that have that service plan."
    servicePlan: String!
    deleteAfterDeactivation: Boolean!
}

input CreateDeactivateservicefordevicesInput {
    contentType: String!
    "Request to deactivate service for one or more devices."
    body: CarrierDeactivateRequestInput!
}

"Request to delete a device request."
input DeleteDevicesRequestInput {
    "The Verizon billing account that the device group belongs to. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "A list of up to 100 devices that you want to delete, specified by device identifier. You only need to provide one identifier per device."
    devicesToDelete: [AccountDeviceListInput!]
}

input CreateDeletedeactivateddevicesInput {
    contentType: String!
    "Devices to delete."
    body: DeleteDevicesRequestInput!
}

"Search by device id."
input DeviceIdSearchInput {
    "The string appears anywhere in the identifer."
    contains: String!
    "The identifer must start with the specified string."
    startswith: String!
    "The identifier must end with the specified string."
    endswith: String!
    "The type of the device identifier. Valid types of identifiers are:ESN (decimal),EID,ICCID (up to 20 digits),IMEI (up to 16 digits),MDN,MEID (hexadecimal),MSISDN."
    kind: String!
}

"Filter for a list of devices."
input AccountDeviceListFilterInput {
    "Specify the kind of the device identifier, the type of match, and the string that you want to match."
    deviceIdentifierFilters: [DeviceIdSearchInput!]
}

"Request for listing account devices."
input AccountDeviceListRequestInput {
    "The billing account for which a list of devices is returned. If you don't specify an accountName, the list includes all devices to which you have access."
    accountName: String!
    "An identifier for a single device."
    deviceId: DeviceIdInput!
    "Filter for a list of devices."
    filter: AccountDeviceListFilterInput!
    "The name of a device state, to only include devices in that state."
    currentState: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFieldsInput!]
    "Only include devices that were added after this date and time."
    earliest: String!
    "Only include devices that are in this device group."
    groupName: String!
    "Only include devices that were added before this date and time."
    latest: String!
    "Only include devices that have this service plan."
    servicePlan: String!
    maxNumberOfDevices: Int!
    largestDeviceIdSeen: Int!
}

input CreateListdevicesinformationInput {
    contentType: String!
    "Device information query."
    body: AccountDeviceListRequestInput!
}

"Filter out the dates."
input DateFilterInput {
    "Only include devices that were added after this date and time."
    earliest: String!
    "Only include devices that were added before this date and time."
    latest: String!
}

"Request to list of all 4G devices with an ICCID (SIM) that was not activated with the expected IMEI (hardware) during a specified time frame."
input DeviceMismatchListRequestInput {
    "A list of specific devices that you want to check, specified by ICCID or MDN."
    devices: [AccountDeviceListInput!]
    "Filter out the dates."
    filter: DateFilterInput!
    "The account that you want to search for mismatched devices. If you don't specify an accountName, the search includes all devices to which you have access."
    accountName: String!
    "The name of a device group, to only include devices in that group."
    groupName: String!
}

input CreateListdeviceswithimeiiccidmismatchInput {
    contentType: String!
    "Request to list devices with mismatched IMEIs and ICCIDs."
    body: DeviceMismatchListRequestInput!
}

"Specify the kind of the device identifier, the type of match, and the string that you want to match."
input DeviceFilterInput {
    "The the billing account that the devices belong to."
    account: String!
    "Only include devices that are in this device group."
    groupName: String!
    "Only include devices that have this service plan."
    servicePlan: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFieldsInput!]
}

"Request to move active devices from one billing account to another within a customer profile."
input MoveDeviceRequestInput {
    "The name of the billing account that you want to move the devices to."
    accountName: String!
    "Specify the kind of the device identifier, the type of match, and the string that you want to match."
    filter: DeviceFilterInput!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFieldsInput!]
    "Up to 10,000 devices that you want to move to a different account, specified by device identifier."
    devices: [AccountDeviceListInput!]
    "The name of a device group, to only include devices in that group."
    groupName: String!
    "The pool from which device IP addresses will be derived in the new account. If you do not include this element, the default pool will be used."
    carrierIpPoolName: String!
    "The service plan code that you want to assign to the devices in the new account. If you do not include this element, ThingSpace will attempt to use the current service plan, which will result in a error if the new account does not have that service plan."
    servicePlan: String!
}

input UpdateMovedeviceswithinaccountsofprofileInput {
    contentType: String!
    "Request to move devices between accounts."
    body: MoveDeviceRequestInput!
}

"Changes the provisioning state of one or more devices to a specified customer-defined service and state."
input GoToStateRequestInput {
    "Up to 10,000 devices that you want to push to a different state, specified by device identifier."
    devices: [AccountDeviceListInput!]
    "Specify the kind of the device identifier, the type of match, and the string that you want to match."
    filter: DeviceFilterInput!
    "The name of a customer-defined service to push the devices to."
    serviceName: String!
    "The name of a customer-defined stage state to push the devices to."
    stateName: String!
    "The service plan code that you want to assign to all specified devices in the new state."
    servicePlan: String!
    "The Zip code of the location where the line of service will primarily be used, or a Zip code that you have been told to use with these devices. For accounts that are configured for geographic numbering, this is the ZIP code from which the MDN will be derived."
    mdnZipCode: String!
    "The pool from which your device IP addresses will be derived if the service or state change requires new IP addresses.If you do not include this element, the default pool will be used."
    carrierIpPoolName: String!
    "For devices with static IP addresses on the public network, this specifies whether the devices have general access to the Internet. Valid values are “restricted” or “unrestricted”."
    publicIpRestriction: String!
    "The Stock Keeping Unit (SKU) number of a 4G device type with an embedded SIM. Can be used with ICCID or EID device identifiers in lieu of an IMEI when activating 4G devices. The SkuNumber will be used with all devices in the request, so all devices must be of the same type."
    skuNumber: String!
    "The names and values of any custom fields that you want to set for the devices."
    customFields: [CustomFieldsInput!]
    "The name of a device group that the devices should be added to."
    groupName: String!
    "The customer name and the address of the device's primary place of use. Leave these fields empty to use the account profile address as the primary place of use. These values will be applied to all devices in the request.If the account is enabled for non-geographic MDNs and the device supports it, the primaryPlaceOfUse address will also be used to derive the MDN for the device."
    primaryPlaceOfUse: PlaceOfUseInput!
}

input UpdateDevicesStateInput {
    contentType: String!
    "Request to change device state to one defined by the user."
    body: GoToStateRequestInput!
}

"Request to update service plan."
input ServicePlanUpdateRequestInput {
    "The name of a billing account."
    accountName: String!
    "The name of a service plan, if you want to only include devices that have that service plan."
    currentServicePlan: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFieldsInput!]
    "A list of the devices that you want to change, specified by device identifier."
    devices: [AccountDeviceListInput!]
    "The name of a device group, if you want to restore service for all devices in that group."
    groupName: String!
    "The service plan code that you want to assign to all specified devices."
    servicePlan: String!
    carrierIpPoolName: String!
    takeEffect: String!
}

input ChangeDevicesServicePlanInput {
    contentType: String!
    "Request to change device service plan."
    body: ServicePlanUpdateRequestInput!
}

"Request for a carrier action."
input CarrierActionsRequestInput {
    "The name of a billing account."
    accountName: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFieldsInput!]
    "The devices for which you want to restore service, specified by device identifier."
    devices: [AccountDeviceListInput!]
    "The name of a device group, if you want to restore service for all devices in that group."
    groupName: String!
    "The name of a service plan, if you want to only include devices that have that service plan."
    servicePlan: String!
}

input CreateSuspendservicefordevicesInput {
    contentType: String!
    "Request to suspend service for one or more devices."
    body: CarrierActionsRequestInput!
}

input CreateRestoreserviceforsuspendeddevicesInput {
    contentType: String!
    "Request to restore services of one or more suspended devices."
    body: CarrierActionsRequestInput!
}

"Request for device status to check availability of activation."
input DeviceActivationRequestInput {
    "The name of a billing account."
    accountName: String!
    "Up to 10,000 devices that you want to move to a different account, specified by device identifier."
    devices: [AccountDeviceListInput!]
}

input CreateCheckdevicesavailabilityforactivationInput {
    contentType: String!
    "Request to check if devices can be activated or not."
    body: DeviceActivationRequestInput!
}

"Request to list of network connection events for a device during a specified time period."
input DeviceConnectionListRequestInput {
    "An identifier for a single device."
    deviceId: DeviceIdInput!
    "The earliest date and time for which you want connection events."
    earliest: String!
    "The last date and time for which you want connection events."
    latest: String!
}

input CreateRetrievedeviceconnectionhistoryInput {
    contentType: String!
    "Query to retrieve device connection history."
    body: DeviceConnectionListRequestInput!
}

"Request to retrieve cost center value of a device."
input DeviceCostCenterRequestInput {
    "The name of a billing account."
    accountName: String!
    "The new cost center code. Valid values are any string of up to 36 alphanumeric characters, space, dash, exclamation point, and pound sign."
    costCenter: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFieldsInput!]
    "A list of the devices that you want to change, specified by device identifier. Do not include accountName, groupName, customFields, or servicePlan if you use this parameter."
    devices: [AccountDeviceListInput!]
    "The name of a device group, if you want to only include devices in that group."
    groupName: String!
    "The customer name and the address of the device's primary place of use. These values are applied to all devices in the request.The Primary Place of Use location may affect taxation or have other legal implications. You may want to speak with legal and/or financial advisers before entering values for these fields."
    primaryPlaceOfUse: String!
    "Set to true to remove the cost center code value. This flag takes precedence over a new costCenter value. If this flag is true and costCenter has a value, the cost center code is removed. Do not include this parameter, or set it to false to change the costCenter value."
    removeCostCenter: Boolean!
    "The name of a service plan, if you want to only include devices that have that service plan."
    servicePlan: String!
}

input UpdateDevicesCostCenterCodeInput {
    contentType: String!
    "Request to update cost center code value for one or more devices."
    body: DeviceCostCenterRequestInput!
}

"Request for obtaining device extended diagnostics."
input DeviceExtendedDiagnosticsRequestInput {
    "The Verizon billing account that the device belongs to. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "The device for which you want diagnostic information, specified by the device's MDN."
    deviceList: [DeviceIdInput!]
}

input CreateGetdeviceextendeddiagnosticinformationInput {
    contentType: String!
    "Request to query extended diagnostics information for a device."
    body: DeviceExtendedDiagnosticsRequestInput!
}

"Request to return the provisioning history of a specified device during a specified time period."
input DeviceProvisioningHistoryListRequestInput {
    "An identifier for a single device."
    deviceId: DeviceIdInput!
    "The earliest date and time for which you want provisioning data."
    earliest: String!
    "The last date and time for which you want provisioning data."
    latest: String!
}

input CreateListdevicesprovisioninghistoryInput {
    contentType: String!
    "Query to obtain device provisioning history."
    body: DeviceProvisioningHistoryListRequestInput!
}

"Requests the current PRL (Preferred Roaming List) version for 2G or 3G devices, which can help determine which devices need a PRL update. (4G and GSM devices do not have a PRL.)."
input DevicePrlListRequestInput {
    "The devices for which you want the PRL version, specified by device identifier. You only need to provide one identifier per device. Do not use any of the other parameters if you specify device IDs."
    deviceIds: [DeviceIdInput!]
    "The name of a billing account. This parameter is only required if you are passing groupName and the UWS account used for the current API session has access to multiple billing accounts, because the same device group name can exist in multiple accounts.An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "The names and values of custom fields, if you want to only include devices that have matching custom fields."
    customFields: [CustomFieldsInput!]
    "The name of a device group, if you want to only include devices in that group."
    groupName: String!
    "The name of a service plan, if you want to only include devices that have that service plan."
    servicePlan: String!
}

input CreateListcurrentdevicesprlversionInput {
    contentType: String!
    "Request to query device PRL."
    body: DevicePrlListRequestInput!
}

"Filter for devices without account."
input DeviceFilterWithoutAccountInput {
    "Only include devices that are in this device group."
    groupName: String!
    "Only include devices that have this service plan."
    servicePlan: String!
    "Custom field names and values, if you want to only include devices that have matching values."
    customFields: [CustomFieldsInput!]
}

"Request to return service suspension information about one or more devices."
input DeviceSuspensionStatusRequestInput {
    "The devices that you want to include in the request, specified by device identifier. You only need to provide one identifier per device."
    deviceIds: [DeviceIdInput!]
    "Filter for devices without account."
    filter: DeviceFilterWithoutAccountInput!
    "The name of a billing account."
    accountName: String!
}

input CreateGetdeviceservicesuspensionstatusInput {
    contentType: String!
    "Request to obtain service suspenstion status for a device."
    body: DeviceSuspensionStatusRequestInput!
}

input LabelInput {
    name: String!
    value: String!
}

"Request to return the daily network data usage of a single device during a specified time period."
input DeviceUsageListRequestInput {
    "An identifier for a single device."
    deviceId: DeviceIdInput!
    "The earliest date for which you want usage data."
    earliest: String!
    "The last date for which you want usage data."
    latest: String!
    label: LabelInput!
}

input CreateListdevicesusagehistoryInput {
    contentType: String!
    "Request to obtain usage history for a specific device."
    body: DeviceUsageListRequestInput!
}

"Request to list device aggregate usage."
input DeviceAggregateUsageListRequestInput {
    "One or more devices for which you want aggregate data, specified by device ID."
    deviceIds: [DeviceIdInput!]
    "The name of a billing account."
    accountName: String!
    "The name of a device group, if you want to only include devices in that group."
    groupName: String!
    "The beginning of the reporting period. The startTime cannot be more than 6 months before the current date."
    startTime: String!
    "The end of the reporting period. The endTime date must be within on month of the startTime date."
    endTime: String!
    label: [LabelInput!]
}

input CreateRetrieveaggregatedeviceusagehistoryInput {
    contentType: String!
    "A request to retrieve aggregated device usage history information."
    body: DeviceAggregateUsageListRequestInput!
}

"Changes the identifier of a 3G or 4G device to match hardware changes made for a line of service. Use this request to transfer the line of service and the MDN to new hardware, or to change the MDN."
input ChangeDeviceIdRequestInput {
    "Set to true to assign a non-Geo MDN and MSISDN, or false to assign an MDN and MSISDN from a specific NPA-NXX."
    assignNonGeoMdn: Boolean!
    "The type of change that you want to make for a 4G device."
    change4gOption: String!
    "The device that you want to change, specified by a device identifier."
    deviceIds: [DeviceIdInput!]
    "The new identifier for the device. Required for all change4GOptions except ChangeMSISDN."
    deviceIdsTo: [DeviceIdInput!]
    "The NPA NXX (area code and prefix) from which the MDN and MSISDN will be derived when assignNonGeoMDN is false. Specify the 6-digit NPA NXX of the location where the line of service will primarily be used. This API checks to see if a number starting with the NPA NXX is available. If not, this API uses the zipCode parameter, if specified, to assign a number in the area of the line of service. This parameter is required when you change an MDN/MSISDN for a B2B carrier, such as Verizon Wireless."
    npaNxx: String!
    "The code for a different service plan, if you want to change the service plan while changing the device identifier. Set this parameter to one of the Code values returned by GET /plans."
    servicePlan: String!
    "The ZIP code from which the MDN and MSISDN will be derived when assignNonGeoMDN is true. Specify the zip code of the location where the line of service will primarily be used."
    zipCode: String!
    smsrOid: String!
}

input UpdateDeviceIdInput {
    "Identifier type."
    serviceType: String!
    contentType: String!
    "Request to update device id."
    body: ChangeDeviceIdRequestInput!
}

input DeviceListInput {
    deviceIds: [DeviceIdInput!]
}

input DeviceUploadRequestInput {
    accountName: String!
    devices: [DeviceListInput!]
    emailAddress: String!
    deviceSku: String!
    uploadType: String!
}

input CreateDeviceuploadInput {
    contentType: String!
    "Device Upload Query"
    body: DeviceUploadRequestInput!
}

"A label for a single device."
input DeviceLabelsInput {
    "The label you want to associate with the device."
    name: String!
    "The value of label"
    value: String!
}

input LabelsListInput {
    deviceIds: [DeviceLabelsInput!]
}

input BillingCycleInput {
    year: String!
    month: String!
}

"Information required to associate a usage segmentation label with a device to retrieve billing."
input BilledusageListRequestInput {
    accountName: String!
    labels: LabelsListInput!
    deviceIds: [DeviceListInput!]
    billingCycle: BillingCycleInput!
}

input CreateBilledusageinfoInput {
    contentType: String!
    "Request to list devices with mismatched IMEIs and ICCIDs."
    body: BilledusageListRequestInput!
}

"Maximum of 2,000 objects are allowed in the array."
input AccountLabelsInput {
    devices: [DeviceListInput!]
    label: [DeviceLabelsInput!]
}

input AssociateLabelRequestInput {
    "The name of a billing account. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "Maximum of 2,000 objects are allowed in the array."
    labels: AccountLabelsInput!
}

input CreateUsagesegmentationlabelassociationInput {
    contentType: String!
    "Request to associate a label to a device."
    body: AssociateLabelRequestInput!
}

input DeleteUsagesegmentationlabeldeletionInput {
    "The numeric name of the account."
    accountName: String!
    "A list of the Label IDs to remove from the exclusion list."
    labelList: LabelsListInput!
}

"The request body identifies the devices to upload."
input UploadsActivatesDeviceRequestInput {
    "The name of a billing account. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "The email address that the report should be sent to when the upload is complete."
    emailAddress: String!
    "The stock keeping unit that identifies the type of devices in the upload and activation."
    deviceSku: String!
    "The format of the device identifiers in the upload and activation."
    uploadType: String!
    "The service plan code that you want to assign to all specified devices."
    servicePlan: String!
    "The pool from which your device IP addresses is derived."
    carrierIpPoolName: String!
    "The Zip code of the location where the line of service is primarily used, or a Zip code that you have been told to use with these devices."
    mdnZipCode: String!
    "The devices to upload, specified by device IDs in a format matching uploadType."
    devices: [DeviceListInput!]
}

input CreateActivationorderstatusInput {
    contentType: String!
    "Request to Uploads and activates device."
    body: UploadsActivatesDeviceRequestInput!
}

"The request body identifies the devices to upload."
input CheckOrderStatusRequestInput {
    "The name of a billing account. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "The request id from the activation order."
    orderRequestId: String!
    "The devices to upload, specified by device IDs in a format matching uploadType."
    devices: [DeviceListInput!]
}

input UploadDeviceIdentifierInput {
    contentType: String!
    "The request body identifies the device and reporting period that you want included in the report."
    body: CheckOrderStatusRequestInput!
}

input GetAccountInformationInput {
    "Account name."
    aname: String!
}

input ListAccountStatesAndServicesInput {
    "Account name."
    aname: String!
}

input ListAccountLeadsInput {
    "Account name."
    aname: String!
    "Continue the previous query from the pageUrl in Location Header."
    next: Int!
}

"Create request for a new device group and optionally add devices to the group."
input CreateDeviceGroupRequestInput {
    "The Verizon billing account that the device group will belong to. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "Zero or more devices to add to the device group. You can use POST /devices/actions/list to get a list of all devices in the account."
    devicesToAdd: [DeviceIdInput!]
    "A description for the device group."
    groupDescription: String!
    "The name for the new device group. This name must be unique within the specified account."
    groupName: String!
}

input CreateDeviceGroupInput {
    contentType: String!
    "A request to create a new device group."
    body: CreateDeviceGroupRequestInput!
}

input ListDeviceGroupsInput {
    "Account name."
    aname: String!
}

input GetDeviceGroupInformationInput {
    "Account name."
    aname: String!
    "Group name."
    gname: String!
    "Continue the previous query from the pageUrl pagetoken."
    next: Int!
}

"Make changes to a device group, including changing the name and description, and adding or removing devices."
input DeviceGroupUpdateRequestInput {
    "Zero or more devices to add to the device group, specified by device ID. The devices will be removed from their current device groups. You can use POST /devices/actions/list to get a list of all devices in the account."
    devicesToAdd: [DeviceIdInput!]
    "Zero or more devices to remove from the device group, specified by device ID. The devices will be added to the default device group."
    devicesToRemove: [DeviceIdInput!]
    "A new description for the device group. Do not include this parameter to leave the group description unchanged."
    newGroupDescription: String!
    "A new name for the device group. Do not include this parameter if you want to leave the group name unchanged."
    newGroupName: String!
}

input UpdateDeviceGroupInput {
    "Account name."
    aname: String!
    "Group name."
    gname: String!
    contentType: String!
    "Request to update device group."
    body: DeviceGroupUpdateRequestInput!
}

input DeleteDeviceGroupInput {
    "Account name."
    aname: String!
    "Group name."
    gname: String!
}

"Request to send SMS."
input SMSSendRequestInput {
    "The name of a billing account."
    accountName: String!
    "The names and values of custom fields, if you want to only include devices that have matching custom fields."
    customFields: [CustomFieldsInput!]
    "The SMS message encoding, which can be 7-bit (default), 8-bit-ASCII, 8-bit-UTF-8, 8-bit-DATA."
    dataEncoding: String!
    "The devices that you want to send the message to, specified by device identifier."
    deviceIds: [DeviceIdInput!]
    "The name of a device group, if you want to send the SMS message to all devices in the device group."
    groupName: String!
    "The name of a service plan, if you want to only include devices that have that service plan."
    servicePlan: String!
    "The contents of the SMS message. The SMS message is limited to 160 characters in 7-bit format, or 140 characters in 8-bit format."
    smsMessage: String!
}

input CreateSendsmstodeviceInput {
    contentType: String!
    "Request to send SMS."
    body: SMSSendRequestInput!
}

input ListDevicesSMSMessagesInput {
    "Account name."
    aname: String!
    "Continue the previous query from the URL in Location Header."
    next: Int!
}

input UpdateStartqueuedsmsdeliveryInput {
    "Account name."
    aname: String!
}

"Request to initiate a Connectivity Management session and returns a VZ-M2M session token that is required in subsequent API requests."
input LogInRequestInput {
    "The username for authentication."
    username: String!
    "The password for authentication."
    password: String!
}

input CreateStartconnectivitymanagementsessionInput {
    contentType: String!
    "Request to initiate a session."
    body: LogInRequestInput!
}

"Request to a new, randomly generated password for the current username."
input SessionResetPasswordRequestInput {
    "The current password for the username."
    oldPassword: String!
}

input UpdateResetconnectivitymanagementpasswordInput {
    contentType: String!
    "Request with current password that needs to be reset."
    body: SessionResetPasswordRequestInput!
}

input ListRegisteredCallbacksInput {
    "Account name."
    aname: String!
}

"Request to register a callback."
input RegisterCallbackRequestInput {
    "The name of the callback service that you want to subscribe to."
    name: String!
    "The address on your server where you have enabled a listening service for callback messages."
    url: String!
    "The user name that the M2M Platform should return in the callback messages."
    username: String!
    "The password that the M2M Platform should return in the callback messages."
    password: String!
}

input CreateRegistercallbackInput {
    "Account name."
    aname: String!
    contentType: String!
    "Request to register a callback."
    body: RegisterCallbackRequestInput!
}

input DeleteDeregistercallbackInput {
    "Account name."
    aname: String!
    "Service name."
    sname: String!
}

input GetCurrentAsynchronousRequestStatusInput {
    "Account name."
    aname: String!
    "UUID from synchronous response."
    requestId: String!
}

input ListAccountServicePlansInput {
    "Account name."
    aname: String!
}

input NotificationReportStatusRequestInput {
    "The name of a billing account."
    accountName: String!
    "An identifier for a single device."
    device: DeviceIdInput!
    "The time at which the request expires."
    requestExpirationTime: String!
    "The type of request."
    requestType: String!
}

input CreateDevicereachabilitystatususingpostInput {
    contentType: String!
    "Retrieve Reachability Report Status for a device."
    body: NotificationReportStatusRequestInput!
}

input RetrieveMonitorsRequestInput {
    "The name of a billing account."
    accountName: String!
    "The devices for which you want to restore service, specified by device identifier."
    devices: [AccountDeviceListInput!]
    "The name of a billing account."
    monitorType: String!
}

input CreateRetrieveactivemonitorsusingpostInput {
    contentType: String!
    "Retrieve Monitor Request."
    body: RetrieveMonitorsRequestInput!
}

input ActivateDeviceProfileRequestInput {
    devices: [DeviceListInput!]
    accountName: String!
    servicePlan: String!
    mdnZipCode: String!
}

input CreateActivatedevicethroughprofileInput {
    contentType: String!
    "Device Profile Query"
    body: ActivateDeviceProfileRequestInput!
}

input PrimaryPlaceOfUseInput {
    customerName: [CustomerNameInput!]
    address: [AddressInput!]
}

input ProfileRequestInput {
    devices: [DeviceListInput!]
    carrierName: String!
    accountName: String!
    servicePlan: String!
    mdnZipCode: String!
    primaryPlaceOfUse: [PrimaryPlaceOfUseInput!]
    smsrOid: String!
    "The name of the pool of IP addresses assigned to the profile."
    carrierIpPoolName: String!
}

input CreateProfiletoactivatedeviceInput {
    contentType: String!
    "Device Profile Query"
    body: ProfileRequestInput!
}

input IdInput {
    "The value of the device identifier."
    id: String!
    "The type of the device identifier. Valid types of identifiers are:ESN (decimal),EID,ICCID (up to 20 digits),IMEI (up to 16 digits),MDN,MEID (hexadecimal),MSISDN."
    kind: String!
}

input DeactivateDeviceListInput {
    ids: [IdInput!]
}

input DeactivateDeviceProfileRequestInput {
    devices: [DeactivateDeviceListInput!]
    accountName: String!
    carrierName: String!
    reasonCode: String!
    etfWaiver: Boolean!
    checkFallbackProfile: Boolean!
}

input CreateProfiletodeactivatedeviceInput {
    contentType: String!
    "Device Profile Query"
    body: DeactivateDeviceProfileRequestInput!
}

input SetFallbackAttributeRequestInput {
    devices: [DeviceListInput!]
    accountName: String!
    carrierName: String!
}

input CreateProfiletosetfallbackattributeInput {
    contentType: String!
    "Device Profile Query"
    body: SetFallbackAttributeRequestInput!
}

input NotificationReportRequestInput {
    accountName: String!
    requestType: String!
    devices: [DeviceListInput!]
    monitorExpirationTime: String!
}

input CreateDevicereachabilityInput {
    contentType: String!
    "Create Reachability Report Request"
    body: NotificationReportRequestInput!
}

input DeleteStopdevicereachabilityInput {
    "The numeric name of the account."
    accountName: String!
    "The array contains the monitorIDs (UUID) for which the monitor is to be deleted."
    monitorIds: [String!]
}

input ProfileChangeStateRequestInput {
    devices: [DeviceListInput!]
    accountName: String!
    smsrOid: String!
}

input CreateDownloadlocalprofiletoenableInput {
    contentType: String!
    "Device Profile Query"
    body: ProfileChangeStateRequestInput!
}

input CreateDownloadlocalprofiletodisableInput {
    contentType: String!
    "Device Profile Query"
    body: ProfileChangeStateRequestInput!
}

input CreateEnablelocalprofileInput {
    contentType: String!
    "Update state"
    body: ProfileChangeStateRequestInput!
}

input CreateDisablelocalprofileInput {
    contentType: String!
    "Update state"
    body: ProfileChangeStateRequestInput!
}

input CreateDeletelocalprofileInput {
    contentType: String!
    "Update state"
    body: ProfileChangeStateRequestInput!
}

"The devices that you want to locate. The array cannot contain more than 20 devices."
input DeviceInfoInput {
    "Device identifier."
    id: String!
    "Device identifier kind."
    kind: String!
    "Device MDN."
    mdn: String!
}

"The body contains the the account name and list of devices that you want to locate, plus other options."
input LocationRequestInput {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "Accurary, currently only 0-coarse supported."
    accuracyMode: AccuracyMode!
    "Location cache mode."
    cacheMode: CacheMode!
    "Device list."
    deviceList: [DeviceInfoInput!]
}

input CreateListdeviceslocationssynchronousInput {
    contentType: String!
    "Request to obtain location of devices."
    body: LocationRequestInput!
}

input CreateListdeviceslocationsasynchronousInput {
    contentType: String!
    "An asynchronous request to obtain locations of devices."
    body: LocationRequestInput!
}

input DeleteCanceldevicelocationrequestInput {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "Transaction ID of the request to cancel, from the synchronous response to the original request."
    txid: String!
}

input CreateLocationReportInput {
    contentType: String!
    "Request for device location report."
    body: LocationRequestInput!
}

input RetrieveLocationReportInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    "Transaction ID from POST /locationreports response."
    txid: String!
    "Zero-based number of the first record to return."
    startindex: Int!
}

input GetLocationReportStatusInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    "Transaction ID of the report."
    txid: String!
}

input DeleteCancelqueuedlocationreportgenerationInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    "Transaction ID of the report to cancel."
    txid: String!
}

input ConsentRequestInput {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "Exclude all devices or not."
    allDevice: Boolean!
    "The change to make: append or replace."
    type: String!
    "Device ID list."
    exclusion: [String!]
}

input CreateExcludedevicesInput {
    contentType: String!
    "Request to update account consent exclusion list."
    body: ConsentRequestInput!
}

input RemoveDevicesFromExclusionListInput {
    "The numeric name of the account."
    accountName: String!
    "A list of the device IDs to remove from the exclusion list."
    deviceList: String!
}

input ListExcludedDevicesInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    "Zero-based number of the first record to return."
    startIndex: String!
}

input GetLocationServiceSubscriptionStatusInput {
    "Account identifier in \"##########-#####\"."
    account: String!
}

"Bill usage request."
input BillUsageRequestInput {
    "Account identifier."
    accountName: String!
    "Start date to search for billable usage, mm-dd-yyyy."
    startDate: String!
    "End date to search for billable usage, mm-dd-yyyy."
    endDate: String!
    "Request usage for single or multiple accounts."
    usageForAllAccounts: Boolean!
}

input CreateGetlocationserviceusageInput {
    contentType: String!
    "Request to obtain billable usage for accounts."
    body: BillUsageRequestInput!
}

input ListRegisteredCallbacks1Input {
    "Account number."
    account: String!
}

input DeviceLocationCallbackInput {
    "The name of the callback service."
    name: CallbackServiceName!
    "The location of your callback listener."
    url: String!
}

input CreateRegistercallback1Input {
    "Account number."
    account: String!
    contentType: String!
    "Request to register a callback."
    body: DeviceLocationCallbackInput!
}

input DeleteDeregistercallback1Input {
    "Account number."
    account: String!
    "Callback service name."
    service: CallbackServiceName!
}

input UsageTriggerAddRequestInput {
    "Usage trigger name"
    triggerName: String!
    "Account name"
    accountName: String!
    "Service name"
    serviceName: ServiceName!
    "The percent of subscribed usage required to activate the trigger, such as 90 or 100."
    thresholdValue: String!
    "Allow additional requests after thresholdValue is reached. (currently not functional)"
    allowExcess: Boolean!
    "Send SMS (text) alerts when the thresholdValue is reached."
    sendSmsNotification: Boolean!
    "Comma-separated list of phone numbers to send SMS alerts to. Digits only; no dashes or parentheses, etc."
    smsPhoneNumbers: String!
    "Send email alerts when the thresholdValue is reached."
    sendEmailNotification: Boolean!
    "Comma-separated list of email addresses to send alerts to."
    emailAddresses: String!
}

input CreateNewTriggerInput {
    contentType: String!
    "License assignment."
    body: UsageTriggerAddRequestInput!
}

input UsageTriggerUpdateRequestInput {
    "Usage trigger name"
    triggerName: String!
    "Account name"
    accountName: String!
    "The percent of subscribed usage required to activate the trigger, such as 90 or 100."
    thresholdValue: String!
    "Comma-separated list of phone numbers to send SMS alerts to. Digits only; no dashes or parentheses, etc."
    smsPhoneNumbers: String!
    "Comma-separated list of email addresses to send alerts to."
    emailAddresses: String!
}

input UpdateTriggerInput {
    "Usage trigger ID"
    triggerId: String!
    contentType: String!
    "New trigger values"
    body: UsageTriggerUpdateRequestInput!
}

input DeleteTriggerInput {
    "Account name"
    accountName: String!
    "Usage trigger ID"
    triggerId: String!
}

input ManagedAccountsAddRequestInput {
    "Account identifier"
    accountName: String!
    "Service name"
    serviceName: ServiceName!
    "SKU name"
    type: String!
    "managed account list"
    managedAccList: [String!]
}

input AddAccountInput {
    contentType: String!
    "Service name and list of accounts to add"
    body: ManagedAccountsAddRequestInput!
}

input ManagedAccountsProvisionRequestInput {
    "Managed account identifier"
    accountName: String!
    "Primary Account identifier"
    paccountName: String!
    "Service name"
    serviceName: ServiceName!
    "SKU name"
    type: String!
    "Transaction identifier returned by add request"
    txid: String!
}

input CreateManagedaccountactionInput {
    contentType: String!
    "Service name and list of accounts to add"
    body: ManagedAccountsProvisionRequestInput!
}

input ManagedAccountCancelRequestInput {
    "Managed account identifier"
    accountName: String!
    "Primary Account identifier"
    paccountName: String!
    "Service name"
    serviceName: ServiceName!
    "SKU name"
    type: String!
    "Transaction identifier returned by provision request"
    txid: String!
}

input CreateCancelmanagedaccountactionInput {
    contentType: String!
    "Service name and list of accounts to add"
    body: ManagedAccountCancelRequestInput!
}

input ListManagedAccountInput {
    "Primary account identifier"
    accountName: String!
    "Service name"
    serviceName: String!
}

input GetAccountSubscriptionStatusInput {
    "Account identifier in \"##########-#####\"."
    account: String!
}

input GetAccountLicenseStatusInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    "The zero-based number of the first record to return. Set startIndex=0 for the first request. If there are more than 1,000 devices in the response, set startIndex=1000 for the second request, 2000 for the third request, etc."
    startIndex: String!
}

"IMEIs of the devices to assign licenses to."
input V1LicensesAssignedRemovedRequestInput {
    "The IMEIs of the devices."
    deviceList: [String!]
}

input CreateAssignlicensestodevicesInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    contentType: String!
    "IMEIs of the devices to assign licenses to."
    body: V1LicensesAssignedRemovedRequestInput!
}

input CreateRemovelicensesfromdevicesInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    contentType: String!
    "IMEIs of the devices to remove licenses from."
    body: V1LicensesAssignedRemovedRequestInput!
}

"List of devices to removes."
input V1ListOfLicensesToRemoveRequestInput {
    "Set to 'append' to append the devices in the current request to the existing list. If there is no existing list then it will be created with only these devices. Leave this parameter out when you want to replace the existing list with the devices in the current request."
    type: String!
    "The IMEIs of the devices."
    deviceList: [String!]
}

input CreateListOfLicensesToRemoveInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    contentType: String!
    "Cancellation candidate device list."
    body: V1ListOfLicensesToRemoveRequestInput!
}

input DeleteListOfLicensesToRemoveInput {
    "Account identifier in \"##########-#####\"."
    account: String!
}

input ListLicensesToRemoveInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    "The zero-based number of the first record to return. Set startIndex=0 for the first request. If there are more than 1,000 devices in the response, set startIndex=1000 for the second request, 2000 for the third request, etc."
    startIndex: String!
}

input ListAvailableFirmwareInput {
    "Account identifier in \"##########-#####\"."
    account: String!
}

"Details of the firmware upgrade request."
input FirmwareUpgradeRequestInput {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "The name of the firmware image that will be used for the upgrade, from a GET /firmware response."
    firmwareName: String!
    "The name of the firmware version that will be on the devices after a successful upgrade."
    firmwareTo: String!
    "The date that the upgrade should begin."
    startDate: String!
    "The IMEIs of the devices."
    deviceList: [String!]
}

input CreateSchedulefirmwareupgradeInput {
    contentType: String!
    "Details of the firmware upgrade request."
    body: FirmwareUpgradeRequestInput!
}

input ListFirmwareUpgradeDetailsInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    "The UUID of the upgrade, returned by POST /upgrades when the upgrade was scheduled."
    upgradeId: String!
}

"List of devices to add or remove."
input FirmwareUpgradeChangeRequestInput {
    "Possible values are `append` or `remove`"
    type: FirmwareTypeList!
    "The IMEIs of the devices."
    deviceList: [String!]
}

input UpdateFirmwareUpgradeDevicesInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    "The UUID of the upgrade, returned by POST /upgrades when the upgrade was scheduled."
    upgradeId: String!
    contentType: String!
    "List of devices to add or remove."
    body: FirmwareUpgradeChangeRequestInput!
}

input DeleteCancelscheduledfirmwareupgradeInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    "The UUID of the scheduled upgrade that you want to cancel."
    upgradeId: String!
}

input ListRegisteredCallbacks2Input {
    "Account identifier in \"##########-#####\"."
    account: String!
}

"Callback endpoint information."
input FotaV1CallbackRegistrationRequestInput {
    "The name of the callback service that you want to subscribe to, which must be 'Fota' for Software Management Services callbacks."
    name: String!
    "The address on your server where you have enabled a listening service for Software Management Services callback messages."
    url: String!
    "The user name that ThingSpace should return in the callback messages."
    username: String!
    "The password that ThingSpace should return in the callback messages."
    password: String!
}

input CreateRegistercallback2Input {
    "Account identifier in \"##########-#####\"."
    account: String!
    contentType: String!
    "Callback details."
    body: FotaV1CallbackRegistrationRequestInput!
}

input DeleteDeregistercallback2Input {
    "Account identifier in \"##########-#####\"."
    account: String!
    "Callback type. Must be 'Fota' for Software Management Services API."
    service: CallbackService!
}

input ListAccountDevicesInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    "Only return devices with IMEIs larger than this value. Use 0 for the first request. If `hasMoreData`=true in the response, use the `lastSeenDeviceId` value from the response as the startIndex in the next request."
    startIndex: String!
}

input ListUpgradesForSpecifiedStatusInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    "The status of the upgrades that you want to retrieve."
    upgradeStatus: UpgradeStatus!
    "The zero-based number of the first record to return. Set startIndex=0 for the first request. If `hasMoreFlag`=true in the response, use the `lastSeenUpgradeId` value from the response as the startIndex in the next request."
    startIndex: String!
}

input GetDeviceFirmwareUpgradeHistoryInput {
    "Account identifier in \"##########-#####\"."
    account: String!
    "The IMEI of the device."
    deviceId: String!
}

input GetAccountSubscriptionStatus1Input {
    "Account identifier."
    account: String!
}

input GetAccountLicenseStatus1Input {
    "Account identifier."
    account: String!
    "Last seen device identifier."
    lastSeenDeviceId: String!
}

"IMEIs of the devices to assign or remove licenses."
input V2LicenseIMEIInput {
    "Account name."
    accountName: String!
    "Device IMEI list."
    deviceList: [String!]
}

input CreateAssignlicensestodevices1Input {
    "Account identifier."
    account: String!
    contentType: String!
    "License assignment."
    body: V2LicenseIMEIInput!
}

input CreateRemovelicensesfromdevices1Input {
    "Account identifier."
    account: String!
    contentType: String!
    "License removal."
    body: V2LicenseIMEIInput!
}

input ListLicensesToRemove1Input {
    "Account identifier."
    account: String!
    "Start index to retrieve."
    startIndex: String!
}

"License cancellation candidate devices."
input V2ListOfLicensesToRemoveRequestInput {
    "List creation option."
    type: String!
    "The number of devices."
    count: Int!
    "Device IMEI list."
    deviceList: [String!]
}

input CreateListOfLicensesToRemove1Input {
    "Account identifier."
    account: String!
    contentType: String!
    "List of licensess to remove."
    body: V2ListOfLicensesToRemoveRequestInput!
}

input DeleteListOfLicensesToRemove1Input {
    "Account identifier."
    account: String!
}

"Allowed start and end time windows."
input V2TimeWindowInput {
    "Start hour in range [0..23], current hour >= startTime."
    startTime: Int!
    "End hour in range [1..24], current hour < endTime."
    endTime: Int!
}

"Software upgrade information."
input CampaignSoftwareUpgradeInput {
    "Campaign name."
    campaignName: String!
    "Software name to upgrade to."
    softwareName: String!
    "Old software name."
    softwareFrom: String!
    "New software name."
    softwareTo: String!
    "OMA or HTTP."
    distributionType: String!
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "Specifies starting date client should download package. If null, client will download as soon as possible."
    downloadAfterDate: String!
    "List of allowed download time windows."
    downloadTimeWindowList: [V2TimeWindowInput!]
    "Client will install package after date. If null, client will install as soon as possible."
    installAfterDate: String!
    "List of allowed install time windows."
    installTimeWindowList: [V2TimeWindowInput!]
    "Device IMEI list."
    deviceList: [String!]
}

input CreateSchedulecampaignfirmwareupgradeInput {
    "Account identifier."
    account: String!
    contentType: String!
    "Software upgrade information."
    body: CampaignSoftwareUpgradeInput!
}

input GetCampaignInformationInput {
    "Account identifier."
    account: String!
    "Software upgrade identifier."
    campaignId: String!
}

"Add or remove device to existing software upgrade information."
input V2AddOrRemoveDeviceRequestInput {
    "Operation either 'append' or 'remove'."
    type: String!
    "Device IMEI list."
    deviceList: [String!]
}

input UpdateCampaignFirmwareDevicesInput {
    "Account identifier."
    account: String!
    "Software upgrade information."
    campaignId: String!
    contentType: String!
    "Request to add or remove device to existing software upgrade information."
    body: V2AddOrRemoveDeviceRequestInput!
}

input DeleteCancelcampaignInput {
    "Account identifier."
    account: String!
    "Unique identifier of campaign."
    campaignId: String!
}

"New dates and time windows."
input V2ChangeCampaignDatesRequestInput {
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "Specifies starting date client should download package. If null, client will download as soon as possible."
    downloadAfterDate: String!
    "List of allowed download time windows. Removing of existing windows is not allowed."
    downloadTimeWindowList: [V2TimeWindowInput!]
    "Client will install package after date. If null, client will install as soon as possible."
    installAfterDate: String!
    "List of allowed install time windows. Removing of existing windows is not allowed."
    installTimeWindowList: [V2TimeWindowInput!]
}

input UpdateCampaignDatesInput {
    "Account identifier."
    account: String!
    "Software upgrade information."
    campaignId: String!
    contentType: String!
    "New dates and time windows."
    body: V2ChangeCampaignDatesRequestInput!
}

input DownloadTimeWindowInput {
    "Device IMEI list."
    startTime: String!
    "Device IMEI list."
    endTime: String!
}

input UploadAndScheduleFileRequestInput {
    "The campaign name."
    campaignName: String!
    "The name of the file you are upgrading to."
    fileName: String!
    "The version of the file you are upgrading to."
    fileVersion: String!
    "Valid values"
    distributionType: String!
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "Specifies the starting date the client should download the package. If null, client downloads as soon as possible."
    downloadAfterDate: String!
    "List of allowed download time windows."
    downloadTimeWindowList: [DownloadTimeWindowInput!]
    "The date after which you install the package. If null, install as soon as possible."
    installAfterDate: String!
    "List of allowed install time windows."
    installTimeWindowList: [DownloadTimeWindowInput!]
    "Device IMEI list."
    deviceList: [String!]
}

input CreateSchedulefileupgradeInput {
    "Account identifier."
    acc: String!
    contentType: String!
    "Device logging information."
    body: UploadAndScheduleFileRequestInput!
}

input SchedulesSoftwareUpgradeRequestInput {
    "The campaign name."
    campaignName: String!
    "Software name."
    softwareName: String!
    "Old software name."
    softwareFrom: String!
    "New software name."
    softwareTo: String!
    "Valid values"
    distributionType: String!
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "Specifies the starting date the client should download the package. If null, client downloads as soon as possible."
    downloadAfterDate: String!
    "List of allowed download time windows."
    downloadTimeWindowList: [DownloadTimeWindowInput!]
    "The date after which you install the package. If null, install as soon as possible."
    installAfterDate: String!
    "List of allowed install time windows."
    installTimeWindowList: [DownloadTimeWindowInput!]
    "Device IMEI list."
    deviceList: [String!]
}

input CreateScheduleswupgradehttpdevicesInput {
    "Account identifier."
    acc: String!
    contentType: String!
    "Device logging information."
    body: SchedulesSoftwareUpgradeRequestInput!
}

input ListRegisteredCallbacks3Input {
    "Account identifier."
    account: String!
}

"Callback URL registration."
input FotaV2CallbackRegistrationRequestInput {
    "Callback URL for an subscribed service."
    url: String!
}

input UpdateCallbackInput {
    "Account identifier."
    account: String!
    contentType: String!
    "Callback URL registration."
    body: FotaV2CallbackRegistrationRequestInput!
}

input CreateRegistercallback3Input {
    "Account identifier."
    account: String!
    contentType: String!
    "Callback URL registration."
    body: FotaV2CallbackRegistrationRequestInput!
}

input DeleteDeregistercallback3Input {
    "Account identifier."
    account: String!
}

input ListAvailableSoftwareInput {
    "Account identifier."
    account: String!
    "Filter distributionType to get specific type of software. Value is LWM2M, OMD-DM or HTTP."
    distributionType: String!
}

input ListAccountDevices1Input {
    "Account identifier."
    account: String!
    "Last seen device identifier."
    lastSeenDeviceId: String!
    "Filter distributionType to get specific type of devices. Values is LWM2M, OMD-DM or HTTP."
    distributionType: String!
}

input GetDeviceFirmwareUpgradeHistory1Input {
    "Account identifier."
    account: String!
    "Device IMEI identifier."
    deviceId: String!
}

input GetCampaignHistoryByStatusInput {
    "Account identifier."
    account: String!
    "Status of the campaign."
    campaignStatus: String!
    "Last seen campaign Id."
    lastSeenCampaignId: String!
}

input GetCampaignDeviceStatusInput {
    "Account identifier."
    account: String!
    "Campaign identifier."
    campaignId: String!
    "Last seen device identifier."
    lastSeenDeviceId: String!
}

input ListDevicesWithLoggingEnabledInput {
    "Account identifier."
    account: String!
}

"Device logging information."
input DeviceLoggingRequestInput {
    "List of device IMEI identifiers."
    deviceIds: [String!]
}

input UpdateEnableloggingfordevicesInput {
    "Account identifier."
    account: String!
    contentType: String!
    "Device logging information."
    body: DeviceLoggingRequestInput!
}

input DeleteDisableloggingfordevicesInput {
    "Account identifier."
    account: String!
    "The list of device IDs."
    deviceIds: String!
}

input UpdateEnabledeviceloggingInput {
    "Account identifier."
    account: String!
    "Device IMEI identifier."
    deviceId: String!
}

input DeleteDisabledeviceloggingInput {
    "Account identifier."
    account: String!
    "Device IMEI identifier."
    deviceId: String!
}

input ListDeviceLogsInput {
    "Account identifier."
    account: String!
    "Device IMEI identifier."
    deviceId: String!
}

input GetDeviceCheckInHistoryInput {
    "Account identifier."
    account: String!
    "Device IMEI identifier."
    deviceId: String!
}

input GetListOfFilesInput {
    "Account identifier."
    acc: String!
    "Filter the distributionType to only retrieve files for a specific distribution type."
    distributionType: String!
}

input UploadConfigFileInput {
    "Account identifier."
    acc: String!
    "The file to upload."
    fileupload: String!
    "Version of the file."
    fileVersion: String!
    "The software-applicable device make."
    make: String!
    "The software-applicable device model."
    model: String!
    "Local target path on the device."
    localTargetPath: String!
}

input GetAccountSubscriptionStatus2Input {
    "Account identifier."
    acc: String!
}

input GetAccountLicensesStatusInput {
    "Account identifier."
    acc: String!
    "Last seen device identifier."
    lastSeenDeviceId: String!
}

"List of devices."
input V3LicenseIMEIInput {
    "Device IMEI list."
    deviceList: [String!]
}

input CreateAssignlicensestodevices2Input {
    "Account identifier."
    acc: String!
    contentType: String!
    "License assignment."
    body: V3LicenseIMEIInput!
}

input CreateRemovelicensesfromdevices2Input {
    "Account identifier."
    acc: String!
    contentType: String!
    "License removal."
    body: V3LicenseIMEIInput!
}

"Time window."
input V3TimeWindowInput {
    "Start hour in range [0..23], current hour >= startTime."
    startTime: Int!
    "End hour in range [1..24], current hour < endTime."
    endTime: Int!
}

"Firmware upgrade for devices."
input CampaignFirmwareUpgradeInput {
    "Campaign name."
    campaignName: String!
    "Firmware name to upgrade to."
    firmwareName: String!
    "Old firmware version."
    firmwareFrom: String!
    "New firmware version."
    firmwareTo: String!
    "Valid values include: LWM2M, OMA and HTTP."
    protocol: String!
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "List of allowed campaign time windows."
    campaignTimeWindowList: [V3TimeWindowInput!]
    "Device IMEI list."
    deviceList: [String!]
}

input CreateSchedulecampaignfirmwareupgrade1Input {
    "Account identifier."
    acc: String!
    contentType: String!
    "Firmware upgrade information."
    body: CampaignFirmwareUpgradeInput!
}

"Devices to add or remove from existing software upgrade information."
input V3AddOrRemoveDeviceRequestInput {
    "Operation either 'append' or 'remove'"
    type: String!
    "Device IMEI list."
    deviceList: [String!]
}

input UpdateCampaignFirmwareDevices1Input {
    "Account identifier."
    acc: String!
    "Unique identifier of a campaign."
    campaignId: String!
    contentType: String!
    "Add or remove device to existing upgrade information."
    body: V3AddOrRemoveDeviceRequestInput!
}

"Campaign dates and time windows."
input V3ChangeCampaignDatesRequestInput {
    "Campaign start date."
    startDate: String!
    "Campaign end date."
    endDate: String!
    "List of allowed campaign time windows."
    campaignTimeWindowList: [V3TimeWindowInput!]
}

input UpdateCampaignDates1Input {
    "Account identifier."
    acc: String!
    "Firmware upgrade information."
    campaignId: String!
    contentType: String!
    "New dates and time windows."
    body: V3ChangeCampaignDatesRequestInput!
}

input GetCampaignInformation1Input {
    "Account identifier."
    acc: String!
    "Firmware upgrade identifier."
    campaignId: String!
}

input DeleteCancelcampaign1Input {
    "Account identifier."
    acc: String!
    "Firmware upgrade information."
    campaignId: String!
}

input GetCampaignHistoryByStatus1Input {
    "Account identifier."
    acc: String!
    "Campaign status."
    campaignStatus: CampaignStatus!
    "Last seen campaign Id."
    lastSeenCampaignId: String!
}

input GetDeviceFirmwareUpgradeHistory2Input {
    "Account identifier."
    acc: String!
    "Device IMEI identifier."
    deviceId: String!
}

input GetCampaignDeviceStatus1Input {
    "Account identifier."
    acc: String!
    "Campaign identifier."
    campaignId: String!
    "Last seen device identifier."
    lastSeenDeviceId: String!
}

input ListAvailableFirmware1Input {
    "Account identifier."
    acc: String!
    "Filter to retrieve a specific protocol type used."
    protocol: FirmwareProtocol!
}

"A list of IMEIs for devices to be synchronized between ThingSpace and the FOTA server."
input FirmwareIMEIInput {
    "Device IMEI list."
    deviceList: [String!]
}

input UpdateSynchronizedevicefirmwareInput {
    "Account identifier."
    acc: String!
    contentType: String!
    "DeviceIds to get firmware info synchronously."
    body: FirmwareIMEIInput!
}

input UpdateReportdevicefirmwareInput {
    "Account identifier."
    acc: String!
    "Device identifier."
    deviceId: String!
}

input GetAccountDeviceInformationInput {
    "Account identifier."
    acc: String!
    "Last seen device identifier."
    lastSeenDeviceId: String!
    "Filter to retrieve a specific protocol type used."
    protocol: DevicesProtocol!
}

"Device IMEI list."
input DeviceIMEIInput {
    "Device IMEI list."
    deviceList: [String!]
}

input CreateListaccountdevicesinformationInput {
    "Account identifier."
    acc: String!
    contentType: String!
    "Request device list information."
    body: DeviceIMEIInput!
}

input ListRegisteredCallbacks4Input {
    "Account identifier."
    acc: String!
}

"Callback URL where the listening service is running."
input FotaV3CallbackRegistrationRequestInput {
    "Callback URL for an subscribed service."
    url: String!
}

input UpdateCallback1Input {
    "Account identifier."
    acc: String!
    contentType: String!
    "Callback URL registration."
    body: FotaV3CallbackRegistrationRequestInput!
}

input CreateRegistercallback4Input {
    "Account identifier."
    acc: String!
    contentType: String!
    "Callback URL registration."
    body: FotaV3CallbackRegistrationRequestInput!
}

input DeleteDeregistercallback4Input {
    "Account identifier."
    acc: String!
}

"Id of the devices."
input LicenseDeviceIdInput {
    "For 4G devices, IMEI (decimal, up to 15 digits) for unassign and ICCID (decimal, up to 20 digits) for assign."
    id: String!
    "For 4G devices, ICCID (decimal, up to 20 digits) for unassign and IMEI (decimal, up to 15 digits) for assign."
    kind: String!
}

"List of all devices."
input LicenseDeviceListInput {
    "For 4G devices, IMEI (decimal, up to 15 digits)."
    deviceIds: [LicenseDeviceIdInput!]
    ipAddress: String!
}

"Request to assign license."
input AssignLicenseRequestInput {
    "The name of a billing account.This parameter is required only if the UWS account used for the current API session has access to multiple accounts. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "A list of 4G devices."
    devices: [LicenseDeviceListInput!]
    "The Stock Keeping Unit (SKU). Valid skuNumbers for license types: “SIMSec-IoT-Lt”. (Lifetime) Once a license is assigned to a SIM, the SIM-Secure feature is enabled for the life of the SIM.“TS-BUNDLE-KTO-SIMSEC-MRC”. (Bundle) The SIM-Secure Flex license can be assigned to or removed from a SIM at any time. This SKU is bundled with other ThingSpace Services.“SIMSec-IoT”. (Flex) The SIM-Secure Flex license can be assigned to or removed from a SIM at any time. This SKU is purchased a la carte."
    skuNumber: String!
}

input CreateAssignlicensetodevicesInput {
    contentType: String!
    "Request to assign license to devices."
    body: AssignLicenseRequestInput!
    "Transaction Id."
    xRequestID: String!
}

input DeleteUnassignlicensetodevicesInput {
    "Transaction Id."
    xRequestID: String!
}

"Request for a subscription."
input SecuritySubscriptionRequestInput {
    "The name of a billing account."
    accountName: String!
    "The Stock Keeping Unit (SKU). Valid skuNumbers for SIM-Secure for IoT are:SIMSec-IoT-Lt”. (Lifetime) Once a license is assigned to a SIM, the SIM-Secure feature is enabled for the life of the SIM.“TS-BUNDLE-KTO-SIMSEC-MRC”. (Bundle) The SIM-Secure Flex license can be assigned to or removed from a SIM at any time. This SKU is bundled with other ThingSpace Services.*“SIMSec-IoT”. (Flex) The SIM-Secure Flex license can be assigned to or removed from a SIM at any time. This SKU is purchased a la carte."
    skuNumber: String!
}

input CreateListaccountsubscriptionsInput {
    contentType: String!
    "Request for account subscription."
    body: SecuritySubscriptionRequestInput!
    "Transaction Id."
    xRequestID: String!
}

"MEC performance metrics request."
input QueryMECPerformanceMetricsRequestInput {
    "The 15-digit International Mobile Equipment Identifier."
    iMEI: String!
    "The 12-digit Mobile Station International Subscriber Directory Number."
    mSISDN: String!
}

input CreateQuerymecperformancemetricsInput {
    contentType: String!
    body: QueryMECPerformanceMetricsRequestInput!
}

input GetDiagnosticsSubscriptionInput {
    "Account identifier."
    accountName: String!
}

"Identifies a particular IoT device."
input DeviceInput {
    "Device identifier."
    id: String!
    "Device kind identifier."
    kind: String!
}

"Streaming RF parameter that you want to observe."
input ObservationRequestAttributeInput {
    "Attribute identifier."
    name: AttributeIdentifier!
}

"Describes value and unit of time."
input NumericalDataInput {
    "Numerical value."
    value: Int!
    "Unit of time."
    unit: NumericalDataUnit!
}

"Used to define callbacks including the device identity, the attribute names, corresponding attribute values and the date/timestamp of when the observation was made."
input ObservationRequestInput {
    "Account identifier in \"##########-#####\"."
    accountName: String!
    "List of devices."
    devices: [DeviceInput!]
    "Attributes are streaming RF parameters that you want to observe."
    attributes: [ObservationRequestAttributeInput!]
    "Describes value and unit of time."
    frequency: NumericalDataInput!
    "Describes value and unit of time."
    duration: NumericalDataInput!
}

input CreateStartdiagnosticsobservationInput {
    contentType: String!
    "Request for device observation information."
    body: ObservationRequestInput!
}

input DeleteStopdiagnosticsobservationInput {
    "The ID value associated with the transaction."
    transactionId: String!
    "The numeric account name."
    accountName: String!
}

"Streaming RF parameters for which you want to retrieve history data."
input HistorySearchFilterAttributesInput {
    "Attribute identifier."
    name: AttributeIdentifier!
}

"The selected device and attributes for which a request should retrieve data."
input HistorySearchFilterInput {
    "Account name identifier."
    accountName: String!
    "Identifies a particular IoT device."
    device: DeviceInput!
    "Streaming RF parameters for which you want to retrieve history data."
    attributes: HistorySearchFilterAttributesInput!
}

"The time period for which a request should retrieve data, beginning with the limitTime.startOn and proceeding with the limitTime.duration."
input HistorySearchLimitTimeInput {
    "The starting date-time for this request."
    startOn: String!
    "Describes value and unit of time."
    duration: NumericalDataInput!
}

"Used to filter data by time period or number of devices."
input HistorySearchRequestInput {
    "The selected device and attributes for which a request should retrieve data."
    _filter: HistorySearchFilterInput!
    "The maximum number of historical attributes to include in the response. If the request matches more than this number of attributes, the response will contain an X-Next value in the header that can be used as the page value in the next request to retrieve the next page of events."
    _limitNumber: Int!
    "The time period for which a request should retrieve data, beginning with the limitTime.startOn and proceeding with the limitTime.duration."
    _limitTime: HistorySearchLimitTimeInput!
    "Page number for pagination purposes."
    _page: String!
}

input CreateGetdiagnosticshistoryInput {
    contentType: String!
    "History data information."
    body: HistorySearchRequestInput!
}

input ListDiagnosticsSettingsInput {
    "Account identifier."
    accountName: String!
    "Devices list format: [{\"id\":\"{imei1}\",\"kind\":\"imei\"},{\"id\":\"{imei2}\",\"kind\":\"imei\"}]."
    devices: String!
}

input GetDiagnosticsSubscriptionCallbackInfoInput {
    "Account identifier."
    accountName: String!
}

"Specifies the callback service that is being subscribed to and the URL where the listening service is running."
input CallbackRegistrationRequestInput {
    "The name of the billing account for which callback messages will be sent. Format: \"##########-#####\"."
    accountName: String!
    "The name of the callback service, which identifies the type and format of messages that will be sent to the registered URL."
    serviceName: String!
    "The URL for your web server."
    endpoint: String!
    "Your HTTP headers."
    httpHeaders: String!
}

input CreateRegisterdiagnosticscallbackurlInput {
    contentType: String!
    "Callback URL registration request."
    body: CallbackRegistrationRequestInput!
}

input DeleteUnregisterdiagnosticscallbackInput {
    "Account identifier."
    accountName: String!
    "Service name for callback notification."
    serviceName: String!
}

"Request body to Performs a device reboot."
input DeviceResetRequestInput {
    "The name of the account. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "The action you want to take on the device."
    action: String!
    "The devices for which you want to perform a factory reset or reboot."
    devices: [DeviceInput!]
}

input CreateDecivesrestartInput {
    contentType: String!
    "A request to perform a device reboot."
    body: DeviceResetRequestInput!
}

"The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
input AccountIdentifierInput {
    billingaccountid: String!
}

"The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
input ResourceIdentifierInput {
    "Target ID."
    id: String!
    "Device IMEI."
    imei: String!
}

"Search for targets by property values."
input QueryTargetRequestInput {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifierInput!
    "A comma-separated list of properties and comparator values to match against subscriptions in the ThingSpace account. See Working with Query Filters for more information. If the request does not include `$selection`, the response will include all subscriptions to which the requesting user has access."
    _selection: String!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifierInput!
}

input CreateQuerytargetInput {
    contentType: String!
    "Search for targets by property values."
    body: QueryTargetRequestInput!
}

"Target to delete."
input DeleteTargetRequestInput {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifierInput!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifierInput!
}

input CreateDeletetargetInput {
    contentType: String!
    "The request body identifies the target to delete."
    body: DeleteTargetRequestInput!
}

input FieldsHttpHeadersInput {
    authorization: String!
}

input CreateTargetRequestFieldsInput {
    httpheaders: FieldsHttpHeadersInput!
    "List of device types."
    devicetypes: [String!]
}

"Authentication headers."
input TargetAuthenticationBodyHeadersInput {
    "Authorization header."
    authorization: String!
    "Content-Type header."
    contentType: String!
}

"Host information."
input TargetAuthenticationBodyHostInput {
    hostandpath: String!
}

input TargetAuthenticationBodyInput {
    "Authentication grant type."
    grantType: String!
    "Refresh token."
    refreshToken: String!
    "Authentication scopes."
    scope: String!
    "Authentication headers."
    headers: TargetAuthenticationBodyHeadersInput!
    "Host information."
    host: TargetAuthenticationBodyHostInput!
}

"OAuth 2 token and refresh token for TS to stream events to Target."
input TargetAuthenticationInput {
    body: TargetAuthenticationBodyInput!
    version: String!
}

"Details of the target that you want to create."
input CreateTargetRequestInput {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifierInput!
    "The ID of the authenticating billing account."
    billingaccountid: String!
    "Identifies the resource kind. Targets are ts.target."
    kind: String!
    "The endpoint for notifications or data streams. The format depends on the selected `addressscheme`.<br />`streamrest` requires a `host:port` value <br />`streamawsiot` requres a valid ARN."
    address: String!
    "The transport format. Valid values are: <br />streamawsiot - streamed data to an AWS account <br />streamrest - streamed REST data to a defined endpoint."
    addressscheme: String!
    fields: CreateTargetRequestFieldsInput!
    "Descriptive information about the target."
    description: String!
    "Security identification string created by a POST /targets/actions/newextid request."
    externalid: String!
    "Name of the target."
    name: String!
    "AWS region value."
    region: String!
    "OAuth 2.0 bearer token."
    key1: String!
    "OAuth 2 token and refresh token for TS to stream events to Target."
    oauth: TargetAuthenticationInput!
}

input CreateTargetInput {
    contentType: String!
    "The request body provides the details of the target that you want to create."
    body: CreateTargetRequestInput!
}

"Authenticating account ID."
input GenerateExternalIDRequestInput {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifierInput!
}

input CreateGeneratetargetexternalidInput {
    contentType: String!
    "The request body only contains the authenticating account."
    body: GenerateExternalIDRequestInput!
}

"The request body must include the UUID of the subscription that you want to update plus any properties that you want to change."
input CreateIoTApplicationRequestInput {
    "A user defined name for the application being deployed in Azure IoT Central."
    appName: String!
    "The ThingSpace ID of the authenticating billing account"
    billingAccountID: String!
    "The Azure ClientID of the associated Azure target account"
    clientID: String!
    "The Azure Client Secret of the associated Azure target account"
    clientSecret: String!
    "The “email IDs” to be added to/sent to with this API."
    emailIDs: String!
    "The Azure Resource group of the associated Azure target account"
    resourcegroup: String!
    "This is the reference Azure IoT Central application developed by Verizon."
    sampleIOTcApp: String!
    "The Azure Subscription ID of the associated Azure target account"
    subscriptionID: String!
    "The Azure Tenant ID of the associated Azure target account"
    tenantID: String!
}

input CreateAzureCentralIoTApplicationInput {
    "TThe ThingSpace ID of the authenticating billing account."
    billingaccountID: String!
    contentType: String!
    "The request body must include the UUID of the subscription that you want to update plus any properties that you want to change."
    body: CreateIoTApplicationRequestInput!
}

"The details of the subscription that you want to create."
input CreateSubscriptionRequestInput {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifierInput!
    "Descriptive information about the subscription."
    description: String!
    "Enable or disable the subscription. A disabled subscription will not send any data."
    disabled: Boolean!
    "The address to which any error reports should be delivered."
    email: String!
    "String containing a $filter object with a property and value to filter out non-matching events."
    filter: String!
    billingaccountid: String!
    "The type of event data to send via this subscription. This will be `ts.event` in most cases. Other event types are `ts.event.diagnostics` for device diagnostic data, `ts.event.configuration` for device configuration events, or `ts.event.security`. Note that the device ThingSpace client must support sending specific event types for anything other than `ts.event`."
    streamkind: String!
    "The ID of the target resource to be used when dispatching events. The corresponding target should have a “stream” addressscheme."
    targetid: String!
    "Name of the subscription."
    name: String!
    "Setting this value to `false` prevents the data returned from being aggregated and makes the data easier to parse."
    allowaggregation: Boolean!
}

input CreateSubscriptionInput {
    contentType: String!
    "The request body provides the details of the subscription that you want to create."
    body: CreateSubscriptionRequestInput!
}

"Fields and values to match."
input QuerySubscriptionRequestInput {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifierInput!
    "A comma-separated list of properties and comparator values to match against subscriptions in the ThingSpace account. See Working with Query Filters for more information. If the request does not include `$selection`, the response will include all subscriptions to which the requesting user has access."
    _selection: String!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifierInput!
}

input CreateQuerysubscriptionInput {
    contentType: String!
    "The request body specifies fields and values to match."
    body: QuerySubscriptionRequestInput!
}

"The subscription to delete."
input DeleteSubscriptionRequestInput {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifierInput!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifierInput!
}

input CreateDeletesubscriptionInput {
    contentType: String!
    "The request body identifies the subscription to delete."
    body: DeleteSubscriptionRequestInput!
}

"List of the field names and values to set."
input ConfigurationInput {
    frequency: String!
}

"The request body identifies the device and the values to set."
input ChangeConfigurationRequestInput {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifierInput!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifierInput!
    "List of the field names and values to set."
    configuration: ConfigurationInput!
}

input UpdateDevicesConfigurationValueInput {
    contentType: String!
    "The request body changes configuration values on a device."
    body: ChangeConfigurationRequestInput!
}

input CreateFinddevicebypropertyvaluesInput {
    contentType: String!
    "The request body specifies fields and values to match."
    body: QuerySubscriptionRequestInput!
}

input CreateSearchdevicesresourcesbypropertyvaluesInput {
    contentType: String!
    "The request body specifies fields and values to match."
    body: QuerySubscriptionRequestInput!
}

"Search Device By Property resource definition."
input SearchDeviceEventHistoryRequestInput {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifierInput!
    "A comma-separated list of properties and comparator values to match against subscriptions in the ThingSpace account. See Working with Query Filters for more information. If the request does not include `$selection`, the response will include all subscriptions to which the requesting user has access."
    _selection: String!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifierInput!
    "The maximum number of events to include in the response."
    _limitnumber: Int!
    "The maximum number of events to include in the response."
    _page: String!
}

input CreateSearchdeviceeventhistoryInput {
    contentType: String!
    "The device identifier and fields to match in the search."
    body: SearchDeviceEventHistoryRequestInput!
}

"Search Device By Property resource definition."
input SearchSensorHistoryRequestInput {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifierInput!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifierInput!
    "The maximum number of events to include in the response."
    _limitnumber: Int!
    "The maximum number of events to include in the response."
    _page: String!
}

input CreateSearchsensorreadingsInput {
    "The name of the sensor."
    fieldname: String!
    contentType: String!
    "The device identifier and fields to match in the search."
    body: SearchSensorHistoryRequestInput!
}

"The request body identifies the device to delete."
input RemoveDeviceRequestInput {
    "The ID of the authenticating billing account, in the format `{\"billingaccountid\":\"1234567890-12345\"}`."
    accountidentifier: AccountIdentifierInput!
    "The ID of the target to delete, in the format {\"id\": \"dd1682d3-2d80-cefc-f3ee-25154800beff\"}."
    resourceidentifier: ResourceIdentifierInput!
}

input CreateDeletedevicefromaccountInput {
    contentType: String!
    "The request body identifies the device to delete."
    body: RemoveDeviceRequestInput!
}

input GetDeviceHyperPreciseStatusInput {
    "A unique identifier for a device."
    imei: String!
    "A unique identifier for an account."
    accountNumber: String!
}

"Device information."
input DeviceServiceRequestInput {
    "International Mobile Equipment Identifier. The unique ID of a device."
    imei: String!
    "Set to Enable (true) or Disable (false)."
    bullseyeEnable: Boolean!
}

"Account number and list of devices."
input BullseyeServiceRequestInput {
    "A list of devices."
    deviceList: [DeviceServiceRequestInput!]
    "A unique identifier for an account."
    accountNumber: String!
}

input UpdateDeviceHyperPreciseStatusInput {
    contentType: String!
    "List of devices and hyper-precise required statuses."
    body: BullseyeServiceRequestInput!
}

"Request for getting an aggregated session report."
input AggregateSessionReportRequestInput {
    "The unique identifier for the account."
    accountNumber: String!
    "Start date of session to include. If not specified  information will be shown from the earliest available (180 days). Can be either date in ISO 8601 format or predefined constants."
    startDate: String!
    "End date of session to include. If not specified  information will be shown to the latest available. Can be either date in ISO 8601 format or predefined constants."
    endDate: String!
    "Devices for which return usage info. Could be 0, 1 or more. In case of 0 will return all devices belonging to customer (except of filtered by other parameters)."
    imei: [String!]
    "User defined group name the devices are a member of."
    deviceGroup: String
    "Optional filter parameter."
    deviceLabel: String
    "The data plan the devices beign queried belong to."
    dataPlan: String
    "Optional filter parameter which return only devices with no sessions."
    noSessionFlag: String!
}

input CreateCalculateaggregatedreportsynchronousInput {
    contentType: String!
    "Aggregated report request."
    body: AggregateSessionReportRequestInput!
}

input CreateCalculateaggregatedreportasynchronousInput {
    contentType: String!
    "Aggregated session report request."
    body: AggregateSessionReportRequestInput!
}

"Request for obtaining a session report."
input SessionReportRequestInput {
    "Account Number."
    accountNumber: String!
    "Device ids."
    imei: String!
    "Start date of session to include. If not specified  information will be shown from the earliest available (180 days). Can be either date in ISO 8601 format or predefined constants."
    startDate: String!
    "End date of session to include. If not specified  information will be shown to the latest available. Can be either date in ISO 8601 format or predefined constants."
    endDate: String!
    "The Low value of session duration."
    durationLow: Int
    "The High value of session duration."
    durationHigh: Int
}

input CreateGetsessionsreportInput {
    contentType: String!
    "Request for sessions report."
    body: SessionReportRequestInput!
}

input ListRegisteredCallbacks5Input {
    "A unique identifier for an account."
    accountNumber: String!
}

"Callback registration request."
input HyperPreciseLocationCallbackInput {
    "The name of the callback service that you want to subscribe to."
    name: String!
    "The address on your server where you have enabled a listening service for the specific type of callback messages. Specify a URL that is reachable from the Verizon data centers. If your service is running on HTTPS, you should use a one-way authentication certificate with a white-listed IP address."
    url: String!
}

input CreateRegistercallback5Input {
    "A unique identifier for an account."
    accountNumber: String!
    contentType: String!
    body: HyperPreciseLocationCallbackInput!
}

input DeleteDeregistercallback5Input {
    "A unique identifier for a account."
    accountNumber: String!
    "The name of the callback service that will be deleted."
    service: String!
}

"Details for sensitivity parameters."
input SensitivityParametersInput {
    "The maximum value of the threshold in the units being measured."
    abnormalMaxValue: Float!
    "If abnormal values are being monitored.<br />true - Monitor for abnormal values<br />false - Do not monitor for abnormal values."
    enableAbnormal: Boolean!
    "If very abnormal values are being monitored.<br />true - Monitor for very abnormal values<br />false - Do not monitor for very abnormal values."
    enableVeryAbnormal: Boolean!
    "The maximum value of the threshold in the units being measured."
    veryAbnormalMaxValue: Float!
}

"Anomaly detection request."
input AnomalyDetectionRequestInput {
    "The name of a billing account. An account name is usually numeric, and must include any leading zeros."
    accountName: String!
    "The type of request being made. anomaly is the request to activate anomaly detection."
    requestType: String!
    "Details for sensitivity parameters."
    sensitivityParameter: SensitivityParametersInput!
}

input CreateActivateanomalydetectionInput {
    contentType: String!
    "Request to activate anomaly detection."
    body: AnomalyDetectionRequestInput!
}

input ListAnomalyDetectionSettingsInput {
    "The name of the subscribed account."
    accountName: String!
}

input UpdateResetanomalydetectionparametersInput {
    "The name of the subscribed account."
    accountName: String!
}

"The details of the UsageAnomaly trigger."
input AnomalyTriggerRequestInput {
    "The Verizon billing accounts associated with the anomaly triggers for this trigger to be active for devices in those accounts. An account name is usually numeric, and must include any leading zeros."
    accountNames: String!
    "Whether or not to include anomalies classified as 'abnormal'.<br />true<br />false<br />Classification is set as part of ThingSpace Intelligence anomaly detection settings."
    includeAbnormal: Boolean!
    "Whether or not to include anomalies classified as 'very abnormal'.<br />true<br />false<br />Classification is set as part of ThingSpace Intelligence anomaly detection settings."
    includeVeryAbnormal: Boolean!
    "Whether or not to include anomalies that are directionally under the expected usage.<br />true<br />false."
    includeUnderExpectedUsage: Boolean!
    "Whether or not to include anomalies that are directionally over the expected usage. <br />true<br />false."
    includeOverExpectedUsage: Boolean!
}

input DataTriggerRequestInput {
    comparator: String!
    threshold: Int!
    thresholdUnit: String!
}

input PromoAlertTriggerRequestInput {
    dataPercentage50: Boolean!
    dataPercentage75: Boolean!
    dataPercentage90: Boolean!
    noOfDaysB4PromoExp: Int!
    smsPercentage50: Boolean!
    smsPercentage75: Boolean!
    smsPercentage90: Boolean!
}

input SessionTriggerRequestInput {
    comparator: String!
    threshold: Int!
}

input SMSTriggerRequestInput {
    comparator: String!
    smsType: String!
    threshold: Int!
}

input UpdateTriggerRequestInput {
    accountName: String!
    active: Boolean!
    "The details of the UsageAnomaly trigger."
    anomalyTriggerRequest: AnomalyTriggerRequestInput!
    cycleType: CycleType!
    dataTriggerRequest: DataTriggerRequestInput!
    groupName: String!
    promoAlertTriggerRequest: PromoAlertTriggerRequestInput!
    sessionTriggerRequest: SessionTriggerRequestInput!
    smsTriggerRequest: SMSTriggerRequestInput!
    triggerCategory: String!
    triggerId: String!
    triggerName: String!
}

input UpdateAnomalyDetectionTriggerInput {
    contentType: String!
    "Update Trigger Request"
    body: UpdateTriggerRequestInput!
}

input CreateTriggerRequestInput {
    accountName: String!
    "The details of the UsageAnomaly trigger."
    anomalyTriggerRequest: AnomalyTriggerRequestInput!
    dataTriggerRequest: DataTriggerRequestInput!
    groupName: String!
    name: String!
    sessionTriggerRequest: SessionTriggerRequestInput!
    smsTriggerRequest: SMSTriggerRequestInput!
    triggerCategory: String!
    triggerCycle: String!
}

input CreateAnomalyDetectionTriggerInput {
    contentType: String!
    "Create Trigger Request"
    body: CreateTriggerRequestInput!
}

input ListAnomalyDetectionTriggerSettingsInput {
    "trigger ID"
    triggerId: String!
}

input DeleteAnomalyDetectionTriggerInput {
    "The trigger ID to be deleted"
    triggerId: String!
}

"Notification SMS details."
input SMSNumberInput {
    carrier: String!
    number: String!
}

"The notification details of the trigger."
input NotificationInput {
    "The type of notification, i.e. 'DailySummary'."
    notificationType: String!
    "Whether or not the notification should be sent via callback.<br />true<br />false."
    callback: Boolean!
    "Whether or not the notification should be sent via e-mail.<br />true<br />false."
    emailNotification: Boolean!
    "Name for the notification group."
    notificationGroupName: String!
    "Frequency factor for notification."
    notificationFrequencyFactor: Int!
    "Frequency interval for notification."
    notificationFrequencyInterval: String!
    "E-mail address(es) where the notification should be delivered."
    externalEmailRecipients: String!
    "SMS notification."
    smsNotification: Boolean!
    "List of SMS numbers."
    smsNumbers: [SMSNumberInput!]
    reminder: Boolean!
    "Severity level associated with the notification. Examples would be:<br />Major<br />Minor<br />Critical<br />NotApplicable."
    severity: String!
}

input CreateTriggerRequestOptionsInput {
    "Trigger name."
    name: String!
    "This is the value to use in the request body to detect anomalous behaivior. The values in this table will only be relevant when this parameter is set to this value."
    triggerCategory: String!
    "Account name."
    accountName: String!
    "The details of the UsageAnomaly trigger."
    anomalyTriggerRequest: AnomalyTriggerRequestInput!
    "The notification details of the trigger."
    notification: NotificationInput!
    "Indicates anomaly detection is active<br />True - Anomaly detection is active.<br />False - Anomaly detection is not active."
    active: Boolean!
}

input CreateAnomalyDetectionTriggerV2Input {
    contentType: String!
    "Request to create an anomaly trigger."
    body: [CreateTriggerRequestOptionsInput!]
}

input UpdateTriggerRequestOptionsInput {
    "Trigger ID."
    triggerId: String!
    "Trigger name."
    triggerName: String!
    "This is the value to use in the request body to detect anomalous behaivior. The values in this table will only be relevant when this parameter is set to this value."
    triggerCategory: String!
    "Account name."
    accountName: String!
    "The details of the UsageAnomaly trigger."
    anomalyTriggerRequest: AnomalyTriggerRequestInput!
    "The notification details of the trigger."
    notification: NotificationInput!
    "Indicates anomaly detection is active<br />True - Anomaly detection is active.<br />False - Anomaly detection is not active."
    active: Boolean!
}

input UpdateAnomalyDetectionTriggerV2Input {
    contentType: String!
    "Request to update existing trigger."
    body: [UpdateTriggerRequestOptionsInput!]
}

input ListAnomalyDetectionTriggerSettingsV2Input {
    "The trigger ID of a specific trigger."
    triggerId: String!
}

"Coordinates information."
input CoordinatesInput {
    "Latitude value of location."
    latitude: String!
    "Longitude value of location."
    longitude: String!
}

"Get network conditions."
input GetNetworkConditionsRequestInput {
    "Account name."
    accountName: String!
    "Type of location detail."
    locationType: String!
    "Coordinates information."
    coordinates: CoordinatesInput!
}

input CreateNearrealtimenetworkconditionsInput {
    contentType: String!
    "Request for current network health."
    body: GetNetworkConditionsRequestInput!
}

"Location coordinates."
input LocationscoordInput {
    coordinatesList: [CoordinatesInput!]
}

"Network type."
input NetworkTypeInput {
    networkType: String!
}

"Get wireless coverage."
input GetWirelessCoverageRequestInput {
    "Account name."
    accountName: String!
    "Type of request."
    requestType: String!
    "Type of location detail."
    locationType: String!
    "Location coordinates."
    locations: LocationscoordInput!
    networkTypesList: [NetworkTypeInput!]
}

input CreateDomestic4gand5gnationwidenetworkcoverageInput {
    contentType: String!
    "Request for network coverage details."
    body: GetWirelessCoverageRequestInput!
}

input CreateSiteproximityInput {
    contentType: String!
    "Request for cell site proximity."
    body: GetNetworkConditionsRequestInput!
}

"Device Id details."
input DeviceIdentifierInput {
    "Kind of device."
    kind: String!
    "Device Identity number."
    id: String!
    "Device MDN number."
    mdn: String!
}

"Get device experience score history."
input GetDeviceExperienceScoreHistoryRequestInput {
    "Account name."
    accountName: String!
    "Device Id details."
    deviceId: DeviceIdentifierInput!
}

input CreateDeviceexperience30dayshistoryInput {
    contentType: String!
    "Request for a device's 30 day experience."
    body: GetDeviceExperienceScoreHistoryRequestInput!
}

"Get device experience score bulk request."
input GetDeviceExperienceScoreBulkRequestInput {
    "Account name."
    accountName: String!
    deviceList: [DeviceIdentifierInput!]
}

input CreateDeviceexperiencebulklatestInput {
    contentType: String!
    "Request for bulk latest history details."
    body: GetDeviceExperienceScoreBulkRequestInput!
}

"Address details."
input AddressItemInput {
    "Street Address."
    addressLine1: String!
    "Optional address information."
    addressLine2: String!
    "Name of the city."
    city: String!
    "State code."
    state: String!
    "Country."
    country: String!
    "Five digit zipcode."
    zip: String!
    "Four digit zip code."
    zip4: String!
}

"Location details."
input LocationsInput {
    addressList: [AddressItemInput!]
}

"Get wireless coverage FWA."
input GetWirelessCoverageRequestFWAInput {
    "Account name."
    accountName: String!
    "Type of request."
    requestType: String!
    "Type of location detail."
    locationType: String!
    "Location details."
    locations: LocationsInput!
    networkTypesList: [NetworkTypeInput!]
}

input CreateDomestic4gand5gfixedwirelessqualificationInput {
    contentType: String!
    "Request for network coverage details."
    body: GetWirelessCoverageRequestFWAInput!
}

input GIODeviceIdInput {
    kind: String!
    id: String!
}

input GIODeviceListInput {
    deviceIds: [GIODeviceIdInput!]
}

input GIOProfileRequestInput {
    devices: [GIODeviceListInput!]
    accountName: String!
    mdnZipCode: String!
    servicePlan: String!
}

input CreateActivateadeviceprofileInput {
    contentType: String!
    "Device Profile Query"
    body: GIOProfileRequestInput!
}

input DeviceProfileRequestInput {
    devices: [GIODeviceListInput!]
    accountName: String!
    servicePlan: String!
}

input CreateEnableadeviceprofileInput {
    contentType: String!
    "Device Profile Query"
    body: DeviceProfileRequestInput!
}

input GIODeactivateDeviceProfileRequestInput {
    devices: [GIODeviceListInput!]
    accountName: String!
    servicePlan: String!
    etfWaiver: Boolean!
    reasonCode: String!
}

input CreateDeactivateadeviceprofileInput {
    contentType: String!
    "Device Profile Query"
    body: GIODeactivateDeviceProfileRequestInput!
}

input CreateEnableadeviceprofilefordownloadInput {
    contentType: String!
    "Device Profile Query"
    body: DeviceProfileRequestInput!
}

input CreateDownloadadeviceprofileInput {
    contentType: String!
    "Device Profile Query"
    body: DeviceProfileRequestInput!
}

input CreateDeleteadeviceprofileInput {
    contentType: String!
    "Device Profile Query"
    body: DeviceProfileRequestInput!
}

input KvPairInput {
    key: String!
    value: String!
}

input GIOSMSSendRequestInput {
    accountName: String!
    customFields: [KvPairInput!]
    dataEncoding: String!
    groupName: String!
    servicePlan: String!
    timeToLive: String!
    deviceIds: [GIODeviceIdInput!]
    smsMessage: String!
}

input CreateSendansmsmessageInput {
    contentType: String!
    "SMS message to an indiividual device."
    body: GIOSMSSendRequestInput!
}

input GetSmsMessagesInput {
    "Numeric account name"
    accountName: String!
    "Continue the previous query from the pageUrl in Location Header"
    next: String!
}

input UpdateStartsmsmessagedeliveryInput {
    "Numeric account name"
    accountName: String!
}

input SMSEventHistoryRequestInput {
    deviceId: GIODeviceIdInput!
    earliest: String!
    latest: String!
}

input CreateListsmsmessagehistoryInput {
    contentType: String!
    "Device Query"
    body: SMSEventHistoryRequestInput!
}

input GetDeviceListWithProfilesRequestInput {
    accountName: String!
    provisioningStatusFilter: String!
    profileStatusFilter: String!
    carrierNameFilter: String!
    deviceFilter: [GIODeviceIdInput!]
}

input CreateRetrievetheglobaldevicelistInput {
    contentType: String!
    "Device Profile Query"
    body: GetDeviceListWithProfilesRequestInput!
}

input ProvhistoryRequestInput {
    accountName: String!
    deviceFilter: [GIODeviceIdInput!]
    earliest: String!
    latest: String!
}

input CreateRetrievedeviceprovisioninghistoryInput {
    contentType: String!
    "Device Provisioning History"
    body: ProvhistoryRequestInput!
}

input GetAsynchronousRequestStatusInput {
    accountName: String!
    requestID: String!
}

input QOSdeviceIdInput {
    id: String!
    kind: String!
}

input FlowInfoInput {
    flowServer: String!
    flowDevice: String!
    flowDirection: String!
    flowProtocol: String!
    qciOption: String!
}

input QOSdeviceInfoInput {
    deviceId: QOSdeviceIdInput!
    deviceIPv6Addr: String!
    flowInfo: [FlowInfoInput!]
}

input SubscribeRequestInput {
    accountName: String!
    deviceInfo: [QOSdeviceInfoInput!]
}

input CreateAThingSpaceQualityOfServiceAPISubscriptionInput {
    contentType: String!
    "The request details to create a ThingSpace Quality of Service API subscription."
    body: SubscribeRequestInput!
}

input DeleteStopathingspacequalityofserviceapisubscriptionInput {
    accountName: String!
    qosSubscriptionId: String!
}

input GetKpilistInput {
    "Account name."
    aname: String!
}

input GetProfileListInput {
    "Account name."
    aname: String!
}

input MECDeviceIdInput {
    id: String!
    kind: String!
}

input MECDeviceListInput {
    deviceIds: [MECDeviceIdInput!]
}

input ActivateInput {
    profile: String!
}

input ChangePmecDeviceStateActivateRequestInput {
    accountName: String!
    deviceList: [MECDeviceListInput!]
    activate: ActivateInput!
}

input ChangepmecdevicestateActivateInput {
    contentType: String!
    body: ChangePmecDeviceStateActivateRequestInput!
}

input ChangePmecDeviceStateBulkDeactivateRequestInput {
    accountName: String!
    deviceList: [MECDeviceListInput!]
}

input ChangepmecdevicestateBulkdeactivateInput {
    contentType: String!
    body: ChangePmecDeviceStateBulkDeactivateRequestInput!
}

input ChangePmecDeviceProfileRequestInput {
    accountName: String!
    deviceList: [MECDeviceListInput!]
    newProfile: String!
}

input ChangePmecDeviceProfileInput {
    contentType: String!
    body: ChangePmecDeviceProfileRequestInput!
}

input ChangePmecDeviceIPaddressBulkInput {
    contentType: String!
    body: ChangePmecDeviceStateBulkDeactivateRequestInput!
}

input GetMECPerformanceConsentInput {
    "Account name."
    aname: String!
}

input ReadySimDeviceIdInput {
    kind: String!
    id: String!
}

input RequestBodyforUsage1Input {
    deviceId: [ReadySimDeviceIdInput!]
    startTime: String!
    endTime: String!
}

input CreateGetpromodeviceusagehistoryInput {
    contentType: String!
    "Retrieve Aggregate Usage"
    body: RequestBodyforUsage1Input!
}

input RequestBodyforUsageInput {
    accountId: String!
    deviceId: [ReadySimDeviceIdInput!]
    startTime: String!
    endTime: String!
}

input CreateGetpromodeviceaggregateusagehistoryInput {
    contentType: String!
    "Retrieve Aggregate Usage"
    body: RequestBodyforUsageInput!
}

input GetAllTriggersByAccountNameInput {
    "The account name"
    accountName: String!
}

input GetTriggersByIdInput {
    "The ID of a specific trigger"
    triggerId: String!
}

input Keyschunk2Input {
    dataPercentage50: Boolean!
    dataPercentage75: Boolean!
    dataPercentage90: Boolean!
    dataPercentage100: Boolean!
    smsPercentage50: Boolean!
    smsPercentage75: Boolean!
    smsPercentage90: Boolean!
    smsPercentage100: Boolean!
    noOfDaysB4PromoExp: Int!
}

input PromoAlert1Input {
    filterCriteria: [String!]
    condition: [Keyschunk2Input!]
    enablePromoExp: Boolean!
}

input RequestTriggerInput {
    triggerId: String!
    triggerName: String!
    accountName: String!
    organizationName: String!
    triggerCategory: String!
    promoAlerts: [PromoAlert1Input!]
}

input UpdateAllAvailableTriggersInput {
    contentType: String!
    "Update the triggers"
    body: RequestTriggerInput!
}

input ESIMDeviceIdInput {
    id: String!
    kind: String!
}

input ESIMDeviceListInput {
    deviceIds: [ESIMDeviceIdInput!]
}

input ESIMProfileRequestInput {
    devices: [ESIMDeviceListInput!]
    carrierName: String!
    accountName: String!
    servicePlan: String!
    mdnZipCode: String!
}

input CreateSetactivateusingpostInput {
    contentType: String!
    "Device Profile Query"
    body: ESIMProfileRequestInput!
}

input DeviceList2Input {
    ids: [ESIMDeviceIdInput!]
}

input ProfileRequest2Input {
    devices: [DeviceList2Input!]
    accountName: String!
    carrierName: String!
    reasonCode: String!
    etfWaiver: Boolean!
    checkFallbackProfile: Boolean!
}

input CreateSetdeactivateusingpostInput {
    contentType: String!
    "Device Profile Query"
    body: ProfileRequest2Input!
}

input DeviceId2Input {
    id: String!
    kind: String!
}

input ESIMProvhistoryRequestInput {
    accountName: String!
    deviceFilter: [DeviceId2Input!]
    earliest: String!
    latest: String!
}

input CreateDeviceprovhistoryusingpostInput {
    contentType: String!
    "Device Provisioning History"
    body: ESIMProvhistoryRequestInput!
}

input GetRequeststatususinggetInput {
    accountname: String!
    requestID: String!
}

"Request for /vendors/registration endpoint. It requires the VendorID and ThingSpace Billing Account number to be defined."
input VendorRegistrationRequestInput {
    "The ID the vendor wants it's devices to be registered under. E.g. Verizon, GM, Ford, etc."
    vendorID: String!
    "The ThingSpace Billing Account number."
    thingSpaceBillingAccount: String!
}

input CreateRegisterimpvendorInput {
    "This is the Basic (authentication) token for the user. It should be acquired by using the ThingSpace Portal (thingspace.verizon.com)."
    basicToken: String!
    "This is the UWS login name for the user. It should be acquired by using the ThingSpace Connectivity Management Portal (thingspace.verizonwireless.com)."
    username: String!
    "This is the UWS password for the user. It should be acquired by using the ThingSpace Connectivity Management Portal (thingspace.verizonwireless.com)."
    password: String!
    contentType: String!
    body: VendorRegistrationRequestInput!
}

input DeleteUnregisterimpvendorInput {
    "This is the Basic (authentication) token for the user. It should be acquired by using the ThingSpace Portal (thingspace.verizon.com)."
    basicToken: String!
    "This is the UWS login name for the user. It should be acquired by using the ThingSpace Connectivity Management Portal (thingspace.verizonwireless.com)."
    username: String!
    "This is the UWS password for the user. It should be acquired by using the ThingSpace Connectivity Management Portal (thingspace.verizonwireless.com)."
    password: String!
    "The VendorID set during the Vendor registration call."
    vendorID: String!
}

"Request for /clients/registration endpoint. It requires the Client Type, Subtype and Vendor to be defined."
input ClientRegistrationRequestInput {
    clientType: String!
    "The subtype or subgroup of the client type. This further specifies the client type. For example it will specify if the client is a passenger car or a truck. See the ClientType description for the supported Subtypes for each client type."
    clientSubtype: ClientSubtype!
    "The vendor that the client belongs to. E.g. Verizon, GM, Ford, etc."
    vendorID: String!
}

input CreateRegisterimpdeviceInput {
    "This is the UWS login name for the user. It should be acquired by using the ThingSpace Connectivity Management Portal (thingspace.verizonwireless.com)."
    username: String!
    "This is the UWS password for the user. It should be acquired by using the ThingSpace Connectivity Management Portal (thingspace.verizonwireless.com)."
    password: String!
    contentType: String!
    body: ClientRegistrationRequestInput!
}

input DeleteUnregisterimpdeviceInput {
    "This is the UWS login name for the user. It should be acquired by using the ThingSpace Connectivity Management Portal (thingspace.verizonwireless.com)."
    username: String!
    "This is the UWS password for the user. It should be acquired by using the ThingSpace Connectivity Management Portal (thingspace.verizonwireless.com)."
    password: String!
    "The Device IDs acquired through the registration API."
    deviceIDs: [ID!]
}

"Geolocation of the device at the time of the connection request in GPS coordinates."
input GeolocationInput {
    "The GPS Latitude value"
    latitude: Float!
    "The GPS Longitude value"
    longitude: Float!
}

"Request for /clients/connection. It requires the device ID acquired in the registration request call; the geolocation of the device at the time of the request; and the network type (Verizon or non-Verizon). The system uses this information to determine with MQTT endpoint the device should use to connect the IMP Message Exchange."
input ConnectionRequestInput {
    "The device ID acquired through the registration API."
    deviceID: ID!
    "Geolocation of the device at the time of the connection request in GPS coordinates."
    geolocation: GeolocationInput!
    networkType: String!
}

input CreateRetrievemqtturlInput {
    "This is the UWS login name for the user. It should be acquired by using the ThingSpace Connectivity Management Portal (thingspace.verizonwireless.com)."
    username: String!
    "This is the UWS password for the user. It should be acquired by using the ThingSpace Connectivity Management Portal (thingspace.verizonwireless.com)."
    password: String!
    "The VendorID set during the Vendor registration call."
    vendorID: String!
    contentType: String!
    body: ConnectionRequestInput!
}

input UploadMapDataMessageInput {
    "This is the Basic (authentication) token for the user. It should be acquired by using the ThingSpace Portal (thingspace.verizon.com)."
    basicToken: String!
    "This is the UWS login name for the user. It should be acquired by using the ThingSpace Connectivity Management Portal (thingspace.verizonwireless.com)."
    username: String!
    "This is the UWS password for the user. It should be acquired by using the ThingSpace Connectivity Management Portal (thingspace.verizonwireless.com)."
    password: String!
    contentType: String!
    body: String!
}

input CoordinateInput {
    latitude: String!
    longitude: String!
}

input PolygonInput {
    type: String!
    coordinates: [CoordinateInput!]
}

input GetDownloadmapdatamessageInput {
    "This is the Basic (authentication) token for the user. It should be acquired by using the ThingSpace Portal (thingspace.verizon.com)."
    basicToken: String!
    "This is the UWS login name for the user. It should be acquired by using the ThingSpace Connectivity Management Portal (thingspace.verizonwireless.com)."
    username: String!
    "This is the UWS password for the user. It should be acquired by using the ThingSpace Connectivity Management Portal (thingspace.verizonwireless.com)."
    password: String!
    geoFence: PolygonInput!
}

type Query {
    "Returns a list of optimal MEC Platforms where you can register your deployed application. **Note:** If a query is sent with all of the parameters, it will fail with a \"400\" error. You can search based on the following parameter combinations - region plus Service Profile ID and subscriber density (density is optional but recommended), region plus UEIdentity(Including UEIdentity Type) or Service Profile ID plus UEIdentity(Including UEIdentity Type)."
    listMECPlatforms(input: ListMECPlatformsInput!): ListMECPlatformsResult!
    "List the geographical regions available, based on the user's bearer token. **Note:** Country code, Metropolitan area, Area and Zone are future functionality and will currently return a \"null\" value."
    listRegions: ListRegionsResult!
    "Returns a list of optimal Service Endpoints that client devices can connect to. **Note:** If a query is sent with all of the parameters, it will fail with a \"400\" error. You can search based on the following parameter combinations - Region plus Service Endpoints IDs and Subscriber density (density is optional but recommended), Region plus Service Endpoints IDs and UEIdentity(Including UEIdentity Type) and Service Endpoints IDs plus UEIdentity(Including UEIdentity Type)."
    listOptimalServiceEndpoints(input: ListOptimalServiceEndpointsInput!): ListOptimalServiceEndpointsResult!
    "Returns a list of all registered service endpoints."
    listAllServiceEndpoints: ListAllServiceEndpointsResult!
    "Returns endpoint information for all Service Endpoints registered to a specified serviceEndpointId."
    getServiceEndpoint(input: GetServiceEndpointInput!): [ResourcesEdgeHostedServiceWithProfileId!]
    "List all service profiles registered under your API key."
    listServiceProfiles: ListServiceProfilesResult!
    "Returns a specified service profile."
    getServiceProfile(input: GetServiceProfileInput!): ResourcesServiceProfileWithId!
    "Returns information about a specified account."
    getAccountInformation(input: GetAccountInformationInput!): Account!
    "Returns a list and details of all custom services and states defined for a specified account."
    listAccountStatesAndServices(input: ListAccountStatesAndServicesInput!): AccountStatesAndServices!
    "When HTTP status is 202, a URL will be returned in the Location header of the form /leads/{aname}?next={token}. This URL can be used to request the next set of leads."
    listAccountLeads(input: ListAccountLeadsInput!): AccountLeadsResult!
    "Returns a list of all device groups in a specified account."
    listDeviceGroups(input: ListDeviceGroupsInput!): [DeviceGroup!]
    "When HTTP status is 202, a URL will be returned in the Location header of the form /groups/{aname}/name/{gname}/?next={token}. This URL can be used to request the next set of groups."
    getDeviceGroupInformation(input: GetDeviceGroupInformationInput!): DeviceGroupDevicesData!
    "When HTTP status is 202, a URL will be returned in the Location header of the form /sms/{aname}/history?next={token}. This URL can be used to request the next set of messages."
    listDevicesSMSMessages(input: ListDevicesSMSMessagesInput!): SMSMessagesQueryResult!
    "Returns the name and endpoint URL of the callback listening services registered for a given account."
    listRegisteredCallbacks(input: ListRegisteredCallbacksInput!): [ConnectivityManagementCallback!]
    "Returns the current status of an asynchronous request that was made for a single device."
    getCurrentAsynchronousRequestStatus(input: GetCurrentAsynchronousRequestStatusInput!): AsynchronousRequestResult!
    "Returns a list of all data service plans that are associated with a specified billing account. When you send a request to /devices/actions/activate to activate a line of service you must specify the code for one of the service plans associated with your account."
    listAccountServicePlans(input: ListAccountServicePlansInput!): [ServicePlan!]
    "Download a completed asynchronous device location report."
    retrieveLocationReport(input: RetrieveLocationReportInput!): LocationReport!
    "Returns the current status of a requested device location report."
    getLocationReportStatus(input: GetLocationReportStatusInput!): LocationReportStatus!
    "This consents endpoint retrieves a list of excluded devices in an account."
    listExcludedDevices(input: ListExcludedDevicesInput!): DevicesConsentResult!
    "This subscriptions endpoint retrieves an account's current location subscription status."
    getLocationServiceSubscriptionStatus(input: GetLocationServiceSubscriptionStatusInput!): DeviceLocationSubscription!
    "Returns a list of all registered callback URLs for the account."
    listRegisteredCallbacks1(input: ListRegisteredCallbacks1Input!): [DeviceLocationCallback!]
    "This endpoint allows user to retrieve the list of all accounts managed by a primary account."
    listManagedAccount(input: ListManagedAccountInput!): ManagedAccountsGetAllResponse!
    "This subscriptions endpoint retrieves an account's current Software Management Service subscription status."
    getAccountSubscriptionStatus(input: GetAccountSubscriptionStatusInput!): V1AccountSubscription!
    "Returns information about an account's Software Management Services licenses and a list of licensed devices."
    getAccountLicenseStatus(input: GetAccountLicenseStatusInput!): AccountLicenseInfo!
    "Returns a list of devices from which licenses will be removed if the number of MRC licenses becomes less than the number of assigned licenses."
    listLicensesToRemove(input: ListLicensesToRemoveInput!): V1ListOfLicensesToRemove!
    "Lists all device firmware images available for an account, based on the devices registered to that account."
    listAvailableFirmware(input: ListAvailableFirmwareInput!): [Firmware!]
    "Returns information about a specified upgrade, include the target date of the upgrade, the list of devices in the upgrade, and the status of the upgrade for each device."
    listFirmwareUpgradeDetails(input: ListFirmwareUpgradeDetailsInput!): FirmwareUpgrade!
    "Returns the name and endpoint URL of the callback listening services registered for a given account."
    listRegisteredCallbacks2(input: ListRegisteredCallbacks2Input!): [RegisteredCallbacks!]
    "Returns an array of all devices in the specified account. Each device object includes information needed for managing firmware, including the device make and model, MDN and IMEI, and current firmware version."
    listAccountDevices(input: ListAccountDevicesInput!): DeviceListQueryResult!
    "Returns a list of all upgrades with a specified status."
    listUpgradesForSpecifiedStatus(input: ListUpgradesForSpecifiedStatusInput!): UpgradeListQueryResult!
    "Returns the upgrade history of the specified device from the previous six months."
    getDeviceFirmwareUpgradeHistory(input: GetDeviceFirmwareUpgradeHistoryInput!): [DeviceUpgradeHistory!]
    "This endpoint retrieves a FOTA subscription by account."
    getAccountSubscriptionStatus1(input: GetAccountSubscriptionStatus1Input!): FotaV2Subscription!
    "The endpoint allows user to list license usage."
    getAccountLicenseStatus1(input: GetAccountLicenseStatus1Input!): V2LicenseSummary!
    "The license cancel endpoint allows user to list registered license cancellation candidate devices."
    listLicensesToRemove1(input: ListLicensesToRemove1Input!): V2ListOfLicensesToRemove!
    "This endpoint allows user to get information of a software upgrade."
    getCampaignInformation(input: GetCampaignInformationInput!): CampaignSoftware!
    "This endpoint allows user to get the registered callback information."
    listRegisteredCallbacks3(input: ListRegisteredCallbacks3Input!): CallbackSummary!
    "This endpoint allows user to list a certain type of software of an account."
    listAvailableSoftware(input: ListAvailableSoftwareInput!): [SoftwarePackage!]
    "The device endpoint gets devices information of an account."
    listAccountDevices1(input: ListAccountDevices1Input!): V2AccountDeviceList!
    "The endpoint allows user to get software upgrade history of a device based on device IMEI."
    getDeviceFirmwareUpgradeHistory1(input: GetDeviceFirmwareUpgradeHistory1Input!): [DeviceSoftwareUpgrade!]
    "The report endpoint allows user to get campaign history of an account for specified status."
    getCampaignHistoryByStatus(input: GetCampaignHistoryByStatusInput!): V2CampaignHistory!
    "The report endpoint allows user to get the full list of device of a campaign."
    getCampaignDeviceStatus(input: GetCampaignDeviceStatusInput!): V2CampaignDevice!
    "Returns an array of all devices in the specified account for which logging is enabled."
    listDevicesWithLoggingEnabled(input: ListDevicesWithLoggingEnabledInput!): [DeviceLoggingStatus!]
    "Gets logs for a specific device."
    listDeviceLogs(input: ListDeviceLogsInput!): [DeviceLog!]
    "Check-in history can be retrieved for any device belonging to the account, not necessarily with logging enabled."
    getDeviceCheckInHistory(input: GetDeviceCheckInHistoryInput!): [CheckInHistoryItem!]
    "You can retrieve a list of configuration or supplementary of files for an account."
    getListOfFiles(input: GetListOfFilesInput!): RetrievesAvailableFilesResponseList!
    "This endpoint retrieves a FOTA subscription by account."
    getAccountSubscriptionStatus2(input: GetAccountSubscriptionStatus2Input!): FotaV3Subscription!
    "The endpoint allows user to list license usage."
    getAccountLicensesStatus(input: GetAccountLicensesStatusInput!): V3LicenseSummary!
    "This endpoint allows the user to retrieve campaign level information for a specified campaign."
    getCampaignInformation1(input: GetCampaignInformation1Input!): Campaign!
    "Retrieve a list of campaigns for an account that have a specified campaign status."
    getCampaignHistoryByStatus1(input: GetCampaignHistoryByStatus1Input!): V3CampaignHistory!
    "Retrieve campaign history for a specific device."
    getDeviceFirmwareUpgradeHistory2(input: GetDeviceFirmwareUpgradeHistory2Input!): [DeviceFirmwareUpgrade!]
    "Retrieve a list of all devices in a campaign and the status of each device."
    getCampaignDeviceStatus1(input: GetCampaignDeviceStatus1Input!): V3CampaignDevice!
    "This endpoint allows user to list the firmware of an account."
    listAvailableFirmware1(input: ListAvailableFirmware1Input!): [FirmwarePackage!]
    "Retrieve account device information such as reported firmware on the devices."
    getAccountDeviceInformation(input: GetAccountDeviceInformationInput!): V3AccountDeviceList!
    "This endpoint allows user to get the registered callback information."
    listRegisteredCallbacks4(input: ListRegisteredCallbacks4Input!): FotaV3CallbackSummary!
    "This endpoint retrieves a diagnostics subscription by account."
    getDiagnosticsSubscription(input: GetDiagnosticsSubscriptionInput!): DiagnosticsSubscription!
    "This endpoint retrieves diagnostics settings synchronously."
    listDiagnosticsSettings(input: ListDiagnosticsSettingsInput!): [DiagnosticObservationSetting!]
    "This endpoint allows user to get the registered callback information of an existing diagnostics subscription."
    getDiagnosticsSubscriptionCallbackInfo(input: GetDiagnosticsSubscriptionCallbackInfoInput!): [DeviceDiagnosticsCallback!]
    "Gets the list of a status for hyper-precise location devices."
    getDeviceHyperPreciseStatus(input: GetDeviceHyperPreciseStatusInput!): BullseyeServiceResult!
    "Find registered callback listener for account by account number."
    listRegisteredCallbacks5(input: ListRegisteredCallbacks5Input!): [CallbackCreated!]
    "Retrieves the current anomaly detection settings for an account."
    listAnomalyDetectionSettings(input: ListAnomalyDetectionSettingsInput!): AnomalyDetectionSettings!
    "This corresponds to the M2M-MC SOAP interface, ```GetTriggers```."
    listAnomalyDetectionTriggers: [GetTriggerResponseList!]
    "This corresponds to the M2M-MC SOAP interface, ```GetTriggers```."
    listAnomalyDetectionTriggerSettings(input: ListAnomalyDetectionTriggerSettingsInput!): [GetTriggerResponseList!]
    "Retrieves the values for a specific trigger ID."
    listAnomalyDetectionTriggerSettingsV2(input: ListAnomalyDetectionTriggerSettingsV2Input!): AnomalyTriggerResult!
    "Retrieves queued SMS messages sent by all M2M MC devices associated with an account."
    getSmsMessages(input: GetSmsMessagesInput!): SmsMessagesResponse!
    "Get the status of an asynchronous request made with the Device Actions."
    getAsynchronousRequestStatus(input: GetAsynchronousRequestStatusInput!): StatusResponse!
    getKpilist(input: GetKpilistInput!): KPIInfoList!
    getProfileList(input: GetProfileListInput!): MECProfileList!
    getMECPerformanceConsent(input: GetMECPerformanceConsentInput!): GetMECPerformanceConsentResponse!
    "Retrieves all of the available triggers for pseudo-MDN."
    getAllAvailableTriggers: TriggerValueResponse!
    "Retrieve the triggers associated with an account name."
    getAllTriggersByAccountName(input: GetAllTriggersByAccountNameInput!): TriggerValueResponse!
    "Retrieves all of the triggers for the specified account associated with the PromoAlert category"
    getAllTriggersByTriggerCategory: TriggerValueResponse2!
    "Retrives a specific trigger by its ID."
    getTriggersById(input: GetTriggersByIdInput!): TriggerValueResponse2!
    "Get the status of a request made with the Device Actions."
    getRequeststatususingget(input: GetRequeststatususinggetInput!): ESIMStatusResponse!
    "This endpoint allows user to download SAE J2735 MAP messages in ASN.1 UPER format. The area for the MAP messages is needed to be defined in the query."
    getDownloadmapdatamessage(input: GetDownloadmapdatamessageInput!): String!
}

type Mutation {
    "Register Service Endpoints of a deployed application to specified MEC Platforms."
    createRegisterserviceendpoints(input: CreateRegisterserviceendpointsInput!): RegisterServiceEndpointResult!
    "Update registered Service Endpoint information."
    updateServiceEndpoint(input: UpdateServiceEndpointInput!): UpdateServiceEndpointResult!
    "Deregister an application's Service Endpoint from the MEC Platform(s)."
    deleteDeregisterserviceendpoint(input: DeleteDeregisterserviceendpointInput!): DeregisterServiceEndpointResult!
    "Creates a service profile that describes the resource requirements of a service."
    createServiceProfile(input: CreateServiceProfileInput!): CreateServiceProfileResult!
    "Update the definition of a Service Profile."
    updateServiceProfile(input: UpdateServiceProfileInput!): UpdateServiceProfileResult!
    "Delete Service Profile based on unique service profile ID."
    deleteServiceProfile(input: DeleteServiceProfileInput!): DeleteServiceProfileResult!
    "If the devices do not already exist in the account, this API resource adds them before activation."
    createActivateservicefordevices(input: CreateActivateservicefordevicesInput!): DeviceManagementResult!
    "Use this API if you want to manage some device settings before you are ready to activate service for the devices."
    addDevices(input: AddDevicesInput!): [AddDevicesResult!]
    "Sends a CarrierService callback message for each device in the request when the contact information has been changed, or if there was a problem and the change could not be completed."
    updateDevicesContactInformation(input: UpdateDevicesContactInformationInput!): DeviceManagementResult!
    "Sends a CarrierService callback message for each device in the request when the custom fields have been changed, or if there was a problem and the change could not be completed."
    updateDevicesCustomFields(input: UpdateDevicesCustomFieldsInput!): DeviceManagementResult!
    "Deactivating service for a device may result in an early termination fee (ETF) being charged to the account, depending on the terms of the contract with Verizon. If your contract allows ETF waivers and if you want to use one for a particular deactivation, set the etfWaiver value to True."
    createDeactivateservicefordevices(input: CreateDeactivateservicefordevicesInput!): DeviceManagementResult!
    "Use this API to remove unneeded devices from an account."
    createDeletedeactivateddevices(input: CreateDeletedeactivateddevicesInput!): [DeleteDevicesResult!]
    "Returns information about a single device or information about all devices that match the given parameters. Returned information includes device provisioning state, service plan, MDN, MIN, and IP address."
    createListdevicesinformation(input: CreateListdevicesinformationInput!): AccountDeviceListResult!
    "Returns a list of all 4G devices with an ICCID (SIM) that was not activated with the expected IMEI (hardware) during a specified time frame."
    createListdeviceswithimeiiccidmismatch(input: CreateListdeviceswithimeiiccidmismatchInput!): DeviceMismatchListResult!
    "Move active devices from one billing account to another within a customer profile."
    updateMovedeviceswithinaccountsofprofile(input: UpdateMovedeviceswithinaccountsofprofileInput!): DeviceManagementResult!
    "Changes the provisioning state of one or more devices to a specified customer-defined service and state."
    updateDevicesState(input: UpdateDevicesStateInput!): DeviceManagementResult!
    "Changes the service plan for one or more devices."
    changeDevicesServicePlan(input: ChangeDevicesServicePlanInput!): DeviceManagementResult!
    "Suspends service for one or more devices."
    createSuspendservicefordevices(input: CreateSuspendservicefordevicesInput!): DeviceManagementResult!
    "Restores service to one or more suspended devices."
    createRestoreserviceforsuspendeddevices(input: CreateRestoreserviceforsuspendeddevicesInput!): DeviceManagementResult!
    "Checks whether specified devices are registered by the manufacturer with the Verizon network and are available to be activated."
    createCheckdevicesavailabilityforactivation(input: CreateCheckdevicesavailabilityforactivationInput!): DeviceManagementResult!
    "Each response includes a maximum of 500 records. To obtain more records, you can call the API multiple times, adjusting the earliest value each time to start where the previous request finished."
    createRetrievedeviceconnectionhistory(input: CreateRetrievedeviceconnectionhistoryInput!): ConnectionHistoryResult!
    "Changes or removes the CostCenterCode value or customer name and address (Primary Place of Use) for one or more devices."
    updateDevicesCostCenterCode(input: UpdateDevicesCostCenterCodeInput!): DeviceManagementResult!
    "Returns extended diagnostic information about a specified device, including connectivity, provisioning, billing and location status."
    createGetdeviceextendeddiagnosticinformation(input: CreateGetdeviceextendeddiagnosticinformationInput!): DeviceExtendedDiagnosticsResult!
    "Returns the provisioning history of a specified device during a specified time period."
    createListdevicesprovisioninghistory(input: CreateListdevicesprovisioninghistoryInput!): [DeviceProvisioningHistoryListResult!]
    "4G and GSM devices do not have a PRL."
    createListcurrentdevicesprlversion(input: CreateListcurrentdevicesprlversionInput!): DeviceManagementResult!
    "Returns DeviceSuspensionStatus callback messages containing the current device state and information on how many days a device has been suspended and can continue to be suspended."
    createGetdeviceservicesuspensionstatus(input: CreateGetdeviceservicesuspensionstatusInput!): DeviceManagementResult!
    "Returns the network data usage history of a device during a specified time period."
    createListdevicesusagehistory(input: CreateListdevicesusagehistoryInput!): DeviceUsageListResult!
    "The information is returned in a callback response, so you must register a URL for DeviceUsage callback messages using the POST /callbacks API."
    createRetrieveaggregatedeviceusagehistory(input: CreateRetrieveaggregatedeviceusagehistoryInput!): DeviceManagementResult!
    "Changes the identifier of a 3G or 4G device to match hardware changes made for a line of service. Use this request to transfer the line of service and the MDN to new hardware, or to change the MDN."
    updateDeviceId(input: UpdateDeviceIdInput!): DeviceManagementResult!
    "This corresponds to the M2M-MC SOAP interface, ```DeviceUploadService```."
    createDeviceupload(input: CreateDeviceuploadInput!): RequestResponse!
    "Gets billed usage for for either multiple devices or an entire billing account."
    createBilledusageinfo(input: CreateBilledusageinfoInput!): DeviceManagementResult!
    "Allows you to associate your own usage segmentation label with a device."
    createUsagesegmentationlabelassociation(input: CreateUsagesegmentationlabelassociationInput!): DeviceManagementResult!
    "Allow customers to remove the associated label from a device."
    deleteUsagesegmentationlabeldeletion(input: DeleteUsagesegmentationlabeldeletionInput!): DeviceManagementResult!
    "Uploads and activates device identifiers and SKUs for new devices from OEMs to Verizon."
    createActivationorderstatus(input: CreateActivationorderstatusInput!): DeviceManagementResult!
    "Checks the status of an activation order and lists where the order is in the provisioning process."
    uploadDeviceIdentifier(input: UploadDeviceIdentifierInput!): DeviceManagementResult!
    "Create a new device group and optionally add devices to the group. Device groups can make it easier to manage similar devices and to get reports on their usage."
    createDeviceGroup(input: CreateDeviceGroupInput!): ConnectivityManagementSuccessResult!
    "Make changes to a device group, including changing the name and description, and adding or removing devices."
    updateDeviceGroup(input: UpdateDeviceGroupInput!): ConnectivityManagementSuccessResult!
    "Deletes a device group from the account. Devices in the group are moved to the default device group and are not deleted from the account."
    deleteDeviceGroup(input: DeleteDeviceGroupInput!): ConnectivityManagementSuccessResult!
    "The messages are queued on the ThingSpace Platform and sent as soon as possible, but they may be delayed due to traffic and routing considerations."
    createSendsmstodevice(input: CreateSendsmstodeviceInput!): DeviceManagementResult!
    "Tells the ThingSpace Platform to start sending mobile-originated SMS messages through the EnhancedConnectivityService callback service. SMS messages from devices are queued until they are retrieved by your application, either by callback or synchronously with GET /sms/{accountName}/history."
    updateStartqueuedsmsdelivery(input: UpdateStartqueuedsmsdeliveryInput!): ConnectivityManagementSuccessResult!
    "Initiates a Connectivity Management session and returns a VZ-M2M session token that is required in subsequent API requests."
    createStartconnectivitymanagementsession(input: CreateStartconnectivitymanagementsessionInput!): LogInResult!
    "Ends a Connectivity Management session."
    createEndconnectivitymanagementsession: LogOutRequest!
    "The new password is effective immediately. Passwords do not expire, but Verizon recommends changing your password every 90 days."
    updateResetconnectivitymanagementpassword(input: UpdateResetconnectivitymanagementpasswordInput!): SessionResetPasswordResult!
    "You are responsible for creating and running a listening process on your server at that URL."
    createRegistercallback(input: CreateRegistercallbackInput!): CallbackActionResult!
    "Stops ThingSpace from sending callback messages for the specified account and service."
    deleteDeregistercallback(input: DeleteDeregistercallbackInput!): CallbackActionResult!
    "If the devices do not already exist in the account, this API resource adds them before activation."
    createDevicereachabilitystatususingpost(input: CreateDevicereachabilitystatususingpostInput!): DeviceManagementResult!
    "Retrieve all the active monitors."
    createRetrieveactivemonitorsusingpost(input: CreateRetrieveactivemonitorsusingpostInput!): DeviceManagementResult!
    "Uses the profile to bring the device under management."
    createActivatedevicethroughprofile(input: CreateActivatedevicethroughprofileInput!): RequestResponse!
    "Uses the profile to activate the device."
    createProfiletoactivatedevice(input: CreateProfiletoactivatedeviceInput!): RequestResponse!
    "Uses the profile to deactivate the device."
    createProfiletodeactivatedevice(input: CreateProfiletodeactivatedeviceInput!): RequestResponse!
    "Allows the profile to set the fallback attribute to the device."
    createProfiletosetfallbackattribute(input: CreateProfiletosetfallbackattributeInput!): RequestResponse!
    createDevicereachability(input: CreateDevicereachabilityInput!): RequestResponse!
    deleteStopdevicereachability(input: DeleteStopdevicereachabilityInput!): RequestResponse!
    "Downloads an eUICC local profile to devices and enables the profile."
    createDownloadlocalprofiletoenable(input: CreateDownloadlocalprofiletoenableInput!): DeviceManagementResult!
    "Downloads an eUICC local profile to devices and leaves the profile disabled."
    createDownloadlocalprofiletodisable(input: CreateDownloadlocalprofiletodisableInput!): DeviceManagementResult!
    "Enable a local profile that has been downloaded to eUICC devices."
    createEnablelocalprofile(input: CreateEnablelocalprofileInput!): RequestResponse!
    "Disable a local profile on eUICC devices. The default or boot profile will become the enabled profile."
    createDisablelocalprofile(input: CreateDisablelocalprofileInput!): RequestResponse!
    "Delete a local profile from eUICC devices. If the local profile is enabled, it will first be disabled and the boot or default profile will be enabled."
    createDeletelocalprofile(input: CreateDeletelocalprofileInput!): RequestResponse!
    "This locations endpoint retrieves the locations for a list of devices."
    createListdeviceslocationssynchronous(input: CreateListdeviceslocationssynchronousInput!): [Location!]
    "Requests the current or cached location of up to 10,000 IoT or consumer devices (phones, tablets. etc.). This request returns a synchronous transaction ID, and the location information for each device is returned asynchronously as a DeviceLocation callback message."
    createListdeviceslocationsasynchronous(input: CreateListdeviceslocationsasynchronousInput!): SynchronousLocationRequestResult!
    "Cancel a queued or unfinished device location request."
    deleteCanceldevicelocationrequest(input: DeleteCanceldevicelocationrequestInput!): TransactionID!
    "Request an asynchronous device location report."
    createLocationReport(input: CreateLocationReportInput!): AsynchronousLocationRequestResult!
    "Cancel a queued device location report."
    deleteCancelqueuedlocationreportgeneration(input: DeleteCancelqueuedlocationreportgenerationInput!): TransactionID!
    "This consents endpoint sets a new exclusion list."
    createExcludedevices(input: CreateExcludedevicesInput!): DeviceLocationSuccessResult!
    "Removes devices from the exclusion list so that they can be located with Device Location Services requests."
    removeDevicesFromExclusionList(input: RemoveDevicesFromExclusionListInput!): DeviceLocationSuccessResult!
    "This endpoint allows user to search for billable usage for accounts based on the provided date range."
    createGetlocationserviceusage(input: CreateGetlocationserviceusageInput!): String!
    "Provide a URL to receive messages from a ThingSpace callback service."
    createRegistercallback1(input: CreateRegistercallback1Input!): CallbackRegistrationResult!
    "Deregister a URL to stop receiving callback messages."
    deleteDeregistercallback1(input: DeleteDeregistercallback1Input!): DeviceLocationSuccessResult!
    "Create a new usage trigger, which will send an alert when the number of device location service transactions reaches a specified percentage of the monthly subscription amount."
    createNewTrigger(input: CreateNewTriggerInput!): UsageTriggerResponse!
    "Update an existing usage trigger"
    updateTrigger(input: UpdateTriggerInput!): UsageTriggerResponse!
    "eletes the specified usage trigger from the given account"
    deleteTrigger(input: DeleteTriggerInput!): DeviceLocationSuccessResult!
    "This endpoint allows user to add managed accounts to a primary account."
    addAccount(input: AddAccountInput!): ManagedAccountsAddResponse!
    "Activates a managed billing service relationship between a managed account and the primary account."
    createManagedaccountaction(input: CreateManagedaccountactionInput!): ManagedAccountsProvisionResponse!
    "Deactivates a managed billing service relationship between a managed account and the primary account."
    createCancelmanagedaccountaction(input: CreateCancelmanagedaccountactionInput!): ManagedAccountCancelResponse!
    "Assigns licenses to a specified list of devices so that firmware upgrades can be scheduled for those devices."
    createAssignlicensestodevices(input: CreateAssignlicensestodevicesInput!): V1LicensesAssignedRemovedResult!
    "Remove unused licenses from device."
    createRemovelicensesfromdevices(input: CreateRemovelicensesfromdevicesInput!): V1LicensesAssignedRemovedResult!
    "Creates a list of devices from which licenses will be removed if the number of MRC licenses becomes less than the number of assigned licenses."
    createListOfLicensesToRemove(input: CreateListOfLicensesToRemoveInput!): V1ListOfLicensesToRemoveResult!
    "Deletes the entire list of cancellation candidate devices."
    deleteListOfLicensesToRemove(input: DeleteListOfLicensesToRemoveInput!): FotaV1SuccessResult!
    "Schedules a firmware upgrade for devices."
    createSchedulefirmwareupgrade(input: CreateSchedulefirmwareupgradeInput!): FirmwareUpgrade!
    "Add or remove devices from a scheduled upgrade."
    updateFirmwareUpgradeDevices(input: UpdateFirmwareUpgradeDevicesInput!): FirmwareUpgradeChangeResult!
    "Cancel a scheduled firmware upgrade."
    deleteCancelscheduledfirmwareupgrade(input: DeleteCancelscheduledfirmwareupgradeInput!): FotaV1SuccessResult!
    "Registers a URL to receive RESTful messages from a callback service when new firmware versions are available and when upgrades start and finish."
    createRegistercallback2(input: CreateRegistercallback2Input!): FotaV1CallbackRegistrationResult!
    "Deregisters the callback endpoint and stops ThingSpace from sending FOTA callback messages for the specified account."
    deleteDeregistercallback2(input: DeleteDeregistercallback2Input!): FotaV1SuccessResult!
    "This endpoint allows user to assign licenses to a list of devices."
    createAssignlicensestodevices1(input: CreateAssignlicensestodevices1Input!): V2LicensesAssignedRemovedResult!
    "This endpoint allows user to remove licenses from a list of devices."
    createRemovelicensesfromdevices1(input: CreateRemovelicensesfromdevices1Input!): V2LicensesAssignedRemovedResult!
    "The license cancel endpoint allows user to create a list of license cancellation candidate devices."
    createListOfLicensesToRemove1(input: CreateListOfLicensesToRemove1Input!): V2ListOfLicensesToRemoveResult!
    "This endpoint allows user to delete a created cancel candidate device list."
    deleteListOfLicensesToRemove1(input: DeleteListOfLicensesToRemove1Input!): FotaV2SuccessResult!
    "This endpoint allows user to schedule a software upgrade."
    createSchedulecampaignfirmwareupgrade(input: CreateSchedulecampaignfirmwareupgradeInput!): CampaignSoftware!
    "This endpoint allows user to Add or Remove devices to an existing software upgrade."
    updateCampaignFirmwareDevices(input: UpdateCampaignFirmwareDevicesInput!): V2AddOrRemoveDeviceResult!
    "This endpoint allows user to cancel software upgrade. A software upgrade already started can not be cancelled."
    deleteCancelcampaign(input: DeleteCancelcampaignInput!): FotaV2SuccessResult!
    "This endpoint allows user to change campaign dates and time windows. Fields which need to remain unchanged should be also provided."
    updateCampaignDates(input: UpdateCampaignDatesInput!): CampaignSoftware!
    "You can upload configuration files and schedule them in a campaign to devices."
    createSchedulefileupgrade(input: CreateSchedulefileupgradeInput!): UploadAndScheduleFileResponse!
    "Campaign time windows for downloading and installing software are available as long as the device OEM supports this."
    createScheduleswupgradehttpdevices(input: CreateScheduleswupgradehttpdevicesInput!): UploadAndScheduleFileResponse!
    "This endpoint allows user to update the HTTPS callback address."
    updateCallback(input: UpdateCallbackInput!): FotaV2CallbackRegistrationResult!
    "This endpoint allows user to create the HTTPS callback address."
    createRegistercallback3(input: CreateRegistercallback3Input!): FotaV2CallbackRegistrationResult!
    "This endpoint allows user to delete a previously registered callback URL."
    deleteDeregistercallback3(input: DeleteDeregistercallback3Input!): FotaV2SuccessResult!
    "Each customer may have a maximum of 20 devices enabled for logging."
    updateEnableloggingfordevices(input: UpdateEnableloggingfordevicesInput!): [DeviceLoggingStatus!]
    "Turn logging off for a list of devices."
    deleteDisableloggingfordevices(input: DeleteDisableloggingfordevicesInput!): String
    "Enables logging for a specific device."
    updateEnabledevicelogging(input: UpdateEnabledeviceloggingInput!): DeviceLoggingStatus!
    "Disables logging for a specific device."
    deleteDisabledevicelogging(input: DeleteDisabledeviceloggingInput!): String
    "Uploads a configuration/supplementary file for an account. ThingSpace generates a fileName after the upload and is returned in the response."
    uploadConfigFile(input: UploadConfigFileInput!): UploadConfigurationFilesResponse!
    "This endpoint allows user to assign licenses to a list of devices."
    createAssignlicensestodevices2(input: CreateAssignlicensestodevices2Input!): V3LicenseAssignedRemovedResult!
    "This endpoint allows user to remove licenses from a list of devices."
    createRemovelicensesfromdevices2(input: CreateRemovelicensesfromdevices2Input!): V3LicenseAssignedRemovedResult!
    "This endpoint allows a user to schedule a firmware upgrade for a list of devices."
    createSchedulecampaignfirmwareupgrade1(input: CreateSchedulecampaignfirmwareupgrade1Input!): FirmwareCampaign!
    "This endpoint allows user to Add or Remove devices to an existing campaign."
    updateCampaignFirmwareDevices1(input: UpdateCampaignFirmwareDevices1Input!): V3AddOrRemoveDeviceResult!
    "This endpoint allows user to change campaign dates and time windows. Fields which need to remain unchanged should be also provided."
    updateCampaignDates1(input: UpdateCampaignDates1Input!): FirmwareCampaign!
    "This endpoint allows user to cancel a firmware campaign. A firmware campaign already started can not be cancelled."
    deleteCancelcampaign1(input: DeleteCancelcampaign1Input!): FotaV3SuccessResult!
    "Synchronize ThingSpace with the FOTA server for up to 100 devices."
    updateSynchronizedevicefirmware(input: UpdateSynchronizedevicefirmwareInput!): DeviceFirmwareList!
    "Ask a device to report its firmware version asynchronously."
    updateReportdevicefirmware(input: UpdateReportdevicefirmwareInput!): DeviceFirmwareVersionUpdateResult!
    "Retrieve device information for a list of devices on an account."
    createListaccountdevicesinformation(input: CreateListaccountdevicesinformationInput!): DeviceListResult!
    "This endpoint allows the user to update the HTTPS callback address."
    updateCallback1(input: UpdateCallback1Input!): FotaV3CallbackRegistrationResult!
    "This endpoint allows the user to create the HTTPS callback address."
    createRegistercallback4(input: CreateRegistercallback4Input!): FotaV3CallbackRegistrationResult!
    "This endpoint allows user to delete a previously registered callback URL."
    deleteDeregistercallback4(input: DeleteDeregistercallback4Input!): FotaV3SuccessResult!
    "Assigns SIM-Secure for IoT licenses to SIMs."
    createAssignlicensetodevices(input: CreateAssignlicensetodevicesInput!): SecuritySuccessResult!
    "Unassigns SIM-Secure for IoT Flexible and Flexible Bundle license from SIMs."
    deleteUnassignlicensetodevices(input: DeleteUnassignlicensetodevicesInput!): SecuritySuccessResult!
    "Retrieves the total number of SIM-Secure for IoT subscription licenses purchased for your account by license type, and lists the number of licenses assigned and available for each license type."
    createListaccountsubscriptions(input: CreateListaccountsubscriptionsInput!): SecuritySubscriptionResult!
    "Query the most recent data for Key Performance Indicators (KPIs) like network availability, MEC hostnames and more."
    createQuerymecperformancemetrics(input: CreateQuerymecperformancemetricsInput!): MECPerformanceMetrics!
    "This endpoint allows the user to start or change observe diagnostics."
    createStartdiagnosticsobservation(input: CreateStartdiagnosticsobservationInput!): DiagnosticsObservationResult!
    "This endpoint allows the user to stop or reset observe diagnostics."
    deleteStopdiagnosticsobservation(input: DeleteStopdiagnosticsobservationInput!): DiagnosticsObservationResult!
    "This endpoint allows the user to get the history data."
    createGetdiagnosticshistory(input: CreateGetdiagnosticshistoryInput!): [History!]
    "This endpoint allows user update the callback HTTPS address of an existing diagnostics subscription."
    createRegisterdiagnosticscallbackurl(input: CreateRegisterdiagnosticscallbackurlInput!): DeviceDiagnosticsCallback!
    "This endpoint allows user to delete a registered callback URL and credential."
    deleteUnregisterdiagnosticscallback(input: DeleteUnregisterdiagnosticscallbackInput!): DeviceDiagnosticsCallback!
    "Performs a device reboot or a factory reset on the modem portion of the device."
    createDecivesrestart(input: CreateDecivesrestartInput!): DiagnosticsObservationResult!
    "Search for targets by property values. Returns an array of all matching target resources."
    createQuerytarget(input: CreateQuerytargetInput!): [Target!]
    "Remove a target from a ThingSpace account."
    createDeletetarget(input: CreateDeletetargetInput!): String
    "Define a target to receive data streams, alerts, or callbacks. After creating the target resource, use its ID in a subscription to set up a data stream."
    createTarget(input: CreateTargetInput!): Target!
    "Create a unique string that ThingSpace will pass to AWS for increased security."
    createGeneratetargetexternalid(input: CreateGeneratetargetexternalidInput!): GenerateExternalIDResult!
    "Deploy a new Azure IoT Central application based on the Verizon ARM template within the specified Azure Active Directory account."
    createAzureCentralIoTApplication(input: CreateAzureCentralIoTApplicationInput!): CreateIoTApplicationResponse!
    "Create a subscription to define a streaming channel that sends data from devices in the account to an endpoint defined in a target resource."
    createSubscription(input: CreateSubscriptionInput!): Subscription!
    "Search for subscriptions by property values. Returns an array of all matching subscription resources."
    createQuerysubscription(input: CreateQuerysubscriptionInput!): [Subscription!]
    "Remove a subscription from a ThingSpace account."
    createDeletesubscription(input: CreateDeletesubscriptionInput!): String
    "Change configuration values on a device, such as setting how often a device records and reports sensor readings."
    updateDevicesConfigurationValue(input: UpdateDevicesConfigurationValueInput!): ChangeConfigurationResponse!
    "Find devices by property values. Returns an array of all matching device resources."
    createFinddevicebypropertyvalues(input: CreateFinddevicebypropertyvaluesInput!): FindDeviceByPropertyResponseList!
    "Search for devices by property values. Returns an array of all matching device resources."
    createSearchdevicesresourcesbypropertyvalues(input: CreateSearchdevicesresourcesbypropertyvaluesInput!): SearchDeviceByPropertyResponseList!
    "Search device event history to find events that match criteria.Sensor readings, configuration changes, and other device data are all stored as events."
    createSearchdeviceeventhistory(input: CreateSearchdeviceeventhistoryInput!): SearchDeviceEventHistoryResponseList!
    "Returns the readings of a specified sensor, with the most recent reading first. Sensor readings are stored as events; this request an array of events."
    createSearchsensorreadings(input: CreateSearchsensorreadingsInput!): SearchSensorHistoryResponseList!
    "Remove a device from a ThingSpace account."
    createDeletedevicefromaccount(input: CreateDeletedevicefromaccountInput!): String
    "Enable/disable hyper-precise service for a device."
    updateDeviceHyperPreciseStatus(input: UpdateDeviceHyperPreciseStatusInput!): BullseyeServiceResult!
    "Calculate aggregated report per day with number of sessions and usage information. User will receive synchronous response for specified list of devices (Max 10) and date range (Max 180 days)."
    createCalculateaggregatedreportsynchronous(input: CreateCalculateaggregatedreportsynchronousInput!): AggregateSessionReport!
    "Calculate aggregated report per day with number of sessions and usage information. User will receive an asynchronous callback for the specified list of devices (Max 10000) and date range (Max 180 days)."
    createCalculateaggregatedreportasynchronous(input: CreateCalculateaggregatedreportasynchronousInput!): AggregatedReportCallbackResult!
    "Detailed report of session duration and number of bytes transferred per day."
    createGetsessionsreport(input: CreateGetsessionsreportInput!): SessionReport!
    "Registers a URL at which an account receives asynchronous responses and other messages from a ThingSpace Platform callback service. The messages are REST messages. You are responsible for creating and running a listening process on your server at that URL to receive and parse the messages."
    createRegistercallback5(input: CreateRegistercallback5Input!): CallbackRegistered!
    "Stops ThingSpace from sending callback messages for the specified account and listener name."
    deleteDeregistercallback5(input: DeleteDeregistercallback5Input!): String
    "Uses the subscribed account ID to activate anomaly detection and set threshold values."
    createActivateanomalydetection(input: CreateActivateanomalydetectionInput!): IntelligenceSuccessResult!
    "Resets the thresholds to zero."
    updateResetanomalydetectionparameters(input: UpdateResetanomalydetectionparametersInput!): IntelligenceSuccessResult!
    "This corresponds to the M2M-MC SOAP interface, ```UpdateTriggerRequest```."
    updateAnomalyDetectionTrigger(input: UpdateAnomalyDetectionTriggerInput!): AnomalyDetectionTrigger!
    "This corresponds to the M2M-MC SOAP interface, ```CreateTrigger```."
    createAnomalyDetectionTrigger(input: CreateAnomalyDetectionTriggerInput!): AnomalyDetectionTrigger!
    "Deletes a specific trigger ID"
    deleteAnomalyDetectionTrigger(input: DeleteAnomalyDetectionTriggerInput!): AnomalyDetectionTrigger!
    "Creates the trigger to identify an anomaly."
    createAnomalyDetectionTriggerV2(input: CreateAnomalyDetectionTriggerV2Input!): AnomalyDetectionTrigger!
    "Updates an existing trigger using the account name."
    updateAnomalyDetectionTriggerV2(input: UpdateAnomalyDetectionTriggerV2Input!): IntelligenceSuccessResult!
    "WNP Query for current network condition."
    createNearrealtimenetworkconditions(input: CreateNearrealtimenetworkconditionsInput!): WNPRequestResponse!
    "Run a report to determine network types available and available coverage. Network types covered include: CAT-M, NB-IOT, LTE, LTE-AWS and 5GNW."
    createDomestic4gand5gnationwidenetworkcoverage(input: CreateDomestic4gand5gnationwidenetworkcoverageInput!): WNPRequestResponse!
    "Identify the direction and general distance of nearby cell sites and the technology supported by the equipment."
    createSiteproximity(input: CreateSiteproximityInput!): WNPRequestResponse!
    "A report of a specific device's service scores over a 30 day period."
    createDeviceexperience30dayshistory(input: CreateDeviceexperience30dayshistoryInput!): WNPRequestResponse!
    "Run a report to view the latest device experience score for specific devices."
    createDeviceexperiencebulklatest(input: CreateDeviceexperiencebulklatestInput!): WNPRequestResponse!
    "Use this query for Fixed Wireless Qualification of an address. Network types include: LTE, C-BAND and MMWAVE."
    createDomestic4gand5gfixedwirelessqualification(input: CreateDomestic4gand5gfixedwirelessqualificationInput!): WNPRequestResponse!
    "Activate a device with either a lead or local profile."
    createActivateadeviceprofile(input: CreateActivateadeviceprofileInput!): GIORequestResponse!
    "Enable a device lead or local profile."
    createEnableadeviceprofile(input: CreateEnableadeviceprofileInput!): GIORequestResponse!
    "Deactivate the lead or local profile. **Note:** to reactivate the profile, use the **Activate** endpoint above."
    createDeactivateadeviceprofile(input: CreateDeactivateadeviceprofileInput!): GIORequestResponse!
    "Enable the Global IoT Orchestration device profile for download."
    createEnableadeviceprofilefordownload(input: CreateEnableadeviceprofilefordownloadInput!): GIORequestResponse!
    "Download a Global IoT Orchestration device profile."
    createDownloadadeviceprofile(input: CreateDownloadadeviceprofileInput!): GIORequestResponse!
    "Delete a device profile for Global IoT Orchestration. **Note:** the profile must be deactivated first!"
    createDeleteadeviceprofile(input: CreateDeleteadeviceprofileInput!): GIORequestResponse!
    "Sends an SMS message to one device. Messages are queued on the M2M MC Platform and sent as soon as possible, but they may be delayed due to traffic and routing considerations."
    createSendansmsmessage(input: CreateSendansmsmessageInput!): GIORequestResponse!
    "Starts delivery of SMS messages for the specified account."
    updateStartsmsmessagedelivery(input: UpdateStartsmsmessagedeliveryInput!): SuccessResponse!
    "Returns a list of sms history for a given device during a specified time frame."
    createListsmsmessagehistory(input: CreateListsmsmessagehistoryInput!): GIORequestResponse!
    "Allows the profile to fetch the complete device list. This works with Verizon US and Global profiles."
    createRetrievetheglobaldevicelist(input: CreateRetrievetheglobaldevicelistInput!): GIORequestResponse!
    "Retreive the provisioning history of a specific device or devices."
    createRetrievedeviceprovisioninghistory(input: CreateRetrievedeviceprovisioninghistoryInput!): GIORequestResponse!
    "Creates a QoS elevation subscription ID and activates the subscription."
    createAThingSpaceQualityOfServiceAPISubscription(input: CreateAThingSpaceQualityOfServiceAPISubscriptionInput!): 201success!
    "Stops an active ThingSpace Quality of Service API subscription using the account name and the subscription ID."
    deleteStopathingspacequalityofserviceapisubscription(input: DeleteStopathingspacequalityofserviceapisubscriptionInput!): 201success!
    changepmecdevicestateActivate(input: ChangepmecdevicestateActivateInput!): ChangeMecDeviceStateResponse!
    changepmecdevicestateBulkdeactivate(input: ChangepmecdevicestateBulkdeactivateInput!): ChangeMecDeviceStateResponse!
    changePmecDeviceProfile(input: ChangePmecDeviceProfileInput!): ChangeMecDeviceProfileResponse!
    changePmecDeviceIPaddressBulk(input: ChangePmecDeviceIPaddressBulkInput!): ChangeMecDeviceIPAddressResponse!
    "Retrieves the usage history of a device during the promotion period."
    createGetpromodeviceusagehistory(input: CreateGetpromodeviceusagehistoryInput!): ResponsetoUsageQuery!
    "Retrieves the aggregate usage for an account using pseudo-MDN during the promotional period using a callback."
    createGetpromodeviceaggregateusagehistory(input: CreateGetpromodeviceaggregateusagehistoryInput!): UsageRequestResponse!
    "Updates the promotional triggers for pseudo-MDN."
    updateAllAvailableTriggers(input: UpdateAllAvailableTriggersInput!): Success!
    "Uses the profile to activate the SIM."
    createSetactivateusingpost(input: CreateSetactivateusingpostInput!): ESIMRequestResponse!
    "Uses the profile to deactivate the SIM."
    createSetdeactivateusingpost(input: CreateSetdeactivateusingpostInput!): ESIMRequestResponse!
    "Retreive the provisioning history of a specific device or devices."
    createDeviceprovhistoryusingpost(input: CreateDeviceprovhistoryusingpostInput!): ESIMRequestResponse!
    "With this API call the users (clients) register themselves as Vendors to the IMP system. Therefore, when a registration is initiated from a device or software service to the IMP system with the registered VendorID, then the client registration will be authorized."
    createRegisterimpvendor(input: CreateRegisterimpvendorInput!): VendorRegistrationResponse!
    "With this API call the users (clients) can unregister themselves from the IMP system. The devices and services for this Vendor will no longer be able to use the IMP Message Exchange."
    deleteUnregisterimpvendor(input: DeleteUnregisterimpvendorInput!): String
    "With this API call the user (client) registers its device or software service to the IMP system. Therefore, when a connection is initiated from the device or software service to the IMP system along with the credential provided by this registration call, then the connection will be authorized.\nNote 1: One user can register multiple devices or software services, which can all be used at the same time.\n\nNote 2: The user needs to authenticate with their ThingSpace credentials and request a bearer token in order to call this API."
    createRegisterimpdevice(input: CreateRegisterimpdeviceInput!): ClientRegistrationResponse!
    "With this API call the user (client) can unregister its devices and software services from the IMP system. The unregistered devices and services will no longer be able to use the IMP Message Exchange."
    deleteUnregisterimpdevice(input: DeleteUnregisterimpdeviceInput!): String
    "With this API call the  or software service requests the MQTT URL for the location that it needs to connect. To determine the proper URL the device or software service needs to provide its ID (the one that was provided in the registration request), location (GPS coordinates), and whether it is on the Verizon cellular network or not.\n\nNote: The user needs to authenticate with their ThingSpace credentials and request a bearer token in order to call this API."
    createRetrievemqtturl(input: CreateRetrievemqtturlInput!): ConnectionResponse!
    "This endpoint allows user to upload map messages in asn.1 J2735 encoded format. The MapData can have one or more intersections."
    uploadMapDataMessage(input: UploadMapDataMessageInput!): String!
}

schema {
    mutation: Mutation
    query: Query
}
